<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Minchao Wu. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Minchao Wu, Chris Hughes</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import data.list.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  # Minimum and maximum of lists</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  ## Main definitions</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  The main definitions are `argmax`, `argmin`, `minimum` and `maximum` for lists.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  `argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15    `f a = f b`, it returns whichever of `a` or `b` comes first in the list.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16    `argmax f []` = none`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  `[]`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  namespace list</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  variables {α : Type*} {β : Type*} [decidable_linear_order β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  /-- Auxiliary definition to define `argmax` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  def argmax₂ (f : α → β) (a : option α) (b : α) : option α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  option.cases_on a (some b) (λ c, if f b ≤ f c then some c else some b)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} {C : option.{u} α → Sort l} (n : option.{u} α), C (@option.none.{u} α) → (Π (val : α), C (@option.some.{u} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  /-- `argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    `f a = f b`, it returns whichever of `a` or `b` comes first in the list.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    `argmax f []` = none` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  def argmax (f : α → β) (l : list α) : option α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  l.foldl (argmax₂ f) none</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, (α → β → α) → α → list.{u_1} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  /-- `argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    `f a = f b`, it returns whichever of `a` or `b` comes first in the list.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    `argmin f []` = none` -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  def argmin (f : α → β) (l : list α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  @argmax _ (order_dual β) _ f l</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  @[simp] lemma argmax_two_self (f : α → β) (a : α) : argmax₂ f (some a) a = a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  if_pos (le_refl _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] (a : α), @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  @[simp] lemma argmax_nil (f : α → β) : argmax f [] = none := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  @[simp] lemma argmin_nil (f : α → β) : argmin f [] = none := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  @[simp] lemma argmax_singleton {f : α → β} {a : α} : argmax f [a] = some a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  @[simp] lemma argmin_singleton {f : α → β} {a : α} : argmin f [a] = a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  @[simp] lemma foldl_argmax₂_eq_none {f : α → β} {l : list α} {o : option α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    l.foldl (argmax₂ f) o = none ↔ l = [] ∧ o = none :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, (α → β → α) → α → list.{u_1} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  list.reverse_rec_on l (by simp) $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.reverse_rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 539, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : list.{u_1} α → Prop} (l : list.{u_1} α), C (@list.nil.{u_1} α) → (∀ (l : list.{u_1} α) (a : α), C l → C (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) → C l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α
⊢ iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o (@list.nil.{u_1} α))
       (@option.none.{u_1} α))
    (and (@eq.{u_1+1} (list.{u_1} α) (@list.nil.{u_1} α) (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    (assume tl hd, by simp [argmax₂];</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → option.{?l_1} α → α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α,
tl : list.{u_1} α,
hd : α
⊢ iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.none.{u_1} α))
    (and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))) →
  iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))
       (@option.none.{u_1} α))
    (and
       (@eq.{u_1+1} (list.{u_1} α)
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))
          (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55      cases foldl (argmax₂ f) o tl; simp; try {split_ifs}; simp)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 851, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, (α → β → α) → α → list.{u_1} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`try { t }` tries to apply tactic `t`, but succeeds whether or not `t` succeeds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='try'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α,
tl : list.{u_1} α,
hd : α
⊢ iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.none.{u_1} α))
    (and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))) →
  iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))
       (@option.none.{u_1} α))
    (and
       (@eq.{u_1+1} (list.{u_1} α)
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))
          (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α,
tl : list.{u_1} α,
hd val : α
⊢ (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α) →
   not (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))) →
  not
    (@eq.{u_1+1} (option.{u_1} α)
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f hd)
             (f val))
          (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
          (option.{u_1} α)
          (@option.some.{u_1} α val)
          (@option.some.{u_1} α hd))
       (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α,
tl : list.{u_1} α,
hd val : α,
h :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f hd)
    (f val)
⊢ (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α) →
   not (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))) →
  not false

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α,
tl : list.{u_1} α,
hd val : α,
h :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f hd)
       (f val))
⊢ (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α) →
   not (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))) →
  not false'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α,
o : option.{u_1} α,
tl : list.{u_1} α,
hd : α
⊢ iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.none.{u_1} α))
    (and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))) →
  iff
    (@eq.{u_1+1} (option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))
       (@option.none.{u_1} α))
    (and
       (@eq.{u_1+1} (list.{u_1} α)
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))
          (@list.nil.{u_1} α))
       (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  private theorem le_of_foldl_argmax₂ {f : α → β} {l} : Π {a m : α} {o : option α}, a ∈ l →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='option'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    m ∈ foldl (argmax₂ f) o l → f a ≤ f m :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β → α) → α → list.{v} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  list.reverse_rec_on l</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.reverse_rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 539, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : list.{u_1} α → Prop} (l : list.{u_1} α), C (@list.nil.{u_1} α) → (∀ (l : list.{u_1} α) (a : α), C l → C (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) → C l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    (λ _ _ _ h, absurd h $ not_mem_nil _)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.not_mem_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) _x (@list.nil.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) _x (@list.nil.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} (a : α), not (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ ∀ (l : list.{u_1} α) (a : α),
    (∀ {a m : α} {o : option.{u_1} α},
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
         (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o l) →
       @has_le.le.{u_2} β
         (@preorder.to_has_le.{u_2} β
            (@partial_order.to_preorder.{u_2} β
               (@lattice.semilattice_inf.to_partial_order.{u_2} β
                  (@lattice.lattice.to_semilattice_inf.{u_2} β
                     (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
         (f a)
         (f m)) →
    ∀ {a_1 m : α} {o : option.{u_1} α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
        (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
           (@list.cons.{u_1} α a (@list.nil.{u_1} α))) →
      @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
        (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
           (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
              (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f a_1)
        (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62      intros tl _ ih _ _ _ h ho,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ ∀ (l : list.{u_1} α) (a : α),
    (∀ {a m : α} {o : option.{u_1} α},
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
         (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o l) →
       @has_le.le.{u_2} β
         (@preorder.to_has_le.{u_2} β
            (@partial_order.to_preorder.{u_2} β
               (@lattice.semilattice_inf.to_partial_order.{u_2} β
                  (@lattice.lattice.to_semilattice_inf.{u_2} β
                     (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
         (f a)
         (f m)) →
    ∀ {a_1 m : α} {o : option.{u_1} α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
        (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
           (@list.cons.{u_1} α a (@list.nil.{u_1} α))) →
      @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
        (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
           (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
              (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f a_1)
        (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63      rw [foldl_append, foldl_cons, foldl_nil, argmax₂] at ho,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='list.foldl_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.foldl_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.foldl_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1329, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1321, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1319, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} (f : α → β → α) (a : α) (l₁ l₂ : list.{u_1} β), @eq.{u_1+1} α (@list.foldl.{u_1 u_1} α β f a (@has_append.append.{u_1} (list.{u_1} β) (@list.has_append.{u_1} β) l₁ l₂)) (@list.foldl.{u_1 u_1} α β f (@list.foldl.{u_1 u_1} α β f a l₁) l₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} (f : α → β → α) (a : α) (b : β) (l : list.{u_1} β), @eq.{u_1+1} α (@list.foldl.{u_1 u_1} α β f a (@list.cons.{u_1} β b l)) (@list.foldl.{u_1 u_1} α β f (f a b) l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} (f : α → β → α) (a : α), @eq.{u_1+1} α (@list.foldl.{u_1 u_1} α β f a (@list.nil.{u_1} β)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → option.{?l_1} α → α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@list.cons.{u_1} α a (@list.nil.{u_1} α)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f)
       (@list.argmax₂.{u_1 u_2} α β _inst_1 f
          (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
          a)
       (@list.nil.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax₂.{u_1 u_2} α β _inst_1 f
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       a)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64      cases hf : foldl (argmax₂ f) o tl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='o'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, (α → β → α) → α → list.{u_1} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65      { rw [hf] at ho,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) (@option.none.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66        rw [foldl_argmax₂_eq_none] at hf,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.foldl_argmax₂_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 51, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α} {o : option.{u_1} α}, iff (@eq.{u_1+1} (option.{u_1} α) (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o l) (@option.none.{u_1} α)) (and (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α)) (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf : and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α)) (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.none.{u_1} α),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf : and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α)) (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67        simp [hf.1, hf.2, *] at * },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α)) (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α)) (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
hf : and (@eq.{u_1+1} (list.{u_1} α) tl (@list.nil.{u_1} α)) (@eq.{u_1+1} (option.{u_1} α) o (@option.none.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68      rw [hf, option.mem_def] at ho,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) (@option.some.{u_1} α val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} {b : option.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a b) (@eq.{u_1+1} (option.{u_1} α) b (@option.some.{u_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α val)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α val)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
ho :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α val)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69      dsimp only at ho,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α val)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70      cases mem_append.1 h with h h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.mem_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} {s t : list.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) s t)) (or (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a s) (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl (@list.cons.{u_1} α a (@list.nil.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)

case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 (@list.cons.{u_1} α a (@list.nil.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      { refine le_trans (ih h hf) _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a m : α} {o : option.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) (@option.some.{u_1} α val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)

case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 (@list.cons.{u_1} α a (@list.nil.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72        have := @le_of_lt _ _ (f val) (f m),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl,
this :
  @has_lt.lt.{u_2} β
    (@preorder.to_has_lt.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m) →
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73        split_ifs at ho;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl,
this :
  @has_lt.lt.{u_2} β
    (@preorder.to_has_lt.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m) →
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        simp * at * },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 tl,
this :
  @has_lt.lt.{u_2} β
    (@preorder.to_has_lt.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m) →
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 (@list.cons.{u_1} α a (@list.nil.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75      { split_ifs at ho;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 (@list.cons.{u_1} α a (@list.nil.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76        simp * at * }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
a : α,
ih :
  ∀ {a m : α} {o : option.{u_1} α},
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a tl →
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl) →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
a_1 m : α,
o : option.{u_1} α,
h :
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1
    (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
       (@list.cons.{u_1} α a (@list.nil.{u_1} α))),
val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o tl)
    (@option.some.{u_1} α val),
ho :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f a)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@option.some.{u_1} α m),
h : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a_1 (@list.cons.{u_1} α a (@list.nil.{u_1} α))
⊢ @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f a_1)
    (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  private theorem foldl_argmax₂_mem (f : α → β) (l) : Π (a m : α),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    m ∈ foldl (argmax₂ f) (some a) l → m ∈ a :: l :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v}, (α → β → α) → α → list.{v} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  list.reverse_rec_on l (by simp [eq_comm])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.reverse_rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='eq_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 539, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 363, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : list.{u_1} α → Prop} (l : list.{u_1} α), C (@list.nil.{u_1} α) → (∀ (l : list.{u_1} α) (a : α), C l → C (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) → C l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1} {a b : α}, iff (@eq.{?l_1} α a b) (@eq.{?l_1} α b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         (@list.nil.{u_1} α)) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ ∀ (l : list.{u_1} α) (a : α),
    (∀ (a m : α),
       @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
         (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f)
            (@option.some.{u_1} α a)
            l) →
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a l)) →
    ∀ (a_1 m : α),
      @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
        (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f)
           (@option.some.{u_1} α a_1)
           (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
              (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) →
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
        (@list.cons.{u_1} α a_1
           (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
              (@list.cons.{u_1} α a (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83      assume tl hd ih a m,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ ∀ (l : list.{u_1} α) (a : α),
    (∀ (a m : α),
       @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
         (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f)
            (@option.some.{u_1} α a)
            l) →
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a l)) →
    ∀ (a_1 m : α),
      @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
        (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f)
           (@option.some.{u_1} α a_1)
           (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
              (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) →
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
        (@list.cons.{u_1} α a_1
           (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
              (@list.cons.{u_1} α a (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84      simp only [foldl_append, foldl_cons, foldl_nil, argmax₂],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list.foldl_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.foldl_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.foldl_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1329, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1321, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 1319, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : α → β → α) (a : α) (l₁ l₂ : list.{?l_2} β), @eq.{?l_1+1} α (@list.foldl.{?l_1 ?l_2} α β f a (@has_append.append.{?l_2} (list.{?l_2} β) (@list.has_append.{?l_2} β) l₁ l₂)) (@list.foldl.{?l_1 ?l_2} α β f (@list.foldl.{?l_1 ?l_2} α β f a l₁) l₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : α → β → α) (a : α) (b : β) (l : list.{?l_2} β), @eq.{?l_1+1} α (@list.foldl.{?l_1 ?l_2} α β f a (@list.cons.{?l_2} β b l)) (@list.foldl.{?l_1 ?l_2} α β f (f a b) l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} (f : α → β → α) (a : α), @eq.{?l_1+1} α (@list.foldl.{?l_1 ?l_2} α β f a (@list.nil.{?l_2} β)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → option.{?l_1} α → α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
          tl)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85      cases hf : foldl (argmax₂ f) (some a) tl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='list.foldl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 176, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1}, (α → β → α) → α → list.{u_1} β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → option.{u_1} α → α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
          tl)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.none.{u_1} α)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.none.{u_1} α)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.some.{u_1} α val)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86      { simp {contextual := tt} },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.none.{u_1} α)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.none.{u_1} α)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.some.{u_1} α val)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.none.{u_1} α)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.none.{u_1} α)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.some.{u_1} α val)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      { dsimp only, split_ifs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f hd)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α hd))
       (@option.some.{u_1} α val)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f hd)
          (f val))
       (@has_le.le.decidable.{u_2} β _inst_1 (f hd) (f val))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α hd)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f hd)
    (f val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α val) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f hd)
       (f val))
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α hd) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88        { finish [ih _ _ hf] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/finish.lean&#x27;, &#x27;line&#x27;: 558, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a m : α), @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a) tl) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a) tl) (@option.some.{u_1} α val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (option.{0} (list.{0} pexpr)) (λ (a : option.{0} (list.{0} pexpr)), @option.has_reflect (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(list.{0} pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative (list.{0} pexpr) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit (list.{0} pexpr) (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.pexpr_list_or_texpr)) → opt_param.{1} auto.auto_config {use_simp := bool.tt, classical := bool.tt, max_ematch_rounds := @bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`finish [h1,...,hn] using [e1,...,en]` negates the goal, normalizes hypotheses
(by splitting conjunctions, eliminating existentials, pushing negations inwards,
and calling `simp` with the supplied lemmas `h1,...,hn`), and then tries `contradiction`.

If this fails, it will create an SMT state and repeatedly use `ematch`
(using `ematch` lemmas in the environment, universally quantified assumptions,
and the supplied lemmas `e1,...,en`) and congruence closure.

`finish` is complete for propositional logic.

Either of the supplied simp lemmas or the supplied ematch lemmas are optional.

`finish` will fail if it does not close the goal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='finish'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(using ([expr, ...] | expr))?&#x27;, &#x27;auto.auto_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f hd)
    (f val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α val) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f hd)
       (f val))
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α hd) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f hd)
    (f val)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α val) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f hd)
       (f val))
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α hd) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89        { simp {contextual := tt} } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l tl : list.{u_1} α,
hd : α,
ih :
  ∀ (a m : α),
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
         tl) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a tl),
a m val : α,
hf :
  @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a)
       tl)
    (@option.some.{u_1} α val),
h :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f hd)
       (f val))
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α hd) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m
    (@list.cons.{u_1} α a
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  theorem argmax_mem {f : α → β} : Π {l : list α} {m : α}, m ∈ argmax f l → m ∈ l</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='argmax_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  | [] m       := by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
argmax_mem :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.nil.{u_1} α)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.nil.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  | (hd::tl) m := by simpa [argmax, argmax₂] using foldl_argmax₂_mem f tl hd m</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='_private.3984385183.foldl_argmax₂_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → list.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → option.{?l_1} α → α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] (f : α → β) (l : list.{u_1} α) (a m : α), @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.some.{u_1} α a) l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
argmax_mem :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
hd : α,
tl : list.{u_1} α,
m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α hd tl)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α hd tl)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
argmax_mem :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
hd : α,
tl : list.{u_1} α,
m : α
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α hd tl)) →
  @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m (@list.cons.{u_1} α hd tl)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  theorem argmin_mem {f : α → β} : Π {l : list α} {m : α}, m ∈ argmin f l → m ∈ l :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  @argmax_mem _ (order_dual β) _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[simp] theorem argmax_eq_none {f : α → β} {l : list α} : l.argmax f = none ↔ l = [] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  by simp [argmax]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → list.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ iff (@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.none.{u_1} α))
    (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
l : list.{u_1} α
⊢ iff (@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.none.{u_1} α))
    (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  @[simp] theorem argmin_eq_none {f : α → β} {l : list α} : l.argmin f = none ↔ l = [] :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  @argmax_eq_none _ (order_dual β) _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α}, iff (@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.none.{u_1} α)) (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  theorem le_argmax_of_mem {f : α → β} {a m : α} {l : list α} : a ∈ l → m ∈ argmax f l → f a ≤ f m :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  le_of_foldl_argmax₂</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='_private.3345543393.le_of_foldl_argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α} {a m : α} {o : option.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) o l) → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  theorem argmin_le_of_mem {f : α → β} {a m : α} {l : list α} : a ∈ l → m ∈ argmin f l → f m ≤ f a:=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                          </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  @le_argmax_of_mem _ (order_dual β) _ _ _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.le_argmax_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {a m : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  theorem argmax_concat (f : α → β) (a : α) (l : list α) : argmax f (l ++ [a]) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_append.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    option.cases_on (argmax f l) (some a) (λ c, if f a ≤ f c then some c else some a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {C : option.{u} α → Sort l} (n : option.{u} α), C (@option.none.{u} α) → (Π (val : α), C (@option.some.{u} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  by rw [argmax, argmax]; simp [argmax₂]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.argmax₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 25, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → list.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → list.{?l_1} α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β], (α → β) → option.{?l_1} α → α → option.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Auxiliary definition to define `argmax`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.argmax.{u_1 u_2} α β _inst_1 f
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f l)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.none.{u_1} α)
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f l)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.none.{u_1} α)
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.foldl.{u_1 u_1} (option.{u_1} α) α (@list.argmax₂.{u_1 u_2} α β _inst_1 f) (@option.none.{u_1} α)
          l)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.argmax.{u_1 u_2} α β _inst_1 f
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f l)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.argmax.{u_1 u_2} α β _inst_1 f
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f l)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f a)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  theorem argmin_concat (f : α → β) (a : α) (l : list α) : argmin f (l ++ [a]) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_append.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116    option.cases_on (argmin f l) (some a) (λ c, if f c ≤ f a then some c else some a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {C : option.{u} α → Sort l} (n : option.{u} α), C (@option.none.{u} α) → (Π (val : α), C (@option.some.{u} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  @argmax_concat _ (order_dual β) _ _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] (f : α → β) (a : α) (l : list.{u_1} α), @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α a) (λ (c : α), @ite.{u_1+1} (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f c)) (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c)) (option.{u_1} α) (@option.some.{u_1} α c) (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  theorem argmax_cons (f : α → β) (a : α) (l : list α) : argmax f (a :: l) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120    option.cases_on (argmax f l) (some a) (λ c, if f c ≤ f a then some a else some c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {C : option.{u} α → Sort l} (n : option.{u} α), C (@option.none.{u} α) → (Π (val : α), C (@option.some.{u} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  list.reverse_rec_on l rfl $</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.reverse_rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 539, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : list.{u_1} α → Prop} (l : list.{u_1} α), C (@list.nil.{u_1} α) → (∀ (l : list.{u_1} α) (a : α), C l → C (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) → C l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122    assume hd tl ih,  begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd)) (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α a) (λ (c : α), @ite.{u_1+1} (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f c) (f a)) (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a)) (option.{u_1} α) (@option.some.{u_1} α a) (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.argmax.{u_1 u_2} α β _inst_1 f
       (@list.cons.{u_1} α a
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α)))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α))))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      rw [← cons_append, argmax_concat, ih, argmax_concat],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='list.cons_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (x : α) (s t : list.{u_1} α), @eq.{u_1+1} (list.{u_1} α) (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) (@list.cons.{u_1} α x s) t) (@list.cons.{u_1} α x (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) s t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] (f : α → β) (a : α) (l : list.{u_1} α), @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α a) (λ (c : α), @ite.{u_1+1} (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f c)) (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c)) (option.{u_1} α) (@option.some.{u_1} α c) (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd)) (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α a) (λ (c : α), @ite.{u_1+1} (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f c) (f a)) (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a)) (option.{u_1} α) (@option.some.{u_1} α a) (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] (f : α → β) (a : α) (l : list.{u_1} α), @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α a) (λ (c : α), @ite.{u_1+1} (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f c)) (@has_le.le.decidable.{u_2} β _inst_1 (f a) (f c)) (option.{u_1} α) (@option.some.{u_1} α c) (@option.some.{u_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.argmax.{u_1 u_2} α β _inst_1 f
       (@list.cons.{u_1} α a
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α)))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α))))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@list.argmax.{u_1 u_2} α β _inst_1 f
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) (@list.cons.{u_1} α a hd)
          (@list.cons.{u_1} α tl (@list.nil.{u_1} α))))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α))))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α))))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
          (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) hd
             (@list.cons.{u_1} α tl (@list.nil.{u_1} α))))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
          (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
          (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124      cases h : argmax f hd with m,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
          (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
          (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125      { simp [h] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.none.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.none.{u_1} α)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      { simp [h], dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c)))
       (@option.some.{u_1} α tl)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f c))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
            (option.{u_1} α)
            (@option.some.{u_1} α c)
            (@option.some.{u_1} α tl)))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl)))
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α a)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f c)
                  (f a))
               (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
               (option.{u_1} α)
               (@option.some.{u_1} α a)
               (@option.some.{u_1} α c))))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)
          (λ (c : α),
             @ite.{u_1+1}
               (@has_le.le.{u_2} β
                  (@preorder.to_has_le.{u_2} β
                     (@partial_order.to_preorder.{u_2} β
                        (@lattice.semilattice_inf.to_partial_order.{u_2} β
                           (@lattice.lattice.to_semilattice_inf.{u_2} β
                              (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
                  (f tl)
                  (f c))
               (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f c))
               (option.{u_1} α)
               (@option.some.{u_1} α c)
               (@option.some.{u_1} α tl))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127        by_cases ham : f m ≤ f a,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128        { rw if_pos ham, dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f m) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@option.some.{u_1} α a))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129          by_cases htlm : f tl ≤ f m,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130          { rw if_pos htlm, dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htlm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f tl) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f m)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131            rw [if_pos (le_trans htlm ham), if_pos ham] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htlm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) b c → @has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f tl) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f m) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f m) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f m)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α a)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f m)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f m)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132          { rw if_neg htlm } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htlm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f tl) (f m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f m)
    (f a),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133        { rw if_neg ham, dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f m) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f m)
             (f a))
          (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
          (option.{u_1} α)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α m)))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α tl)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f tl)
               (f val))
            (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f val))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α tl))
       (@option.some.{u_1} α m))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134          by_cases htlm : f tl ≤ f m,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135          { rw if_pos htlm, dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='if_pos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htlm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 839, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f tl) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α m)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α m)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f m)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136            rw if_neg ham },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f m) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f tl)
    (f m)
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α m)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f m)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f m) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137          { rw if_neg htlm, dsimp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htlm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f tl) (f m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f m))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
       (option.{u_1} α)
       (@option.some.{u_1} α m)
       (@option.some.{u_1} α tl))
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@ite.{u_1+1}
          (@has_le.le.{u_2} β
             (@preorder.to_has_le.{u_2} β
                (@partial_order.to_preorder.{u_2} β
                   (@lattice.semilattice_inf.to_partial_order.{u_2} β
                      (@lattice.lattice.to_semilattice_inf.{u_2} β
                         (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
             (f tl)
             (f m))
          (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f m))
          (option.{u_1} α)
          (@option.some.{u_1} α m)
          (@option.some.{u_1} α tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α tl)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α val))
       (@option.some.{u_1} α tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α tl)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138            rw [if_neg (not_le_of_gt (lt_trans (lt_of_not_ge ham) (lt_of_not_ge htlm)))] } } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_le_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='lt_of_not_ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='htlm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b : α}, @gt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → not (@has_le.le.{u_2} α (@preorder.to_has_le.{u_2} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : preorder.{u_2} α] {a b c : α}, @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a b → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) b c → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f m) (f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_2} [_inst_1 : linear_order.{u_2} α] {a b : α}, not (@ge.{u_2} α (@preorder.to_has_le.{u_2} α (@partial_order.to_preorder.{u_2} α (@linear_order.to_partial_order.{u_2} α _inst_1))) a b) → @has_lt.lt.{u_2} α (@preorder.to_has_lt.{u_2} α (@partial_order.to_preorder.{u_2} α (@linear_order.to_partial_order.{u_2} α _inst_1))) a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@linear_order.to_partial_order.{u_2} β (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1) (@decidable_linear_order.lt.{u_2} β _inst_1) (@decidable_linear_order.le_refl.{u_2} β _inst_1) (@decidable_linear_order.le_trans.{u_2} β _inst_1) (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1) (@decidable_linear_order.le_antisymm.{u_2} β _inst_1) (@decidable_linear_order.le_total.{u_2} β _inst_1))))) (f tl) (f m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α tl)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
f : α → β,
a : α,
l hd : list.{u_1} α,
tl : α,
ih :
  @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a hd))
    (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α)
       (@list.argmax.{u_1 u_2} α β _inst_1 f hd)
       (@option.some.{u_1} α a)
       (λ (c : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f c)
               (f a))
            (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a))
            (option.{u_1} α)
            (@option.some.{u_1} α a)
            (@option.some.{u_1} α c))),
m : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f hd) (@option.some.{u_1} α m),
ham :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f m)
       (f a)),
htlm :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f tl)
       (f m))
⊢ @eq.{u_1+1} (option.{u_1} α) (@option.some.{u_1} α tl)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f tl)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f tl) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  theorem argmin_cons (f : α → β) (a : α) (l : list α) : argmin f (a :: l) =</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    option.cases_on (argmin f l) (some a) (λ c, if f a ≤ f c then some a else some c) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {C : option.{u} α → Sort l} (n : option.{u} α), C (@option.none.{u} α) → (Π (val : α), C (@option.some.{u} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  @argmax_cons _ (order_dual β) _ _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] (f : α → β) (a : α) (l : list.{u_1} α), @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α a l)) (@option.cases_on.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α a) (λ (c : α), @ite.{u_1+1} (@has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f c) (f a)) (@has_le.le.decidable.{u_2} β _inst_1 (f c) (f a)) (option.{u_1} α) (@option.some.{u_1} α a) (@option.some.{u_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  theorem index_of_argmax [decidable_eq α] {f : α → β} : Π {l : list α} {m : α}, m ∈ argmax f l →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='index_of_argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='∀ {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → ∀ {a : α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    ∀ {a}, a ∈ l → f m ≤ f a → l.index_of m ≤ l.index_of a</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  | []       m _  _ _  _   := by simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
m : α,
_x :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.nil.{u_1} α)),
_x : α,
_x : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) _x (@list.nil.{u_1} α),
_x :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f _x)
⊢ @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m (@list.nil.{u_1} α))
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) _x (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  | (hd::tl) m hm a ha ham := begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m : α,
hm :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α hd tl)),
a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m (@list.cons.{u_1} α hd tl))
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a (@list.cons.{u_1} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149    simp only [index_of_cons, argmax_cons, option.mem_def] at ⊢ hm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.index_of_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 732, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 119, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_eq.{?l_1+1} α] (a b : α) (l : list.{?l_1} α), @eq.{1} nat (@list.index_of.{?l_1} α (λ (a b : α), _inst_1 a b) a (@list.cons.{?l_1} α b l)) (@ite.{1} (@eq.{?l_1+1} α a b) (_inst_1 a b) nat (@has_zero.zero.{0} nat nat.has_zero) (nat.succ (@list.index_of.{?l_1} α (λ (a b : α), _inst_1 a b) a l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β] (f : α → β) (a : α) (l : list.{?l_1} α), @eq.{?l_1+1} (option.{?l_1} α) (@list.argmax.{?l_1 ?l_2} α β _inst_1 f (@list.cons.{?l_1} α a l)) (@option.cases_on.{?l_1+1 ?l_1} α (λ (_x : option.{?l_1} α), option.{?l_1} α) (@list.argmax.{?l_1 ?l_2} α β _inst_1 f l) (@option.some.{?l_1} α a) (λ (c : α), @ite.{?l_1+1} (@has_le.le.{?l_2} β (@preorder.to_has_le.{?l_2} β (@partial_order.to_preorder.{?l_2} β (@lattice.semilattice_inf.to_partial_order.{?l_2} β (@lattice.lattice.to_semilattice_inf.{?l_2} β (@lattice.lattice_of_decidable_linear_order.{?l_2} β _inst_1))))) (f c) (f a)) (@has_le.le.decidable.{?l_2} β _inst_1 (f c) (f a)) (option.{?l_1} α) (@option.some.{?l_1} α a) (@option.some.{?l_1} α c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {b : option.{?l_1} α}, iff (@has_mem.mem.{?l_1 ?l_1} α (option.{?l_1} α) (@option.has_mem.{?l_1} α) a b) (@eq.{?l_1+1} (option.{?l_1} α) b (@option.some.{?l_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m : α,
hm :
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
    (@list.argmax.{u_1 u_2} α β _inst_1 f (@list.cons.{u_1} α hd tl)),
a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a)
⊢ @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m (@list.cons.{u_1} α hd tl))
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a (@list.cons.{u_1} α hd tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150    cases h : argmax f tl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.none.{u_1} α)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151    { rw h at hm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.none.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.none.{u_1} α)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.none.{u_1} α)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.none.{u_1} α),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@option.none.{u_1} α))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152      simp * at * },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.none.{u_1} α),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@option.none.{u_1} α))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153    { rw h at hm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@list.argmax.{u_1 u_2} α β _inst_1 f tl))
    (@option.some.{u_1} α m),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      dsimp only at hm,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α hd)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_2} β
               (@preorder.to_has_le.{u_2} β
                  (@partial_order.to_preorder.{u_2} β
                     (@lattice.semilattice_inf.to_partial_order.{u_2} β
                        (@lattice.lattice.to_semilattice_inf.{u_2} β
                           (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
               (f val)
               (f hd))
            (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
            (option.{u_1} α)
            (@option.some.{u_1} α hd)
            (@option.some.{u_1} α val))
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      cases ha with hahd hatl,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ha : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.cons.{u_1} α hd tl),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hahd : @eq.{u_1+1} α a hd
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))

case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156      { clear index_of_argmax,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case or.inl
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hahd : @eq.{u_1+1} α a hd
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))

case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inl
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hahd : @eq.{u_1+1} α a hd
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hahd : @eq.{u_1+1} α a hd
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157        subst hahd,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hahd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α a hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hahd : @eq.{u_1+1} α a hd
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158        split_ifs at hm,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f a))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f a))
       (option.{u_1} α)
       (@option.some.{u_1} α a)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f val)
    (f a),
hm : @eq.{u_1+1} α a m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f val)
       (f a)),
hm : @eq.{u_1+1} α val m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159        { subst hm },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α a m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f val)
    (f a),
hm : @eq.{u_1+1} α a m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))

α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f val)
       (f a)),
hm : @eq.{u_1+1} α val m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@linear_order.to_partial_order.{u_2} β
             (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                (@decidable_linear_order.lt.{u_2} β _inst_1)
                (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
    (f val)
    (f a),
hm : @eq.{u_1+1} α a m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f val)
       (f a)),
hm : @eq.{u_1+1} α val m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160        { subst hm, contradiction } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1306, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 825, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} α val m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Given hypothesis `h : x = t` or `h : t = x`, where `x` is a local constant, `subst h` substitutes `x` by `t` everywhere in the main goal and then clears `h`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The contradiction tactic attempts to find in the current local context a hypothesis that is equivalent to an empty inductive type (e.g. `false`), a hypothesis of the form `c_1 ... = c_2 ...` where `c_1` and `c_2` are distinct constructors, or two contradictory hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='contradiction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f val)
       (f a)),
hm : @eq.{u_1+1} α val m
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m a) (_inst_2 m a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
tl : list.{u_1} α,
a val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
h_1 :
  not
    (@has_le.le.{u_2} β
       (@preorder.to_has_le.{u_2} β
          (@partial_order.to_preorder.{u_2} β
             (@linear_order.to_partial_order.{u_2} β
                (@linear_order.mk.{u_2} β (@decidable_linear_order.le.{u_2} β _inst_1)
                   (@decidable_linear_order.lt.{u_2} β _inst_1)
                   (@decidable_linear_order.le_refl.{u_2} β _inst_1)
                   (@decidable_linear_order.le_trans.{u_2} β _inst_1)
                   (@decidable_linear_order.lt_iff_le_not_le.{u_2} β _inst_1)
                   (@decidable_linear_order.le_antisymm.{u_2} β _inst_1)
                   (@decidable_linear_order.le_total.{u_2} β _inst_1)))))
       (f val)
       (f a)),
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f a)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α val a) (_inst_2 val a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) val tl)))
    (@ite.{1} (@eq.{u_1+1} α a a) (_inst_2 a a) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161      { have := index_of_argmax h hatl, clear index_of_argmax,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='index_of_argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hatl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1318, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → ∀ {a : α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@list.mem.{u_1} α a tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name lean.parser.ident) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`clear h₁ ... hₙ` tries to clear each hypothesis `hᵢ` from the local context.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='clear'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case or.inr
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
index_of_argmax :
  ∀ {l : list.{u_1} α} {m : α},
    @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m
      (@list.argmax.{u_1 u_2} α β _inst_1 f l) →
    ∀ {a : α},
      @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
      @has_le.le.{u_2} β
        (@preorder.to_has_le.{u_2} β
           (@partial_order.to_preorder.{u_2} β
              (@lattice.semilattice_inf.to_partial_order.{u_2} β
                 (@lattice.lattice.to_semilattice_inf.{u_2} β
                    (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
        (f m)
        (f a) →
      @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
        (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl,
this :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f a) →
  @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) val tl)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl,
this :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f a) →
  @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) val tl)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162        split_ifs at *;</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/split_ifs.lean&#x27;, &#x27;line&#x27;: 84, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title=' Splits all if-then-else-expressions into multiple goals.

Given a goal of the form `g (if p then x else y)`, `split_ifs` will produce
two goals: `p ⊢ g x` and `¬p ⊢ g y`.

If there are multiple ite-expressions, then `split_ifs` will split them all,
starting with a top-most one whose condition does not contain another
ite-expression.

`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.

`split_ifs with h₁ h₂ h₃` overrides the default names for the hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='split_ifs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl,
this :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f a) →
  @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) val tl)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163        refl &lt;|&gt; exact nat.zero_le _ &lt;|&gt; simp [*, nat.succ_le_succ_iff, -not_le] at * } }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='nat.zero_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='nat.succ_le_succ_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 75, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/nat/basic.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (n : nat), @has_le.le.{0} nat nat.has_le (@has_zero.zero.{0} nat nat.has_zero) n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {m n : nat}, iff (@has_le.le.{0} nat nat.has_le (nat.succ m) (nat.succ n)) (@has_le.le.{0} nat nat.has_le m n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
hd : α,
tl : list.{u_1} α,
m a : α,
ham :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f m)
    (f a),
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f tl) (@option.some.{u_1} α val),
hm :
  @eq.{u_1+1} (option.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_2} β
          (@preorder.to_has_le.{u_2} β
             (@partial_order.to_preorder.{u_2} β
                (@lattice.semilattice_inf.to_partial_order.{u_2} β
                   (@lattice.lattice.to_semilattice_inf.{u_2} β
                      (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
          (f val)
          (f hd))
       (@has_le.le.decidable.{u_2} β _inst_1 (f val) (f hd))
       (option.{u_1} α)
       (@option.some.{u_1} α hd)
       (@option.some.{u_1} α val))
    (@option.some.{u_1} α m),
hatl : @list.mem.{u_1} α a tl,
this :
  @has_le.le.{u_2} β
    (@preorder.to_has_le.{u_2} β
       (@partial_order.to_preorder.{u_2} β
          (@lattice.semilattice_inf.to_partial_order.{u_2} β
             (@lattice.lattice.to_semilattice_inf.{u_2} β
                (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
    (f val)
    (f a) →
  @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) val tl)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)
⊢ @has_le.le.{0} nat nat.has_le
    (@ite.{1} (@eq.{u_1+1} α m hd) (_inst_2 m hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m tl)))
    (@ite.{1} (@eq.{u_1+1} α a hd) (_inst_2 a hd) nat (@has_zero.zero.{0} nat nat.has_zero)
       (nat.succ (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a tl)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  theorem index_of_argmin [decidable_eq α] {f : α → β} : Π {l : list α} {m : α}, m ∈ argmin f l →</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                   </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    ∀ {a}, a ∈ l → f a ≤ f m → l.index_of m ≤ l.index_of a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  @index_of_argmax _ (order_dual β) _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.index_of_argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 145, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] [_inst_2 : decidable_eq.{u_1+1} α] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → ∀ {a : α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  theorem mem_argmax_iff [decidable_eq α] {f : α → β} {m : α} {l : list α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    m ∈ argmax f l ↔ m ∈ l ∧ (∀ a ∈ l, f a ≤ f m) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172      (∀ a ∈ l, f m ≤ f a → l.index_of m ≤ l.index_of a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173  ⟨λ hm, ⟨argmax_mem hm, λ a ha, le_argmax_of_mem ha hm, λ _, index_of_argmax hm⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.argmax_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.le_argmax_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.index_of_argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 145, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {a m : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] [_inst_2 : decidable_eq.{u_1+1} α] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → ∀ {a : α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_2} β
            (@preorder.to_has_le.{u_2} β
               (@partial_order.to_preorder.{u_2} β
                  (@lattice.semilattice_inf.to_partial_order.{u_2} β
                     (@lattice.lattice.to_semilattice_inf.{u_2} β
                        (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
            (f a)
            (f m))
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_2} β
            (@preorder.to_has_le.{u_2} β
               (@partial_order.to_preorder.{u_2} β
                  (@lattice.semilattice_inf.to_partial_order.{u_2} β
                     (@lattice.lattice.to_semilattice_inf.{u_2} β
                        (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
            (f m)
            (f a) →
          @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l))) →
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      rintros ⟨hml, ham, hma⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_2} β
            (@preorder.to_has_le.{u_2} β
               (@partial_order.to_preorder.{u_2} β
                  (@lattice.semilattice_inf.to_partial_order.{u_2} β
                     (@lattice.lattice.to_semilattice_inf.{u_2} β
                        (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
            (f a)
            (f m))
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_2} β
            (@preorder.to_has_le.{u_2} β
               (@partial_order.to_preorder.{u_2} β
                  (@lattice.semilattice_inf.to_partial_order.{u_2} β
                     (@lattice.lattice.to_semilattice_inf.{u_2} β
                        (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
            (f m)
            (f a) →
          @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l))) →
  @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      cases harg : argmax f l with n,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.none.{u_1} α)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.none.{u_1} α)

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177      { simp * at * },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.none.{u_1} α)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.none.{u_1} α)

case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.none.{u_1} α)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.none.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178      { have := le_antisymm (hma n (argmax_mem harg) (le_argmax_of_mem hml harg))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='n'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='list.le_argmax_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : partial_order.{0} α] {a b : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) a b → @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α _inst_1)) b a → @eq.{1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {a m : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179          (index_of_argmax harg hml (ham _ (argmax_mem harg))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='list.index_of_argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='hml'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ham'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='harg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 145, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] [_inst_2 : decidable_eq.{u_1+1} α] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → ∀ {a : α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n),
this :
  @eq.{1} nat (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) n l)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180        rw [(index_of_inj hml (argmax_mem harg)).1 this, option.mem_def] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list.index_of_inj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hml'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='harg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='option.mem_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 900, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/option/defs.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α] {l : list.{u_1} α} {x y : α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) x l → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) y l → iff (@eq.{1} nat (@list.index_of.{u_1} α (λ (a b : α), _inst_1 a b) x l) (@list.index_of.{u_1} α (λ (a b : α), _inst_1 a b) y l)) (@eq.{u_1+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} nat (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) n l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {a : α} {b : option.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) a b) (@eq.{u_1+1} (option.{u_1} α) b (@option.some.{u_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n),
this :
  @eq.{1} nat (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) n l)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n),
this :
  @eq.{1} nat (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) n l)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) n (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
β : Type u_2,
_inst_1 : decidable_linear_order.{u_2} β,
_inst_2 : decidable_eq.{u_1+1} α,
f : α → β,
m : α,
l : list.{u_1} α,
hml : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l,
ham :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f a)
      (f m),
hma :
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_2} β
      (@preorder.to_has_le.{u_2} β
         (@partial_order.to_preorder.{u_2} β
            (@lattice.semilattice_inf.to_partial_order.{u_2} β
               (@lattice.lattice.to_semilattice_inf.{u_2} β
                  (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1)))))
      (f m)
      (f a) →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l),
n : α,
harg : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_2} α β _inst_1 f l) (@option.some.{u_1} α n),
this :
  @eq.{1} nat (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) n l)
⊢ @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@option.some.{u_1} α n)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181    end⟩</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  theorem argmax_eq_some_iff [decidable_eq α] {f : α → β} {m : α} {l : list α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184    argmax f l = some m ↔ m ∈ l ∧ (∀ a ∈ l, f a ≤ f m) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185      (∀ a ∈ l, f m ≤ f a → l.index_of m ≤ l.index_of a) := mem_argmax_iff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.mem_argmax_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] [_inst_2 : decidable_eq.{u_1+1} α] {f : α → β} {m : α} {l : list.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)) (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l) (and (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)) (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187  theorem mem_argmin_iff [decidable_eq α] {f : α → β} {m : α} {l : list α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188    m ∈ argmin f l ↔ m ∈ l ∧ (∀ a ∈ l, f m ≤ f a) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189      (∀ a ∈ l, f a ≤ f m → l.index_of m ≤ l.index_of a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  @mem_argmax_iff _ (order_dual β) _ _ _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.mem_argmax_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 170, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] [_inst_2 : decidable_eq.{u_1+1} α] {f : α → β} {m : α} {l : list.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_2} α β _inst_1 f l)) (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l) (and (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m)) (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_2 → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192  theorem argmin_eq_some_iff [decidable_eq α] {f : α → β} {m : α} {l : list α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='decidable_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 276, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    argmin f l = some m ↔ m ∈ l ∧ (∀ a ∈ l, f m ≤ f a) ∧</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194      (∀ a ∈ l, f a ≤ f m → l.index_of m ≤ l.index_of a) := mem_argmin_iff</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.index_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.mem_argmin_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/basic.lean&#x27;, &#x27;line&#x27;: 151, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 187, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_2} [c : has_le.{u_2} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : decidable_eq.{u_1+1} α], α → list.{u_1} α → nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β] [_inst_2 : decidable_eq.{u_1+1} α] {f : α → β} {m : α} {l : list.{u_1} α}, iff (@has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmin.{u_1 u_2} α β _inst_1 f l)) (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l) (and (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f m) (f a)) (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_2} β (@preorder.to_has_le.{u_2} β (@partial_order.to_preorder.{u_2} β (@lattice.semilattice_inf.to_partial_order.{u_2} β (@lattice.lattice.to_semilattice_inf.{u_2} β (@lattice.lattice_of_decidable_linear_order.{u_2} β _inst_1))))) (f a) (f m) → @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{u_1} α (λ (a b : α), _inst_2 a b) a l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  variable [decidable_linear_order α]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='decidable_linear_order'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 212, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  /-- `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  `[]`  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200  def maximum (l : list α) : with_bot α := argmax id l</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='with_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  /-- `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  `[]`  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  def minimum (l : list α) : with_top α := argmin id l</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='with_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : decidable_linear_order.{u_2} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='orange'><a title='`argmin f l` returns `some a`, where `a` of `l` that minimises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmin f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  @[simp] lemma maximum_nil : maximum ([] : list α) = ⊥ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_bot.bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_bot.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  @[simp] lemma minimum_nil : minimum ([] : list α) = ⊤ := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='lattice.has_top.top'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [c : lattice.has_top.{u_1} α], α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210  @[simp] lemma maximum_singleton (a : α) : maximum [a] = a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212  @[simp] lemma minimum_singleton (a : α) : minimum [a] = a := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  theorem maximum_mem {l : list α} {m : α} : (maximum l : with_top α) = m → m ∈ l := argmax_mem</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 92, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_1} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  theorem minimum_mem {l : list α} {m : α} : (minimum l : with_bot α) = m → m ∈ l := argmin_mem</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 96, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β] {f : α → β} {l : list.{u_1} α} {m : α}, @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmin.{u_1 u_1} α β _inst_1 f l) → @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  @[simp] theorem maximum_eq_none {l : list α} : l.maximum = none ↔ l = [] := argmax_eq_none</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmax_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 99, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β] {f : α → β} {l : list.{u_1} α}, iff (@eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α β _inst_1 f l) (@option.none.{u_1} α)) (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  @[simp] theorem minimum_eq_none {l : list α} : l.minimum = none ↔ l = [] := argmin_eq_none</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='option.none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.argmin_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 102, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, option.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β] {f : α → β} {l : list.{u_1} α}, iff (@eq.{u_1+1} (option.{u_1} α) (@list.argmin.{u_1 u_1} α β _inst_1 f l) (@option.none.{u_1} α)) (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  theorem le_maximum_of_mem {a m : α} {l : list α} : a ∈ l → (maximum l : with_bot α) = m → a ≤ m :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  le_argmax_of_mem</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.le_argmax_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 105, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β] {f : α → β} {a m : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmax.{u_1 u_1} α β _inst_1 f l) → @has_le.le.{u_1} β (@preorder.to_has_le.{u_1} β (@partial_order.to_preorder.{u_1} β (@lattice.semilattice_inf.to_partial_order.{u_1} β (@lattice.lattice.to_semilattice_inf.{u_1} β (@lattice.lattice_of_decidable_linear_order.{u_1} β _inst_1))))) (f a) (f m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  theorem minimum_le_of_mem {a m : α} {l : list α} : a ∈ l → (minimum l : with_top α) = m → m ≤ a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  argmin_le_of_mem</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.argmin_le_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 108, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β] {f : α → β} {a m : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_mem.mem.{u_1 u_1} α (option.{u_1} α) (@option.has_mem.{u_1} α) m (@list.argmin.{u_1 u_1} α β _inst_1 f l) → @has_le.le.{u_1} β (@preorder.to_has_le.{u_1} β (@partial_order.to_preorder.{u_1} β (@lattice.semilattice_inf.to_partial_order.{u_1} β (@lattice.lattice.to_semilattice_inf.{u_1} β (@lattice.lattice_of_decidable_linear_order.{u_1} β _inst_1))))) (f m) (f a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  theorem le_maximum_of_mem&#x27; {a : α} {l : list α} (ha : a ∈ l) : (a : with_bot α) ≤ maximum l :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                                  </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  option.cases_on (maximum l) (λ _ h, absurd ha ((h rfl).symm ▸ not_mem_nil _))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='option.cases_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='absurd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.not_mem_nil'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 89, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : option.{u_1} α → Prop} (n : option.{u_1} α), C (@option.none.{u_1} α) → (∀ (val : α), C (@option.some.{u_1} α val)) → C n'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ (m : α), @eq.{u_1+1} (with_bot.{u_1} α) (@option.none.{u_1} α) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) m) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) a m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u_1+1} (with_bot.{u_1} α) (@option.none.{u_1} α) (@option.none.{u_1} α) → @eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {a b : Prop}, a → not a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@eq.{u_1+1} (with_bot.{u_1} α) (@option.none.{u_1} α) (@option.none.{u_1} α) → @eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {a b : α}, @eq.{u_1+1} α a b → @eq.{u_1+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} {P : α → Prop} {a b : α}, @eq.{u_1+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} (a : α), not (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230    (λ m hm _, with_bot.coe_le_coe.2 $ hm _ rfl)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='with_bot.coe_le_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 398, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (m_1 : α), @eq.{u_1+1} (with_bot.{u_1} α) (@option.some.{u_1} α m) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) m_1) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) a m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u_1+1} (with_bot.{u_1} α) (@option.some.{u_1} α m) (@option.none.{u_1} α) → @eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : partial_order.{u_1} α] {a b : α}, iff (@has_le.le.{u_1} (with_bot.{u_1} α) (@preorder.to_has_le.{u_1} (with_bot.{u_1} α) (@with_bot.preorder.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1))) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) b)) (@has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ (m_1 : α), @eq.{u_1+1} (with_bot.{u_1} α) (@option.some.{u_1} α m) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) m_1) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) a m_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} {a : α}, @eq.{u_1+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231    (λ m, @le_maximum_of_mem _ _ _ m _ ha)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='list.le_maximum_of_mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 222, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] {a m : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) m) → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) a m'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232    (@maximum_eq_none _ _ l).1</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.maximum_eq_none'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff.mp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 218, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] {l : list.{u_1} α}, iff (@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l) (@option.none.{u_1} α)) (@eq.{u_1+1} (list.{u_1} α) l (@list.nil.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {a b : Prop}, iff a b → a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234  theorem le_minimum_of_mem&#x27; {a : α} {l : list α} (ha : a ∈ l) : minimum l ≤ (a : with_top α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235  @le_maximum_of_mem&#x27; (order_dual α) _ _ _ ha</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.le_maximum_of_mem&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='ha'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 228, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] {a : α} {l : list.{u_1} α}, @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_1} (with_bot.{u_1} α) (@preorder.to_has_le.{u_1} (with_bot.{u_1} α) (@with_bot.preorder.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a) (@list.maximum.{u_1} α _inst_2 l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237  theorem maximum_concat (a : α) (l : list α) : maximum (l ++ [a]) = max (maximum l) a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_append.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@list.maximum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@list.maximum.{u_1} α _inst_2 l)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239    rw max_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='max_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 80, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] (a b : α), @eq.{u_1+1} α (@max.{u_1} α _inst_1 a b) (@max.{u_1} α _inst_1 b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@list.maximum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@list.maximum.{u_1} α _inst_2 l)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@list.maximum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240    simp only [maximum, argmax_concat, id, max],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 111, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_2 : decidable_linear_order.{?l_1} α], list.{?l_1} α → with_bot.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β] (f : α → β) (a : α) (l : list.{?l_1} α), @eq.{?l_1+1} (option.{?l_1} α) (@list.argmax.{?l_1 ?l_2} α β _inst_1 f (@has_append.append.{?l_1} (list.{?l_1} α) (@list.has_append.{?l_1} α) l (@list.cons.{?l_1} α a (@list.nil.{?l_1} α)))) (@option.cases_on.{?l_1+1 ?l_1} α (λ (_x : option.{?l_1} α), option.{?l_1} α) (@list.argmax.{?l_1 ?l_2} α β _inst_1 f l) (@option.some.{?l_1} α a) (λ (c : α), @ite.{?l_1+1} (@has_le.le.{?l_2} β (@preorder.to_has_le.{?l_2} β (@partial_order.to_preorder.{?l_2} β (@lattice.semilattice_inf.to_partial_order.{?l_2} β (@lattice.lattice.to_semilattice_inf.{?l_2} β (@lattice.lattice_of_decidable_linear_order.{?l_2} β _inst_1))))) (f a) (f c)) (@has_le.le.decidable.{?l_2} β _inst_1 (f a) (f c)) (option.{?l_1} α) (@option.some.{?l_1} α c) (@option.some.{?l_1} α a)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : decidable_linear_order.{?l_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@list.maximum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l))
       (with_bot.{u_1} α)
       (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241    cases h : argmax id l,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='list.argmax'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u_1} [_inst_1 : decidable_linear_order.{u_1} β], (α → β) → list.{u_1} α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`argmax f l` returns `some a`, where `a` of `l` that maximises `f a`. If there are `a b` such that
 `f a = f b`, it returns whichever of `a` or `b` comes first in the list.
 `argmax f []` = none`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l))
       (with_bot.{u_1} α)
       (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.none.{u_1} α))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.none.{u_1} α))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.none.{u_1} α))
       (with_bot.{u_1} α)
       (@option.none.{u_1} α)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))

case option.some
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.some.{u_1} α val))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242    { rw [if_neg], refl, exact not_le_of_gt (with_bot.bot_lt_some _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='if_neg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='not_le_of_gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='with_bot.bot_lt_some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 845, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 412, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {c : Prop} [h : decidable c], not c → ∀ {α : Type u_1} {t e : α}, @eq.{u_1+1} α (@ite.{u_1+1} c h α t e) e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : preorder.{u_1} α] {a b : α}, @gt.{u_1} α (@preorder.to_has_lt.{u_1} α _inst_1) a b → not (@has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α _inst_1) a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : partial_order.{u_1} α] (a : α), @has_lt.lt.{u_1} (with_bot.{u_1} α) (@preorder.to_has_lt.{u_1} (with_bot.{u_1} α) (@with_bot.preorder.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1))) (@lattice.has_bot.bot.{u_1} (with_bot.{u_1} α) (@with_bot.has_bot.{u_1} α)) (@option.some.{u_1} α a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.none.{u_1} α))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.none.{u_1} α))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.none.{u_1} α))
       (with_bot.{u_1} α)
       (@option.none.{u_1} α)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))

case option.some
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.some.{u_1} α val))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.none
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.none.{u_1} α))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.none.{u_1} α))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.none.{u_1} α))
       (with_bot.{u_1} α)
       (@option.none.{u_1} α)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.none.{u_1} α))
    (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
       (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
       a)

α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ not
    (@has_le.le.{u_1} (with_bot.{u_1} α)
       (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
          (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
             (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                   (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
case option.none
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.none.{u_1} α))
    (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
       (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
       a)

α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ not
    (@has_le.le.{u_1} (with_bot.{u_1} α)
       (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
          (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
             (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                   (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.none.{u_1} α)
⊢ not
    (@has_le.le.{u_1} (with_bot.{u_1} α)
       (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
          (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
             (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                   (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@option.none.{u_1} α))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.some.{u_1} α val))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    change (coe : α → with_bot α) with some,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='with_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='option.some'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 279, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {a b : Type u_1} [_inst_1 : has_lift_t.{u_1+1 u_1+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u_1}, α → option.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='case option.some
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.some.{u_1} α val))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@option.some.{u_1} α val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.some.{u_1} α val))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α val))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    simp, congr</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1543, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='congr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@option.rec.{u_1+1 u_1} α (λ (_x : option.{u_1} α), option.{u_1} α) (@option.some.{u_1} α a)
       (λ (val : α),
          @ite.{u_1+1}
            (@has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               val)
            (@eq.rec.{1 1} Prop
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  (@id.{u_1+1} α val))
               (λ (c : Prop), decidable c)
               (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
               (@has_le.le.{u_1} α
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  a
                  val)
               (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
                 (e_3 : @eq.{u_1+1} α a_2 a_3),
                   @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                     (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                     e_3)
                  (@preorder.to_has_le.{u_1} α
                     (@partial_order.to_preorder.{u_1} α
                        (@lattice.semilattice_inf.to_partial_order.{u_1} α
                           (@lattice.lattice.to_semilattice_inf.{u_1} α
                              (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
                  (@id.{u_1+1} α a)
                  a
                  (@id.equations._eqn_1.{u_1+1} α a)
                  (@id.{u_1+1} α val)
                  val
                  (@id.equations._eqn_1.{u_1+1} α val)))
            (option.{u_1} α)
            (@option.some.{u_1} α val)
            (@option.some.{u_1} α a))
       (@option.some.{u_1} α val))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} (with_bot.{u_1} α)
          (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
             (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                   (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                      (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α val))
       (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@option.some.{u_1} α a)
          (@option.some.{u_1} α val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α,
val : α,
h : @eq.{u_1+1} (option.{u_1} α) (@list.argmax.{u_1 u_1} α α _inst_2 (@id.{u_1+1} α) l) (@option.some.{u_1} α val)
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@ite.{u_1+1}
       (@has_le.le.{u_1} α
          (@preorder.to_has_le.{u_1} α
             (@partial_order.to_preorder.{u_1} α
                (@lattice.semilattice_inf.to_partial_order.{u_1} α
                   (@lattice.lattice.to_semilattice_inf.{u_1} α
                      (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
          a
          val)
       (@eq.rec.{1 1} Prop
          (@has_le.le.{u_1} α
             (@preorder.to_has_le.{u_1} α
                (@partial_order.to_preorder.{u_1} α
                   (@lattice.semilattice_inf.to_partial_order.{u_1} α
                      (@lattice.lattice.to_semilattice_inf.{u_1} α
                         (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
             (@id.{u_1+1} α a)
             (@id.{u_1+1} α val))
          (λ (c : Prop), decidable c)
          (@has_le.le.decidable.{u_1} α _inst_2 (@id.{u_1+1} α a) (@id.{u_1+1} α val))
          (@has_le.le.{u_1} α
             (@preorder.to_has_le.{u_1} α
                (@partial_order.to_preorder.{u_1} α
                   (@lattice.semilattice_inf.to_partial_order.{u_1} α
                      (@lattice.lattice.to_semilattice_inf.{u_1} α
                         (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
             a
             val)
          (@(λ [c : has_le.{u_1} α] (a a_1 : α) (e_2 : @eq.{u_1+1} α a a_1) (a_2 a_3 : α)
            (e_3 : @eq.{u_1+1} α a_2 a_3),
              @congr.{u_1+1 1} α Prop (@has_le.le.{u_1} α c a) (@has_le.le.{u_1} α c a_1) a_2 a_3
                (@congr_arg.{u_1+1 (max (u_1+1) 1)} α (α → Prop) a a_1 (@has_le.le.{u_1} α c) e_2)
                e_3)
             (@preorder.to_has_le.{u_1} α
                (@partial_order.to_preorder.{u_1} α
                   (@lattice.semilattice_inf.to_partial_order.{u_1} α
                      (@lattice.lattice.to_semilattice_inf.{u_1} α
                         (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
             (@id.{u_1+1} α a)
             a
             (@id.equations._eqn_1.{u_1+1} α a)
             (@id.{u_1+1} α val)
             val
             (@id.equations._eqn_1.{u_1+1} α val)))
       (option.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))
    (@ite.{u_1+1}
       (@has_le.le.{u_1} α
          (@preorder.to_has_le.{u_1} α
             (@partial_order.to_preorder.{u_1} α
                (@lattice.semilattice_inf.to_partial_order.{u_1} α
                   (@lattice.lattice.to_semilattice_inf.{u_1} α
                      (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
          a
          val)
       (@decidable_of_decidable_of_iff
          (@has_le.le.{u_1} (with_bot.{u_1} α)
             (@preorder.to_has_le.{u_1} (with_bot.{u_1} α)
                (@partial_order.to_preorder.{u_1} (with_bot.{u_1} α)
                   (@linear_order.to_partial_order.{u_1} (with_bot.{u_1} α)
                      (@decidable_linear_order.to_linear_order.{u_1} (with_bot.{u_1} α)
                         (@with_bot.decidable_linear_order.{u_1} α _inst_2)))))
             (@option.some.{u_1} α a)
             (@option.some.{u_1} α val))
          (@has_le.le.{u_1} α
             (@preorder.to_has_le.{u_1} α
                (@partial_order.to_preorder.{u_1} α
                   (@lattice.semilattice_inf.to_partial_order.{u_1} α
                      (@lattice.lattice.to_semilattice_inf.{u_1} α
                         (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
             a
             val)
          (@has_le.le.decidable.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
             (@option.some.{u_1} α a)
             (@option.some.{u_1} α val))
          (@with_bot.some_le_some.{u_1} α
             (@lattice.semilattice_inf.to_partial_order.{u_1} α
                (@lattice.lattice.to_semilattice_inf.{u_1} α
                   (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))
             a
             val))
       (with_bot.{u_1} α)
       (@option.some.{u_1} α val)
       (@option.some.{u_1} α a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247  theorem minimum_concat (a : α) (l : list α) : minimum (l ++ [a]) = min (minimum l) a :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_append.append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 321, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_append.{u_1} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248  by simp only [min_comm _ (a : with_top α)]; exact @maximum_concat (order_dual α) _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='min_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='with_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list.maximum_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 523, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 237, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] (a b : α), @eq.{u_1+1} α (@min.{u_1} α _inst_1 a b) (@min.{u_1} α _inst_1 b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] (a : α) (l : list.{u_1} α), @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2) (@list.maximum.{u_1} α _inst_2 l) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_top.{u_1} α)
    (@list.minimum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@min.{u_1} (with_top.{u_1} α) (@with_top.decidable_linear_order.{u_1} α _inst_2)
       (@list.minimum.{u_1} α _inst_2 l)
       (@coe.{u_1+1 u_1+1} α (with_top.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_top.{u_1} α) (@with_top.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_top.{u_1} α)
    (@list.minimum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l
          (@list.cons.{u_1} α a (@list.nil.{u_1} α))))
    (@min.{u_1} (with_top.{u_1} α) (@with_top.decidable_linear_order.{u_1} α _inst_2)
       (@list.minimum.{u_1} α _inst_2 l)
       (@coe.{u_1+1 u_1+1} α (with_top.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_top.{u_1} α) (@with_top.has_coe_t.{u_1} α))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  theorem maximum_cons (a : α) (l : list α) : maximum (a :: l) = max a (maximum l) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='max'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  list.reverse_rec_on l (by simp [@max_eq_left (with_bot α) _ _ _ lattice.bot_le])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='list.reverse_rec_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='max_eq_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='with_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='lattice.bot_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/list/basic.lean&#x27;, &#x27;line&#x27;: 539, &#x27;column&#x27;: 26}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 340, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/bounded_lattice.lean&#x27;, &#x27;line&#x27;: 102, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} {C : list.{u_1} α → Prop} (l : list.{u_1} α), C (@list.nil.{u_1} α) → (∀ (l : list.{u_1} α) (a : α), C l → C (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) → C l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@linear_order.to_partial_order.{u_1} α (@decidable_linear_order.to_linear_order.{u_1} α _inst_1)))) b a → @eq.{u_1+1} α (@max.{u_1} α _inst_1 a b) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : lattice.order_bot.{u_1} α] {a : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.order_bot.to_partial_order.{u_1} α _inst_1))) (@lattice.has_bot.bot.{u_1} α (@lattice.order_bot.to_has_bot.{u_1} α _inst_1)) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l : list.{u_1} α
⊢ @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a (@list.nil.{u_1} α)))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 (@list.nil.{u_1} α)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252    (λ tl hd ih, by rw [← cons_append, maximum_concat, ih, maximum_concat, max_assoc])</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='tl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='list.cons_append'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ih'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum_concat'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='max_assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/list/lemmas.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 237, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 237, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl)) (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a) (@list.maximum.{u_1} α _inst_2 tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} (x : α) (s t : list.{u_1} α), @eq.{u_1+1} (list.{u_1} α) (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) (@list.cons.{u_1} α x s) t) (@list.cons.{u_1} α x (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) s t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] (a : α) (l : list.{u_1} α), @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2) (@list.maximum.{u_1} α _inst_2 l) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl)) (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a) (@list.maximum.{u_1} α _inst_2 tl))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] (a : α) (l : list.{u_1} α), @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) l (@list.cons.{u_1} α a (@list.nil.{u_1} α)))) (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2) (@list.maximum.{u_1} α _inst_2 l) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] (a b c : α), @eq.{u_1+1} α (@max.{u_1} α _inst_1 (@max.{u_1} α _inst_1 a b) c) (@max.{u_1} α _inst_1 a (@max.{u_1} α _inst_1 b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l tl : list.{u_1} α,
hd : α,
ih :
  @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 tl))
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@list.maximum.{u_1} α _inst_2
       (@list.cons.{u_1} α a
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l tl : list.{u_1} α,
hd : α,
ih :
  @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 tl))
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@list.maximum.{u_1} α _inst_2
       (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) (@list.cons.{u_1} α a tl)
          (@list.cons.{u_1} α hd (@list.nil.{u_1} α))))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l tl : list.{u_1} α,
hd : α,
ih :
  @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 tl))
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl))
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          hd))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l tl : list.{u_1} α,
hd : α,
ih :
  @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 tl))
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@list.maximum.{u_1} α _inst_2 tl))
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          hd))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2
          (@has_append.append.{u_1} (list.{u_1} α) (@list.has_append.{u_1} α) tl
             (@list.cons.{u_1} α hd (@list.nil.{u_1} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
a : α,
l tl : list.{u_1} α,
hd : α,
ih :
  @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a tl))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@list.maximum.{u_1} α _inst_2 tl))
⊢ @eq.{u_1+1} (with_bot.{u_1} α)
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             a)
          (@list.maximum.{u_1} α _inst_2 tl))
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          hd))
    (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          a)
       (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2)
          (@list.maximum.{u_1} α _inst_2 tl)
          (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
             (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
             hd)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  theorem minimum_cons (a : α) (l : list α) : minimum (a :: l) = min a (minimum l) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {T : Type u_1}, T → list.{u_1} T → list.{u_1} T'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [_inst_1 : decidable_linear_order.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  min_comm (minimum l) a ▸ @maximum_cons (order_dual α) _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='min_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.subst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum_cons'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 50, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 190, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 250, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : decidable_linear_order.{u_1} α] (a b : α), @eq.{u_1+1} α (@min.{u_1} α _inst_1 a b) (@min.{u_1} α _inst_1 b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} {P : α → Prop} {a b : α}, @eq.{u_1+1} α a b → P a → P b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] (a : α) (l : list.{u_1} α), @eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 (@list.cons.{u_1} α a l)) (@max.{u_1} (with_bot.{u_1} α) (@with_bot.decidable_linear_order.{u_1} α _inst_2) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) a) (@list.maximum.{u_1} α _inst_2 l))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  theorem maximum_eq_coe_iff {m : α} {l : list α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258    maximum l = m ↔ m ∈ l ∧ (∀ a ∈ l, a ≤ m) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_bot.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ iff
    (@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          m))
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260    unfold_coes,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Unfold coercion-related definitions'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='unfold_coes'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ iff
    (@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l)
       (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α)
          (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α))
          m))
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ iff (@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l) (@option.some.{u_1} α m))
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261    simp only [maximum, argmax_eq_some_iff, id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='list.maximum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.argmax_eq_some_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 200, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 183, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_2 : decidable_linear_order.{?l_1} α], list.{?l_1} α → with_bot.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : decidable_linear_order.{?l_2} β] [_inst_2 : decidable_eq.{?l_1+1} α] {f : α → β} {m : α} {l : list.{?l_1} α}, iff (@eq.{?l_1+1} (option.{?l_1} α) (@list.argmax.{?l_1 ?l_2} α β _inst_1 f l) (@option.some.{?l_1} α m)) (and (@has_mem.mem.{?l_1 ?l_1} α (list.{?l_1} α) (@list.has_mem.{?l_1} α) m l) (and (∀ (a : α), @has_mem.mem.{?l_1 ?l_1} α (list.{?l_1} α) (@list.has_mem.{?l_1} α) a l → @has_le.le.{?l_2} β (@preorder.to_has_le.{?l_2} β (@partial_order.to_preorder.{?l_2} β (@lattice.semilattice_inf.to_partial_order.{?l_2} β (@lattice.lattice.to_semilattice_inf.{?l_2} β (@lattice.lattice_of_decidable_linear_order.{?l_2} β _inst_1))))) (f a) (f m)) (∀ (a : α), @has_mem.mem.{?l_1 ?l_1} α (list.{?l_1} α) (@list.has_mem.{?l_1} α) a l → @has_le.le.{?l_2} β (@preorder.to_has_le.{?l_2} β (@partial_order.to_preorder.{?l_2} β (@lattice.semilattice_inf.to_partial_order.{?l_2} β (@lattice.lattice.to_semilattice_inf.{?l_2} β (@lattice.lattice_of_decidable_linear_order.{?l_2} β _inst_1))))) (f m) (f a) → @has_le.le.{0} nat nat.has_le (@list.index_of.{?l_1} α (λ (a b : α), _inst_2 a b) m l) (@list.index_of.{?l_1} α (λ (a b : α), _inst_2 a b) a l))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort ?l_1}, α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' `maximum l` returns an `with_bot α`, the largest element of `l` for nonempty lists, and `⊥` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ iff (@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l) (@option.some.{u_1} α m))
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ iff
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (and
          (∀ (a : α),
             @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
             @has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               m)
          (∀ (a : α),
             @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
             @has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               m
               a →
             @has_le.le.{0} nat nat.has_le
               (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
               (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l))))
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ iff
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (and
          (∀ (a : α),
             @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
             @has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               a
               m)
          (∀ (a : α),
             @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
             @has_le.le.{u_1} α
               (@preorder.to_has_le.{u_1} α
                  (@partial_order.to_preorder.{u_1} α
                     (@lattice.semilattice_inf.to_partial_order.{u_1} α
                        (@lattice.lattice.to_semilattice_inf.{u_1} α
                           (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
               m
               a →
             @has_le.le.{0} nat nat.has_le
               (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
               (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l))))
    (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l))) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m)

α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263    { simp only [true_and, forall_true_iff] {contextual := tt} },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='true_and'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='forall_true_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and true a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1}, iff (α → true) true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l))) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m)

α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l))) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    { simp only [true_and, forall_true_iff] {contextual := tt},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='true_and'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='forall_true_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 404, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 467, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (and true a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Sort ?l_1}, iff (α → true) true'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m) →
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (and
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            a
            m)
       (∀ (a : α),
          @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
          @has_le.le.{u_1} α
            (@preorder.to_has_le.{u_1} α
               (@partial_order.to_preorder.{u_1} α
                  (@lattice.semilattice_inf.to_partial_order.{u_1} α
                     (@lattice.lattice.to_semilattice_inf.{u_1} α
                        (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
            m
            a →
          @has_le.le.{0} nat nat.has_le
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
            (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m) →
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_1} α
      (@preorder.to_has_le.{u_1} α
         (@partial_order.to_preorder.{u_1} α
            (@lattice.semilattice_inf.to_partial_order.{u_1} α
               (@lattice.lattice.to_semilattice_inf.{u_1} α
                  (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
      m
      a →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265      intros h a hal hma,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α
⊢ and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m) →
  ∀ (a : α),
    @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
    @has_le.le.{u_1} α
      (@preorder.to_has_le.{u_1} α
         (@partial_order.to_preorder.{u_1} α
            (@lattice.semilattice_inf.to_partial_order.{u_1} α
               (@lattice.lattice.to_semilattice_inf.{u_1} α
                  (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
      m
      a →
    @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
      (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α,
h :
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m),
a : α,
hal : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l,
hma :
  @has_le.le.{u_1} α
    (@preorder.to_has_le.{u_1} α
       (@partial_order.to_preorder.{u_1} α
          (@lattice.semilattice_inf.to_partial_order.{u_1} α
             (@lattice.lattice.to_semilattice_inf.{u_1} α
                (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
    m
    a
⊢ @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266      rw [le_antisymm hma (h.2 a hal)] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='le_antisymm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : partial_order.{u_1} α] {a b : α}, @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) a b → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α _inst_1)) b a → @eq.{u_1+1} α a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) m a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l) (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) a m)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α,
h :
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m),
a : α,
hal : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l,
hma :
  @has_le.le.{u_1} α
    (@preorder.to_has_le.{u_1} α
       (@partial_order.to_preorder.{u_1} α
          (@lattice.semilattice_inf.to_partial_order.{u_1} α
             (@lattice.lattice.to_semilattice_inf.{u_1} α
                (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
    m
    a
⊢ @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u_1,
_inst_2 : decidable_linear_order.{u_1} α,
m : α,
l : list.{u_1} α,
h :
  and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l)
    (∀ (a : α),
       @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l →
       @has_le.le.{u_1} α
         (@preorder.to_has_le.{u_1} α
            (@partial_order.to_preorder.{u_1} α
               (@lattice.semilattice_inf.to_partial_order.{u_1} α
                  (@lattice.lattice.to_semilattice_inf.{u_1} α
                     (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
         a
         m),
a : α,
hal : @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l,
hma :
  @has_le.le.{u_1} α
    (@preorder.to_has_le.{u_1} α
       (@partial_order.to_preorder.{u_1} α
          (@lattice.semilattice_inf.to_partial_order.{u_1} α
             (@lattice.lattice.to_semilattice_inf.{u_1} α
                (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2)))))
    m
    a
⊢ @has_le.le.{0} nat nat.has_le (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) m l)
    (@list.index_of.{u_1} α (λ (a b : α), @eq.decidable.{u_1} α _inst_2 a b) a l)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269  theorem minimum_eq_coe_iff {m : α} {l : list α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='list'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 286, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270    minimum l = m ↔ m ∈ l ∧ (∀ a ∈ l, m ≤ a) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='list.minimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='and'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='l'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='m'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 204, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α], list.{u_1} α → with_top.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u_1} [c : has_mem.{u_1 u_1} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='list.{u_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_le.{u_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title=' `minimum l` returns an `with_top α`, the smallest element of `l` for nonempty lists, and `⊤` for
`[]`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  @maximum_eq_coe_iff (order_dual α) _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='list.maximum_eq_coe_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='order_dual'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 257, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/basic.lean&#x27;, &#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u_1} [_inst_2 : decidable_linear_order.{u_1} α] {m : α} {l : list.{u_1} α}, iff (@eq.{u_1+1} (with_bot.{u_1} α) (@list.maximum.{u_1} α _inst_2 l) (@coe.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@coe_to_lift.{u_1+1 u_1+1} α (with_bot.{u_1} α) (@with_bot.has_coe_t.{u_1} α)) m)) (and (@has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) m l) (∀ (a : α), @has_mem.mem.{u_1 u_1} α (list.{u_1} α) (@list.has_mem.{u_1} α) a l → @has_le.le.{u_1} α (@preorder.to_has_le.{u_1} α (@partial_order.to_preorder.{u_1} α (@lattice.semilattice_inf.to_partial_order.{u_1} α (@lattice.lattice.to_semilattice_inf.{u_1} α (@lattice.lattice_of_decidable_linear_order.{u_1} α _inst_2))))) a m))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Type tag for a set with dual order: `≤` means `≥` and `&lt;` means `&gt;`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  end list</code></pre>
</body>