<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Reid Barton. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Reid Barton, Johan Commelin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.equivalence</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.equiv.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes v₁ v₂ v₃ u₁ u₂ u₃ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  local attribute [elab_simple] whisker_left whisker_right</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated from left to right, and without propagating information from the expected type to its arguments'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {C : Type u₁} [𝒞 : category.{v₁} C] {D : Type u₂} [𝒟 : category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{v₁ u₁} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{v₂ u₂} D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  `F ⊣ G` represents the data of an adjunction between two functors</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  `F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  structure adjunction (F : C ⥤ D) (G : D ⥤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  (hom_equiv : Π (X Y), (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v₂ → Type v₁ → Type (max (max v₂ v₁) v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  (unit : 𝟭 C ⟶ F.comp G)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  (counit : G.comp F ⟶ 𝟭 D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₂} [ℰ : category_theory.category.{v₂ u₂} E], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₂ u₁ u₂} D 𝒟 E ℰ → @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₂ u₂)} [c : category_theory.has_hom.{(max u₂ v₂) (max v₂ u₂)} obj], obj → obj → Type (max u₂ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  (hom_equiv_unit&#x27; : Π {X Y f}, (hom_equiv X Y) f = (unit : _ ⟶ _).app X ≫ G.map f . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  (hom_equiv_counit&#x27; : Π {X Y g}, (hom_equiv X Y).symm g = F.map g ≫ counit.app Y . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  infix ` ⊣ `:15 := adjunction</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  class is_left_adjoint (left : C ⥤ D) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  (right : D ⥤ C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  (adj : left ⊣ right)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  class is_right_adjoint (right : D ⥤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  (left : C ⥤ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  (adj : left ⊣ right)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  def left_adjoint (R : D ⥤ C) [is_right_adjoint R] : C ⥤ D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_right_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  is_right_adjoint.left R</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.is_right_adjoint.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (right : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) [c : @category_theory.is_right_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 right], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  def right_adjoint (L : C ⥤ D) [is_left_adjoint L] : D ⥤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_left_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  is_left_adjoint.right L</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.is_left_adjoint.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (left : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [c : @category_theory.is_left_adjoint.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 left], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  namespace adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  restate_axiom hom_equiv_unit&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  restate_axiom hom_equiv_counit&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  attribute [simp, priority 10] hom_equiv_unit hom_equiv_counit</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y}, @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y) f) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) X) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X : C} {Y : D} {g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)}, @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y)) g) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) g) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  variables {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) {X&#x27; X : C} {Y Y&#x27; : D}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  @[simp, priority 10] lemma hom_equiv_naturality_left_symm (f : X&#x27; ⟶ X) (g : X ⟶ G.obj Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    (adj.hom_equiv X&#x27; Y).symm (f ≫ g) = F.map f ≫ (adj.hom_equiv X Y).symm g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  by rw [hom_equiv_counit, F.map_comp, assoc, adj.hom_equiv_counit.symm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X : C} {Y : D} {g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)}, @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y)) g) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) g) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) f g)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) g) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) Y)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             f
             g))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             g))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             g)
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  @[simp] lemma hom_equiv_naturality_left (f : X&#x27; ⟶ X) (g : F.obj X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    (adj.hom_equiv X&#x27; Y) (F.map f ≫ g) = f ≫ (adj.hom_equiv X Y) g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  by rw [← equiv.eq_symm_apply]; simp [-hom_equiv_unit]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α y (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) (@eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       g)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  @[simp, priority 10] lemma hom_equiv_naturality_right (f : F.obj X ⟶ Y) (g : Y ⟶ Y&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    (adj.hom_equiv X Y&#x27;) (f ≫ g) = (adj.hom_equiv X Y) f ≫ G.map g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  by rw [hom_equiv_unit, G.map_comp, ← assoc, ←hom_equiv_unit]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y}, @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y) f) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) X) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y&#x27; (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y Y&#x27; f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y f) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y}, @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y) f) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) X) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          f
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          f)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          X)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y&#x27;
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             Y&#x27;
             f
             g)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          f)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          X)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             f)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          f)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             f))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          f)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          f
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          f)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          f
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          f)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] lemma hom_equiv_naturality_right_symm (f : X ⟶ G.obj Y) (g : Y ⟶ Y&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    (adj.hom_equiv X Y&#x27;).symm (f ≫ G.map g) = (adj.hom_equiv X Y).symm f ≫ g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  by rw [equiv.symm_apply_eq]; simp [-hom_equiv_counit]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x) y) (@eq.{v₁+1} β x (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       f
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
             f)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  @[simp] lemma left_triangle :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (whisker_right adj.unit F) ≫ (whisker_left F adj.counit) = nat_trans.id _ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u₁ v₂)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ @eq.{(max u₁ v₂)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F)
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)))
    (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F)
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          F)
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.id.{v₂ u₂} D 𝒟))
       (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          F)
       (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)))
    (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ @eq.{(max u₁ v₂)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F)
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)))
    (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F)
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          F)
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.id.{v₂ u₂} D 𝒟))
       (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          F)
       (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)))
    (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          x))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F)
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.id.{v₂ u₂} D 𝒟))
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             F)
          (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)))
       x)
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          F)
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
          (@category_theory.functor.id.{v₂ u₂} D 𝒟))
       (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             x))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    erw [← adj.hom_equiv_counit, equiv.symm_apply_eq, adj.hom_equiv_unit],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj x (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) x)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) x)) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x) y) (@eq.{v₁+1} β x (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj x (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) x (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) x) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             x))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             x
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             x
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             x
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj x
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          x))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       x
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
       (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
       (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
       x)
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             x
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             x
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj x
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
       (@category_theory.category_struct.id.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       x
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
       (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
       (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
       x)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       x
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          x)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : C
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       x
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
       (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
       (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
       x)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       x
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          x)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  @[simp] lemma right_triangle :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    (whisker_left G adj.unit) ≫ (whisker_right adj.counit G) = nat_trans.id _ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₂ v₁ u₂ u₁)} [c : category_theory.category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) X Y → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type (max u₂ v₁)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ @eq.{(max u₂ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
       (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
       (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)))
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          G))
    (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
       (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
       (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          G)
       (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj))
       (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          G))
    (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ @eq.{(max u₂ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
       (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
       (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)))
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          G))
    (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
       (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
       (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          G)
       (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj))
       (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          G))
    (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          x))
    (@category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          G)
       (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj))
          (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             G))
       x)
    (@category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          G)
       (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
          x
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             x)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    erw [← adj.hom_equiv_unit, ← equiv.eq_symm_apply, adj.hom_equiv_counit],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) x) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) x)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α y (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) (@eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) x)) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)) x (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
          x
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             x)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
             x)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
             x)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))
       (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
          x)
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          x))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       x)
    (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
       (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
       (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
       x)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
             x))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
             x))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
             x)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
          (@category_theory.adjunction.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
             x))
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       x)
    (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
       (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
       (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
       x)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       x
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
x : D
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       x)
    (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
       (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
       (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
       x)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x))
       x
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G x)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  @[simp, reassoc] lemma left_triangle_components :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    F.map (adj.unit.app X) ≫ adj.counit.app (F.obj X) = 𝟙 (F.obj X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  congr_arg (λ (t : nat_trans _ (𝟭 C ⋙ F)), t.app X) adj.left_triangle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.left_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u₁ v₂)} {β : Type v₂} {a₁ a₂ : α} (f : α → β), @eq.{(max u₁ v₂)+1} α a₁ a₂ → @eq.{v₂+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₂} [ℰ : category_theory.category.{v₂ u₂} E], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₂ u₁ u₂} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.id.{v₂ u₂} D 𝒟))) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) F) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.id.{v₂ u₂} D 𝒟)) (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) F) (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj))) (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `α.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  @[simp, reassoc] lemma right_triangle_components {Y : D} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    adj.unit.app (G.obj Y) ≫ G.map (adj.counit.app Y) = 𝟙 (G.obj Y) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  congr_arg (λ (t : nat_trans _ (G ⋙ 𝟭 C)), t.app Y) adj.right_triangle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.right_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u₂ v₁)} {β : Type v₁} {a₁ a₂ : α} (f : α → β), @eq.{(max u₂ v₁)+1} α a₁ a₂ → @eq.{v₁+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → Type (max u₂ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.nat_trans.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (adj : @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G), @eq.{(max u₂ v₁)+1} (@category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.id.{v₂ u₂} D 𝒟) G)) (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.id.{v₂ u₂} D 𝒟) G) (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)) (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) G)) (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `α.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  @[simp, reassoc] lemma counit_naturality {X Y : D} (f : X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    F.map (G.map f) ≫ (adj.counit).app Y = (adj.counit).app X ≫ f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  adj.counit.naturality f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[simp, reassoc] lemma unit_naturality {X Y : C} (f : X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    (adj.unit).app X ≫ G.map (F.map f) = f ≫ (adj.unit).app Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  (adj.unit.naturality f).symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v₁} {a b : α}, @eq.{v₁+1} α a b → @eq.{v₁+1} α b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  end adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  namespace adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  structure core_hom_equiv (F : C ⥤ D) (G : D ⥤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  (hom_equiv : Π (X Y), (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v₂ → Type v₁ → Type (max (max v₂ v₁) v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  (hom_equiv_naturality_left_symm&#x27; : Π {X&#x27; X Y} (f : X&#x27; ⟶ X) (g : X ⟶ G.obj Y),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    (hom_equiv X&#x27; Y).symm (f ≫ g) = F.map f ≫ (hom_equiv X Y).symm g . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  (hom_equiv_naturality_right&#x27; : Π {X Y Y&#x27;} (f : F.obj X ⟶ Y) (g : Y ⟶ Y&#x27;),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    (hom_equiv X Y&#x27;) (f ≫ g) = (hom_equiv X Y) f ≫ G.map g . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  namespace core_hom_equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  restate_axiom hom_equiv_naturality_left_symm&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  restate_axiom hom_equiv_naturality_right&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  attribute [simp, priority 10] hom_equiv_naturality_left_symm hom_equiv_naturality_right</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_left_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X&#x27; Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) f g)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) {X : C} {Y Y&#x27; : D} (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y Y&#x27; f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X Y) f) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  variables {F : C ⥤ D} {G : D ⥤ C} (adj : core_hom_equiv F G) {X&#x27; X : C} {Y Y&#x27; : D}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  @[simp] lemma hom_equiv_naturality_left (f : X&#x27; ⟶ X) (g : F.obj X ⟶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    (adj.hom_equiv X&#x27; Y) (F.map f ≫ g) = f ≫ (adj.hom_equiv X Y) g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  by rw [← equiv.eq_symm_apply]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α y (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) (@eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       g)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  @[simp] lemma hom_equiv_naturality_right_symm (f : X ⟶ G.obj Y) (g : Y ⟶ Y&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    (adj.hom_equiv X Y&#x27;).symm (f ≫ G.map g) = (adj.hom_equiv X Y).symm f ≫ g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  by rw [equiv.symm_apply_eq]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x) y) (@eq.{v₁+1} β x (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       f
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
             f)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  end core_hom_equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  structure core_unit_counit (F : C ⥤ D) (G : D ⥤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  (unit : 𝟭 C ⟶ F.comp G)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁)} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  (counit : G.comp F ⟶ 𝟭 D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₂} [ℰ : category_theory.category.{v₂ u₂} E], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₂ u₁ u₂} D 𝒟 E ℰ → @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₂ u₂)} [c : category_theory.has_hom.{(max u₂ v₂) (max v₂ u₂)} obj], obj → obj → Type (max u₂ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [𝒞 : category_theory.category.{v₂ u₂} C], @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  (left_triangle&#x27; : whisker_right unit F ≫ (functor.associator F G F).hom ≫ whisker_left F counit = nat_trans.id (𝟭 C ⋙ F) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} B ℬ C 𝒞) (H : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟), @category_theory.iso.{(max u₁ v₄) (max v₁ v₄ u₁ u₄)} (@category_theory.functor.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.category.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.comp.{v₁ v₃ v₄ u₁ u₃ u₄} A 𝒜 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} A 𝒜 B ℬ C 𝒞 F G) H) (@category_theory.functor.comp.{v₁ v₂ v₄ u₁ u₂ u₄} A 𝒜 B ℬ D 𝒟 F (@category_theory.functor.comp.{v₂ v₃ v₄ u₂ u₃ u₄} B ℬ C 𝒞 D 𝒟 G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ v₂ u₁ u₂)} [_inst_1 : category_theory.category.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₂} [ℰ : category_theory.category.{v₂ u₂} E], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₂ u₁ u₂} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  (right_triangle&#x27; : whisker_left G unit ≫ (functor.associator G F G).inv ≫ whisker_right counit G = nat_trans.id (G ⋙ 𝟭 C) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₂ v₁ u₂ u₁)} [c : category_theory.category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) X Y → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} B ℬ C 𝒞) (H : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟), @category_theory.iso.{(max u₁ v₄) (max v₁ v₄ u₁ u₄)} (@category_theory.functor.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.category.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.comp.{v₁ v₃ v₄ u₁ u₃ u₄} A 𝒜 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} A 𝒜 B ℬ C 𝒞 F G) H) (@category_theory.functor.comp.{v₁ v₂ v₄ u₁ u₂ u₄} A 𝒜 B ℬ D 𝒟 F (@category_theory.functor.comp.{v₂ v₃ v₄ u₂ u₃ u₄} B ℬ C 𝒞 D 𝒟 G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₂ v₁ u₂ u₁)} [_inst_1 : category_theory.category.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} C] {X Y : C}, @category_theory.iso.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} C (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} C (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₂ v₁ u₂ u₁)} [c : category_theory.category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) X Y → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → name → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  namespace core_unit_counit</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  restate_axiom left_triangle&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  restate_axiom right_triangle&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  attribute [simp] left_triangle right_triangle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.left_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.right_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G), @eq.{(max u₁ v₂)+1} (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.id.{v₂ u₂} D 𝒟))) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) F) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.id.{v₂ u₂} D 𝒟)) (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) F) (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) F) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.id.{v₂ u₂} D 𝒟)) (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) F) (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)) (@category_theory.functor.associator.{u₁ v₁ u₂ v₂ u₁ v₁ u₂ v₂} C 𝒞 D 𝒟 C 𝒞 D 𝒟 F G F)) (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c)))) (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟 (@category_theory.functor.id.{v₁ u₁} C 𝒞) F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} (c : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G), @eq.{(max u₂ v₁)+1} (@category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.id.{v₂ u₂} D 𝒟) G)) (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.id.{v₂ u₂} D 𝒟) G) (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c)) (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) G) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.id.{v₂ u₂} D 𝒟) G) (@category_theory.iso.inv.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)} (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞) (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) G) (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)) (@category_theory.functor.associator.{u₂ v₂ u₁ v₁ u₂ v₂ u₁ v₁} D 𝒟 C 𝒞 D 𝒟 C 𝒞 G F G)) (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c) G))) (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G (@category_theory.functor.id.{v₁ u₁} C 𝒞)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  end core_unit_counit</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  variables {F : C ⥤ D} {G : D ⥤ C}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  def mk_of_hom_equiv (adj : core_hom_equiv F G) : F ⊣ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  { unit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    { app := λ X, (adj.hom_equiv X (F.obj X)) (𝟙 (F.obj X)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ ∀ ⦃X Y : C⦄
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            Y))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            Y)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X
            Y
            f)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj Y
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            Y)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155        intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ ∀ ⦃X Y : C⦄
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            Y))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            Y)
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X
            Y
            f)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj Y
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.id.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            Y)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
            (@category_theory.category_struct.id.{v₂ u₂} D
               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
         (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
            (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          Y)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X
          Y
          f)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                Y
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                Y
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj Y
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156        erw [← adj.hom_equiv_naturality_left, ← adj.hom_equiv_naturality_right],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y)) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y) f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) f) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          Y)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X
          Y
          f)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                Y
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                Y
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj Y
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                Y))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                Y)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X
                Y
                f))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                Y))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                Y)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X
                Y
                f))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157        dsimp, simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                Y))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                Y)
             (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X
                Y
                f))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                   (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                   X))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    counit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    { app := λ Y, (adj.hom_equiv _ _).inv_fun (𝟙 (G.obj Y)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161      naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ ∀ ⦃X Y : D⦄
  (f :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            Y))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            Y)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            Y)
         (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X
            Y
            f)
         (@equiv.inv_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  Y))
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     Y)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  Y))
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            Y)
         (@equiv.inv_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  X))
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  X))
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
         (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163        intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
⊢ ∀ ⦃X Y : D⦄
  (f :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      X
      Y),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            Y))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            Y)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            Y)
         (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X
            Y
            f)
         (@equiv.inv_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  Y))
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     Y)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  Y))
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            X)
         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            Y)
         (@equiv.inv_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  X))
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                  (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                     (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                     X)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
               (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                  (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                  X))
            (@category_theory.category_struct.id.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
         (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          Y)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X
          Y
          f)
       (@equiv.inv_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y)
       (@equiv.inv_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164        erw [← adj.hom_equiv_naturality_left_symm, ← adj.hom_equiv_naturality_right_symm],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) f g)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) f) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y))) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) f (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y) g))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X))) f) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          Y)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y)
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X
          Y
          f)
       (@equiv.inv_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y)
       (@equiv.inv_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y)
       (@equiv.inv_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   X)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)
             (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X
                Y
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165        dsimp, simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          Y))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X)
             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                Y)
             (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                X
                Y
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    X
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
             Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    hom_equiv_unit&#x27; := λ X Y f, by erw [← adj.hom_equiv_naturality_right]; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) f) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
       f)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.nat_trans.mk.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (λ (X : C),
                @coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                  (equiv.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        X
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        X
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                  (@category_theory.category_struct.id.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
             (λ (X Y : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           Y)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y)
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X
                           Y
                           f)
                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                           (equiv.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 Y
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 Y
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              Y
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y)
                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                           (equiv.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              X
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X
                           Y
                           f)))
                  (@eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y))
                     (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                        (equiv.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    X))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                        (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    X))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                        (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                           adj
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                        (@category_theory.category_struct.comp.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 Y))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                           (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 Y)
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X
                                 Y
                                 f))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y)
                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                           (equiv.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              X
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{v₁+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 Y)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y)
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X
                                 Y
                                 f)
                              (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                 (equiv.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Y
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                 (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Y
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    Y
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                 (equiv.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X
                                 Y
                                 f)))
                        (@eq.{v₁+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y))
                           (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                              (equiv.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          X))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          X))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.category_struct.comp.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                 (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y)
                                    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X
                                       Y
                                       f))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                 (equiv.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 v₁+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X
                              Y
                              f)
                           (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                              (equiv.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          Y))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          Y))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    Y)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.category_struct.id.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                        (λ
                         (_a :
                           @category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))),
                           @eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      Y))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      Y)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      Y)
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X
                                      Y
                                      f)
                                   (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                      (equiv.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            Y
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                      (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            Y
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞
                                         D
                                         𝒟
                                         F
                                         G
                                         adj
                                         Y
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                      (@category_theory.category_struct.id.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      Y)
                                   (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                      (equiv.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            X
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                      (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            X
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                      (… …)
                                      …)
                                   …))
                             …)
                        …
                        …
                        …))
                  …))
          X)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
       f)
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)
       f)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          X)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.nat_trans.mk.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (λ (X : C),
                @coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                  (equiv.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        X
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                  (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                        (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        X
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                  (@category_theory.category_struct.id.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
             (λ (X Y : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           Y)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y)
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X
                           Y
                           f)
                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                           (equiv.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 Y
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 Y
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              Y
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y)
                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                           (equiv.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              X
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X
                           Y
                           f)))
                  (@eq.{v₁+1}
                     (@category_theory.has_hom.hom.{v₁ u₁} C
                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y))
                     (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                        (equiv.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    X))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                        (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    X))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                        (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                           adj
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                        (@category_theory.category_struct.comp.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 Y))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                           (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 Y)
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X
                                 Y
                                 f))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                     (@category_theory.category_struct.comp.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X)
                        (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           Y)
                        (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                           (equiv.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                              (@category_theory.has_hom.hom.{v₂ u₂} D
                                 (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                              (@category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 X
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              X
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                           (@category_theory.category_struct.id.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                        (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                           (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{v₁+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 Y)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y)
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X
                                 Y
                                 f)
                              (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                 (equiv.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Y
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                 (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Y
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    Y
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                 (equiv.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X
                                 Y
                                 f)))
                        (@eq.{v₁+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y))
                           (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                              (equiv.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          X))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          X))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    X)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.category_struct.comp.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y))
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                 (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X)
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y)
                                    (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       X
                                       Y
                                       f))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                           (@category_theory.category_struct.comp.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                 (equiv.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                    (@category_theory.has_hom.hom.{v₂ u₂} D
                                       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       X
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                 (@category_theory.category_struct.id.{v₂ u₂} D
                                    (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
                              (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F
                                    G)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 v₁+1}
                        (@category_theory.has_hom.hom.{v₁ u₁} C
                           (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X)
                           (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                           (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                              (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                              X
                              Y
                              f)
                           (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                              (equiv.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          Y))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                          Y))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                       (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                       Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                    (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                    Y)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                              (@category_theory.category_struct.id.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                        (λ
                         (_a :
                           @category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                X)
                             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))),
                           @eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      Y))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      Y)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      Y)
                                   (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X
                                      Y
                                      f)
                                   (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                      (equiv.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            Y
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                      (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            Y
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞
                                         D
                                         𝒟
                                         F
                                         G
                                         adj
                                         Y
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))
                                      (@category_theory.category_struct.id.{v₂ u₂} D
                                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y))))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      X)
                                   (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                                      (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C
                                         𝒞
                                         F
                                         G)
                                      Y)
                                   (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                                      (equiv.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            X
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                      (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                                         (@category_theory.has_hom.hom.{v₂ u₂} D
                                            (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                               (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                                            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
                                         (@category_theory.has_hom.hom.{v₁ u₁} C
                                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                            X
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))))
                                      (… …)
                                      …)
                                   …))
                             …)
                        …
                        …
                        …))
                  …))
          X)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    hom_equiv_counit&#x27; := λ X Y f, by erw [← adj.hom_equiv_naturality_left_symm]; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) f g)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) f) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) Y)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
       f)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f)
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.nat_trans.mk.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (λ (Y : D),
                @equiv.inv_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        Y))
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        Y))
                  (@category_theory.category_struct.id.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
             (λ (X Y : D)
              (f :
                @category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{v₂+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y))
                     (@category_theory.category_struct.comp.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           Y)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)
                        (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X
                           Y
                           f)
                        (@equiv.inv_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                     (@category_theory.category_struct.comp.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)
                        (@equiv.inv_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                        (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X
                           Y
                           f)))
                  (@eq.{v₂+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y))
                     (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                        (equiv.{v₁+1 v₂+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)))
                        (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)))
                        (@equiv.symm.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                     (@category_theory.category_struct.comp.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)
                        (@equiv.inv_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                        (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{v₂+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.category_struct.comp.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 Y)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)
                              (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X
                                 Y
                                 f)
                              (@equiv.inv_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                           (@category_theory.category_struct.comp.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)
                              (@equiv.inv_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                              (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X
                                 Y
                                 f)))
                        (@eq.{v₂+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                              (equiv.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.symm.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@category_theory.category_struct.comp.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                           (@category_theory.category_struct.comp.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)
                              (@equiv.inv_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                              (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 v₂+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                           (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                              (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                              Y))
                        (@category_theory.category_struct.comp.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                           (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                              (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                              Y)
                           (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                              (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f))
                           (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                              (equiv.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.symm.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                        (λ
                         (_a :
                           @category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                Y)),
                           @eq.{1} Prop
                             (@eq.{v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      Y))
                                (@category_theory.category_struct.comp.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      Y)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      Y)
                                   (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X
                                      Y
                                      f)
                                   (@equiv.inv_fun.{v₂+1 v₁+1}
                                      (@category_theory.has_hom.hom.{v₂ u₂} D
                                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            Y))
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                            (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                               (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                               Y)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞
                                         D
                                         𝒟
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            Y))
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                                (@category_theory.category_struct.comp.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      Y)
                                   (@equiv.inv_fun.{v₂+1 v₁+1}
                                      (@category_theory.has_hom.hom.{v₂ u₂} D
                                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            X))
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                            (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                               (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                               X)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞
                                         D
                                         𝒟
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            X))
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                                   …))
                             …)
                        …
                        …
                        …))
                  …))
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
       f)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj X Y))
       f)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f)
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.nat_trans.mk.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (λ (Y : D),
                @equiv.inv_fun.{v₂+1 v₁+1}
                  (@category_theory.has_hom.hom.{v₂ u₂} D
                     (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                     (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        Y))
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                     (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                        (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                        Y))
                  (@category_theory.category_struct.id.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
             (λ (X Y : D)
              (f :
                @category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{v₂+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y))
                     (@category_theory.category_struct.comp.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           Y)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)
                        (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X
                           Y
                           f)
                        (@equiv.inv_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                     (@category_theory.category_struct.comp.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)
                        (@equiv.inv_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                        (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X
                           Y
                           f)))
                  (@eq.{v₂+1}
                     (@category_theory.has_hom.hom.{v₂ u₂} D
                        (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y))
                     (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                        (equiv.{v₁+1 v₂+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)))
                        (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)))
                        (@equiv.symm.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)))
                        (@category_theory.category_struct.comp.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                           (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                     (@category_theory.category_struct.comp.{v₂ u₂} D
                        (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X)
                        (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           Y)
                        (@equiv.inv_fun.{v₂+1 v₁+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.has_hom.hom.{v₁ u₁} C
                              (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                 (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                    (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G
                              adj
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X))
                           (@category_theory.category_struct.id.{v₁ u₁} C
                              (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                        (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                           (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{v₂+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@category_theory.category_struct.comp.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 Y)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)
                              (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X
                                 Y
                                 f)
                              (@equiv.inv_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                           (@category_theory.category_struct.comp.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)
                              (@equiv.inv_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                              (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X
                                 Y
                                 f)))
                        (@eq.{v₂+1}
                           (@category_theory.has_hom.hom.{v₂ u₂} D
                              (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                 (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y))
                           (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                              (equiv.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.symm.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@category_theory.category_struct.comp.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f)
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                           (@category_theory.category_struct.comp.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X)
                              (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 Y)
                              (@equiv.inv_fun.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       X))
                                 (@category_theory.category_struct.id.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                              (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                 (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 v₂+1}
                        (@category_theory.has_hom.hom.{v₂ u₂} D
                           (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                              (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                           (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                              (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                              Y))
                        (@category_theory.category_struct.comp.{v₂ u₂} D
                           (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                           (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                           (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                              (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                              Y)
                           (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                              (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                              (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X Y f))
                           (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                              (equiv.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@equiv.symm.{v₂+1 v₁+1}
                                 (@category_theory.has_hom.hom.{v₂ u₂} D
                                    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y))
                                 (@category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D
                                    𝒟
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                    (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                       (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                       Y)))
                              (@category_theory.category_struct.id.{v₁ u₁} C
                                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                 (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                        (λ
                         (_a :
                           @category_theory.has_hom.hom.{v₂ u₂} D
                             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                             (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                Y)),
                           @eq.{1} Prop
                             (@eq.{v₂+1}
                                (@category_theory.has_hom.hom.{v₂ u₂} D
                                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      Y))
                                (@category_theory.category_struct.comp.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      Y)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      Y)
                                   (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X
                                      Y
                                      f)
                                   (@equiv.inv_fun.{v₂+1 v₁+1}
                                      (@category_theory.has_hom.hom.{v₂ u₂} D
                                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            Y))
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                            (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                               (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                               Y)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞
                                         D
                                         𝒟
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            Y))
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))))
                                (@category_theory.category_struct.comp.{v₂ u₂} D
                                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D
                                         𝒟
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      X)
                                   (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                      (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                      Y)
                                   (@equiv.inv_fun.{v₂+1 v₁+1}
                                      (@category_theory.has_hom.hom.{v₂ u₂} D
                                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                                            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X))
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            X))
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                                            (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                               (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                               X)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞
                                         D
                                         𝒟
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)
                                         (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                                            (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                                            X))
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G X)))
                                   …))
                             …)
                        …
                        …
                        …))
                  …))
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    .. adj }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  def mk_of_unit_counit (adj : core_unit_counit F G) : F ⊣ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.adjunction.core_unit_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  { hom_equiv := λ X Y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    { to_fun := λ f, adj.unit.app X ≫ G.map f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {F G : @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      inv_fun := λ g, F.map g ≫ adj.counit.app Y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      left_inv := λ f, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    ((λ
      (g :
        @category_theory.has_hom.hom.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
        @category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             g)
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y))
       ((λ
         (f :
           @category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y),
           @category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X)
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y
                f))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176        change F.map (_ ≫ _) ≫ _ = _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    ((λ
      (g :
        @category_theory.has_hom.hom.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
        @category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             g)
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y))
       ((λ
         (f :
           @category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y),
           @category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X)
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y
                f))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X)
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y
                f)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177        rw [F.map_comp, assoc, ←functor.comp_map, adj.counit.naturality, ←assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.comp_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X)) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) f g)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X) f) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D] {E : Type u₂} [ℰ : category_theory.category.{v₂ u₂} E] (F : @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟) (G : @category_theory.functor.{v₁ v₂ u₁ u₂} D 𝒟 E ℰ) (X Y : C) (f : @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} E (@category_theory.category_struct.to_has_hom.{v₂ u₂} E (@category_theory.category.to_category_struct.{v₂ u₂} E ℰ)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 E ℰ (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} C 𝒞 D 𝒟 E ℰ F G) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} C 𝒞 E ℰ (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} C 𝒞 D 𝒟 E ℰ F G) Y)) (@category_theory.functor.map.{v₂ v₂ u₂ u₂} C 𝒞 E ℰ (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} C 𝒞 D 𝒟 E ℰ F G) X Y f) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} D 𝒟 E ℰ G (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ ⦃X Y : D⦄ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) Y) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y) (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) X Y f) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X) (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) Y) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) X) (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.id.{v₂ u₂} D 𝒟) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X)
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y
                f)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       Y
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y
                f)))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y
                f))
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             f)
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             Y)
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             f)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       Y
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X))
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X))
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178        convert id_comp _ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X X Y (@category_theory.category_struct.id.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       Y
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X))
          (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                X)
             (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                X))
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
       (@category_theory.functor.map.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179        have t := congr_arg (λ t : nat_trans _ _, t.app _) adj.left_triangle,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u₁ v₂)} {β : Type v₂} {a₁ a₂ : α} (f : α → β), @eq.{(max u₁ v₂)+1} α a₁ a₂ → @eq.{v₂+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `α.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
t :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          ?m_1))
    ((λ
      (t :
        @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))),
        @category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             F)
          (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
             (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                F)
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F))
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
                (@category_theory.functor.id.{v₂ u₂} D 𝒟))
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                   F)
                (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F))
                (@category_theory.functor.associator.{u₁ v₁ u₂ v₂ u₁ v₁ u₂ v₂} C 𝒞 D 𝒟 C 𝒞 D
                   𝒟
                   F
                   G
                   F))
             (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)))))
    ((λ
      (t :
        @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))),
        @category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          t
          ?m_1)
       (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180        dsimp at t,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
t :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          ?m_1))
    ((λ
      (t :
        @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))),
        @category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             F)
          (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
             (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                F)
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F))
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
                (@category_theory.functor.id.{v₂ u₂} D 𝒟))
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
                   F)
                (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F))
                (@category_theory.functor.associator.{u₁ v₁ u₂ v₂ u₁ v₁ u₂ v₂} C 𝒞 D 𝒟 C 𝒞 D
                   𝒟
                   F
                   G
                   F))
             (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟 F
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)))))
    ((λ
      (t :
        @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))),
        @category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟 F
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          t
          ?m_1)
       (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             F)))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
t :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             ?m_1))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))))
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181        simp only [id_comp] at t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
t :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             ?m_1))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))))
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
t :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             ?m_1))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182        exact t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) X)) (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))) (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
t :
  @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             ?m_1))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ?m_1))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X))
       (@category_theory.functor.obj.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y
⊢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184      right_inv := λ g, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             f))
       ((λ
         (g :
           @category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
           @category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                g)
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185        change _ ≫ G.map (_ ≫ _) = _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    ((λ
      (f :
        @category_theory.has_hom.hom.{v₂ u₂} D
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y
             f))
       ((λ
         (g :
           @category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
           @category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                g)
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          X)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                g)
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186        rw [G.map_comp, ←assoc, ←functor.comp_map, ←adj.unit.naturality, assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.comp_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (f : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y f g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) f) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 E ℰ) (X Y : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} E (@category_theory.category_struct.to_has_hom.{v₁ u₁} E (@category_theory.category.to_category_struct.{v₁ u₁} E ℰ)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 E ℰ F G) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 E ℰ F G) Y)) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 E ℰ (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 E ℰ F G) X Y f) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 E ℰ G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) Y) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) Y) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X Y f) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X) (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) X) (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          X)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                g)
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          X)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                g))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X)
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
                g)))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             X)
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             g))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             g)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          g)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187        convert comp_id _ g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Y f (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          g)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             Y
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188        have t := congr_arg (λ t : nat_trans _ _, t.app _) adj.right_triangle,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type (max u₂ v₁)} {β : Type v₁} {a₁ a₂ : α} (f : α → β), @eq.{(max u₂ v₁)+1} α a₁ a₂ → @eq.{v₁+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} C 𝒞 D 𝒟 → Type (max u₂ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `α.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
t :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          ?m_1))
    ((λ
      (t :
        @category_theory.nat_trans.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)),
        @category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj))
          (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
             (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                G)
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                G)
             (@category_theory.iso.inv.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                   G)
                (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
                (@category_theory.functor.associator.{u₂ v₂ u₁ v₁ u₂ v₂ u₁ v₁} D 𝒟 C 𝒞 D 𝒟 C
                   𝒞
                   G
                   F
                   G))
             (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                G))))
    ((λ
      (t :
        @category_theory.nat_trans.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)),
        @category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          t
          ?m_1)
       (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189        dsimp at t,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
t :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          ?m_1))
    ((λ
      (t :
        @category_theory.nat_trans.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)),
        @category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
             (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj))
          (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
             (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                G)
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                G)
             (@category_theory.iso.inv.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                   G)
                (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G))
                (@category_theory.functor.associator.{u₂ v₂ u₁ v₁ u₂ v₂ u₁ v₁} D 𝒟 C 𝒞 D 𝒟 C
                   𝒞
                   G
                   F
                   G))
             (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                G))))
    ((λ
      (t :
        @category_theory.nat_trans.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)),
        @category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             G)
          t
          ?m_1)
       (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞 G
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
t :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
             ?m_1
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                ?m_1))))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190        simp only [id_comp] at t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
t :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
             ?m_1
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
                ?m_1))))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
t :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
          ?m_1
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             ?m_1)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191        exact t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞 (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G) (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) Y (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟 (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟) (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj) Y))) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
t :
  @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
          ?m_1
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             ?m_1)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ?m_1))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)
          (@category_theory.adjunction.core_unit_counit.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          Y
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.adjunction.core_unit_counit.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G adj)
             Y)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
adj : @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    end },</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    .. adj }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  omit 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  def id : 𝟭 C ⊣ 𝟭 C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₁} [𝒟 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ v₁ u₁ u₁} D 𝒟 C 𝒞 → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  { hom_equiv := λ X Y, equiv.refl _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Sort u_1), equiv.{u_1 u_1} α α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    unit := 𝟙 _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.category_struct.{(max u₁ v₁) (max v₁ u₁)} obj] (X : obj), @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    counit := 𝟙 _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.category_struct.{(max u₁ v₁) (max v₁ u₁)} obj] (X : obj), @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  variables {E : Type u₃} [ℰ : category.{v₃} E] (H : D ⥤ E) (I : E ⥤ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₃) [_inst_2 : category_theory.category.{v₃ u₃} D], Type (max v₂ v₃ u₂ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π (C : Type u₃) [_inst_1 : category_theory.category.{v₃ u₃} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₃ v₂ u₃ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  def comp (adj₁ : F ⊣ G) (adj₂ : H ⊣ I) : F ⋙ H ⊣ I ⋙ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 → @category_theory.functor.{v₃ v₂ u₃ u₂} D 𝒟 C 𝒞 → Type (max u₂ u₃ v₂ v₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₃ v₂ u₃ u₂} E ℰ D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ → @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D], @category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 D 𝒟 → @category_theory.functor.{v₃ v₁ u₃ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₃ v₁ v₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₃ v₂ u₃ u₂} E ℰ D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₁} [ℰ : category_theory.category.{v₁ u₁} E], @category_theory.functor.{v₃ v₂ u₃ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 E ℰ → @category_theory.functor.{v₃ v₁ u₃ u₁} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  { hom_equiv := λ X Z, equiv.trans (adj₂.hom_equiv _ _) (adj₁.hom_equiv _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='adj₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u} {β : Sort v} {γ : Sort w}, equiv.{u v} α β → equiv.{v w} β γ → equiv.{u w} α γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D] {F : @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₃ v₂ u₃ u₂} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₃+1 v₂+1} (@category_theory.has_hom.hom.{v₃ u₃} D (@category_theory.category_struct.to_has_hom.{v₃ u₃} D (@category_theory.category.to_category_struct.{v₃ u₃} D 𝒟)) (@category_theory.functor.obj.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C 𝒞)) X (@category_theory.functor.obj.{v₃ v₂ u₃ u₂} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    unit := adj₁.unit ≫</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='adj₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.category_struct.{(max u₁ v₁) (max v₁ u₁)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    (whisker_left F $ whisker_right adj₂.unit G) ≫ (functor.associator _ _ _).inv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D] {F : @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₃ v₂ u₃ u₂} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₂ u₂} C 𝒞) (@category_theory.functor.comp.{v₂ v₃ v₂ u₂ u₃ u₂} C 𝒞 D 𝒟 C 𝒞 F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₁ u₁)} [c : category_theory.category_struct.{(max u₁ v₁) (max v₁ u₁)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} B ℬ C 𝒞) (H : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟), @category_theory.iso.{(max u₁ v₄) (max v₁ v₄ u₁ u₄)} (@category_theory.functor.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.category.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.comp.{v₁ v₃ v₄ u₁ u₃ u₄} A 𝒜 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} A 𝒜 B ℬ C 𝒞 F G) H) (@category_theory.functor.comp.{v₁ v₂ v₄ u₁ u₂ u₄} A 𝒜 B ℬ D 𝒟 F (@category_theory.functor.comp.{v₂ v₃ v₄ u₂ u₃ u₄} B ℬ C 𝒞 D 𝒟 G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type (max v₁ u₁)} [_inst_1 : category_theory.category.{(max u₁ v₁) (max v₁ u₁)} C] {X Y : C}, @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} C (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212    counit := (functor.associator _ _ _).hom ≫</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (G : @category_theory.functor.{v₂ v₃ u₂ u₃} B ℬ C 𝒞) (H : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟), @category_theory.iso.{(max u₁ v₄) (max v₁ v₄ u₁ u₄)} (@category_theory.functor.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.category.{v₁ v₄ u₁ u₄} A 𝒜 D 𝒟) (@category_theory.functor.comp.{v₁ v₃ v₄ u₁ u₃ u₄} A 𝒜 C 𝒞 D 𝒟 (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} A 𝒜 B ℬ C 𝒞 F G) H) (@category_theory.functor.comp.{v₁ v₂ v₄ u₁ u₂ u₄} A 𝒜 B ℬ D 𝒟 F (@category_theory.functor.comp.{v₂ v₃ v₄ u₂ u₃ u₄} B ℬ C 𝒞 D 𝒟 G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type (max v₃ u₃)} [_inst_1 : category_theory.category.{(max u₃ v₃) (max v₃ u₃)} C] {X Y : C}, @category_theory.iso.{(max u₃ v₃) (max v₃ u₃)} C _inst_1 X Y → @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} C (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} C (@category_theory.category.to_category_struct.{(max u₃ v₃) (max v₃ u₃)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₃ u₃)} [c : category_theory.category_struct.{(max u₃ v₃) (max v₃ u₃)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} obj (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} obj c) X Y → @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} obj (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} obj (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213      (whisker_left I $ whisker_right adj₁.counit H) ≫ adj₂.counit }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) {G H : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ}, @category_theory.has_hom.hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.category.to_category_struct.{(max u₂ v₃) (max v₂ v₃ u₂ u₃)} (@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ) (@category_theory.functor.category.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ))) G H → @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F G) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₃ v₂ u₃ u₂} E ℰ D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {E : Type u₃} [ℰ : category_theory.category.{v₃ u₃} E] {G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H → Π (F : @category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ), @category_theory.has_hom.hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.category.to_category_struct.{(max u₁ v₃) (max v₁ v₃ u₁ u₃)} (@category_theory.functor.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ) (@category_theory.functor.category.{v₁ v₃ u₁ u₃} C 𝒞 E ℰ))) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ G F) (@category_theory.functor.comp.{v₁ v₂ v₃ u₁ u₂ u₃} C 𝒞 D 𝒟 E ℰ H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₃ u₃)} [c : category_theory.category_struct.{(max u₃ v₃) (max v₃ u₃)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} obj (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} obj c) X Y → @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} obj (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} obj c) Y Z → @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} obj (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{v₂ v₃ u₂ u₃} D 𝒟 E ℰ H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [𝒞 : category_theory.category.{v₂ u₂} C] {D : Type u₃} [𝒟 : category_theory.category.{v₃ u₃} D] {F : @category_theory.functor.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₃ v₂ u₃ u₂} D 𝒟 C 𝒞}, @category_theory.adjunction.{v₂ v₃ u₂ u₃} C 𝒞 D 𝒟 F G → @category_theory.has_hom.hom.{(max u₃ v₃) (max v₃ u₃)} (@category_theory.functor.{v₃ v₃ u₃ u₃} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₃ v₃) (max v₃ u₃)} (@category_theory.functor.{v₃ v₃ u₃ u₃} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₃ v₃) (max v₃ u₃)} (@category_theory.functor.{v₃ v₃ u₃ u₃} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₃ v₃ u₃ u₃} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₃ v₂ v₃ u₃ u₂ u₃} D 𝒟 C 𝒞 D 𝒟 G F) (@category_theory.functor.id.{v₃ u₃} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  section construct_left</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  -- Construction of a left adjoint. In order to construct a left</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  -- adjoint to a functor G : D → C, it suffices to give the object part</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  -- of a functor F : C → D together with isomorphisms Hom(FX, Y) ≃</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  -- Hom(X, GY) natural in Y. The action of F on morphisms can be</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  -- constructed from this data.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  variables {F_obj : C → D} {G}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  variables (e : Π X Y, (F_obj X ⟶ Y) ≃ (X ⟶ G.obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v₂ → Type v₁ → Type (max (max v₂ v₁) v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D], @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  variables (he : Π X Y Y&#x27; g h, e X Y&#x27; (h ≫ g) = e X Y h ≫ G.map g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  include he</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  private lemma he&#x27; {X Y Y&#x27;} (f g) : (e X Y&#x27;).symm (f ≫ G.map g) = (e X Y).symm f ≫ g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₂} [_inst_1 : category_theory.category.{v₂ u₂} C] {D : Type u₁} [_inst_2 : category_theory.category.{v₁ u₁} D] (c : @category_theory.functor.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₂ u₂} C (@category_theory.category_struct.to_has_hom.{v₂ u₂} C (@category_theory.category.to_category_struct.{v₂ u₂} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ u₁} D (@category_theory.category_struct.to_has_hom.{v₁ u₁} D (@category_theory.category.to_category_struct.{v₁ u₁} D _inst_2)) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  by intros; rw [equiv.symm_apply_eq, he]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x) y) (@eq.{v₁+1} β x (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (F_obj X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (e X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (F_obj X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       f
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (F_obj X)
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (e X Y))
             f)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       f
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
          (e X Y)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                (e X Y))
             f))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (F_obj X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (e X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (F_obj X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y),
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (F_obj X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
          (e X Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
          f
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (F_obj X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  def left_adjoint_of_equiv : C ⥤ D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  { obj := F_obj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    map := λ X X&#x27; f, (e X (F_obj X&#x27;)).symm (f ≫ e X&#x27; (F_obj X&#x27;) (𝟙 _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] (X : obj), @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    map_comp&#x27; := λ X X&#x27; X&#x27;&#x27; f f&#x27;, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (F_obj X)
       (F_obj X&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
          (e X (F_obj X&#x27;&#x27;)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             X&#x27;
             X&#x27;&#x27;
             f
             f&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;&#x27;)))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (F_obj X)
       (F_obj X&#x27;)
       (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
             (e X (F_obj X&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
             f
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                (e X&#x27; (F_obj X&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;)))))
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235      rw [equiv.symm_apply_eq, he, equiv.apply_symm_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.apply_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x) y) (@eq.{v₁+1} β x (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) (x : β), @eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (F_obj X)
       (F_obj X&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
          (e X (F_obj X&#x27;&#x27;)))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             X&#x27;
             X&#x27;&#x27;
             f
             f&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;&#x27;)))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (F_obj X)
       (F_obj X&#x27;)
       (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
             (e X (F_obj X&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
             f
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                (e X&#x27; (F_obj X&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;)))))
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
       (e X (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (F_obj X)
          (F_obj X&#x27;)
          (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
                (e X (F_obj X&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
                f
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                   (e X&#x27; (F_obj X&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;)))))
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (e X (F_obj X&#x27;))
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;)))
                (e X (F_obj X&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
                f
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
                   (e X&#x27; (F_obj X&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;))))))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
          f
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
             (e X&#x27; (F_obj X&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;))))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236      conv { to_rhs, rw [assoc, ←he, id_comp, equiv.apply_symm_apply] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.apply_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X X Y (@category_theory.category_struct.id.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) (x : β), @eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
          f
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
             (e X&#x27; (F_obj X&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;))))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
          f
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
             (e X&#x27; (F_obj X&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;))))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (e X&#x27; (F_obj X&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;))))
    (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    X
    X&#x27;
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
    f
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (e X&#x27; (F_obj X&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;)))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    X
    X&#x27;
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
    f
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
       (e X&#x27; (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (F_obj X&#x27;)
          (F_obj X&#x27;)
          (F_obj X&#x27;&#x27;)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;))
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    X
    X&#x27;
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
    f
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
       (e X&#x27; (F_obj X&#x27;&#x27;))
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;))))
          (e X&#x27; (F_obj X&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;))))
    (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
    X
    X&#x27;
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
    f
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       f&#x27;
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       f
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X&#x27;&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
          f&#x27;
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       f
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X&#x27;&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
          f&#x27;
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
       f
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X&#x27;&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))
          f&#x27;
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (F_obj X&#x27;&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  def adjunction_of_equiv_left : left_adjoint_of_equiv e he ⊣ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='category_theory.adjunction.left_adjoint_of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 231, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} {F_obj : C → D} (e : Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))), (∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))) → @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  mk_of_hom_equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  { hom_equiv := e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    hom_equiv_naturality_left_symm&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
⊢ ∀ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
         (equiv.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                     (λ (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                     (λ (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.symm.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                     (λ (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X&#x27;
            X
            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
            f
            g))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X&#x27;)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X)
         Y
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X&#x27;
            X
            f)
         (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
            (equiv.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                     (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                        (λ (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                     (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                        (λ (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.symm.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                     (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                        (λ (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245      intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))
⊢ ∀ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
         (equiv.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                     (λ (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                     (λ (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.symm.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                  (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                     (λ (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X&#x27;
            X
            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
            f
            g))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X&#x27;)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X)
         Y
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
               (λ (X : C), F_obj X)
               e
               he)
            X&#x27;
            X
            f)
         (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
            (equiv.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                     (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                        (λ (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                     (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                        (λ (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.symm.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                     (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                        (λ (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;
          X
          f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246      erw [← he&#x27; e he, ← equiv.apply_eq_iff_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_private.2238520471.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='equiv.apply_eq_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 228, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞} {F_obj : C → D} (e : Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))), (∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))) → ∀ {X : C} {Y Y&#x27; : D} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (e X Y&#x27;)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) f (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)) (e X Y)) f) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v₂} (f : equiv.{v₂+1 v₂+1} α β) (x y : α), iff (@eq.{v₂+1} β (@coe_fn.{(max 1 (v₂+1)) v₂+1} (equiv.{v₂+1 v₂+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₂+1} α β) f x) (@coe_fn.{(max 1 (v₂+1)) v₂+1} (equiv.{v₂+1 v₂+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₂+1} α β) f y)) (@eq.{v₂+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;
          X
          f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          f
          g))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             ((λ (X : C), F_obj X) X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             ((λ (X : C), F_obj X) X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             ((λ (X : C), F_obj X) X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ((λ (X : C), F_obj X) X))
             f
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      ((λ (X : C), F_obj X) X)
                      ((λ (X : C), F_obj X) X))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ((λ (X : C), F_obj X) X))))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      ((λ (X : C), F_obj X) X)
                      ((λ (X : C), F_obj X) X))
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ((λ (X : C), F_obj X) X))))
                (e X ((λ (X : C), F_obj X) X))
                (@category_theory.category_struct.id.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                   ((λ (X : C), F_obj X) X))))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X)
             Y
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                         (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                            (λ (X : C), F_obj X)
                            e
                            he)
                         X)
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                         (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                            (λ (X : C), F_obj X)
                            e
                            he)
                         X)
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                         (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                            (λ (X : C), F_obj X)
                            e
                            he)
                         X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                   (e X Y))
                g))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{?l_1} ?m_2
    (@coe_fn.{(max 1 (imax (v₂+1) ?l_1) ?l_1 (v₂+1)) (imax (v₂+1) ?l_1)}
       (equiv.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             f
             g)))
    (@coe_fn.{(max 1 (imax (v₂+1) ?l_1) ?l_1 (v₂+1)) (imax (v₂+1) ?l_1)}
       (equiv.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ((λ (X : C), F_obj X) X))
                f
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         ((λ (X : C), F_obj X) X)
                         ((λ (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                            ((λ (X : C), F_obj X) X))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         ((λ (X : C), F_obj X) X)
                         ((λ (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                            ((λ (X : C), F_obj X) X))))
                   (e X ((λ (X : C), F_obj X) X))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      ((λ (X : C), F_obj X) X))))
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (e X Y))
                   g)))))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ equiv.{v₂+1 ?l_1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    ?m_2

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ Sort ?l_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247      simp [(he _ _ _ _ _).symm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y) (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (F_obj X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))) (e X Y) h) (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{?l_1} ?m_2
    (@coe_fn.{(max 1 (imax (v₂+1) ?l_1) ?l_1 (v₂+1)) (imax (v₂+1) ?l_1)}
       (equiv.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             f
             g)))
    (@coe_fn.{(max 1 (imax (v₂+1) ?l_1) ?l_1 (v₂+1)) (imax (v₂+1) ?l_1)}
       (equiv.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ((λ (X : C), F_obj X) X))
                f
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         ((λ (X : C), F_obj X) X)
                         ((λ (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                            ((λ (X : C), F_obj X) X))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         ((λ (X : C), F_obj X) X)
                         ((λ (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                            ((λ (X : C), F_obj X) X))))
                   (e X ((λ (X : C), F_obj X) X))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      ((λ (X : C), F_obj X) X))))
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (e X Y))
                   g)))))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ equiv.{v₂+1 ?l_1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    ?m_2

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ Sort ?l_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ @eq.{?l_1} ?m_2
    (@coe_fn.{(max 1 (imax (v₂+1) ?l_1) ?l_1 (v₂+1)) (imax (v₂+1) ?l_1)}
       (equiv.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             f
             g)))
    (@coe_fn.{(max 1 (imax (v₂+1) ?l_1) ?l_1 (v₂+1)) (imax (v₂+1) ?l_1)}
       (equiv.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{v₂+1 ?l_1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                   (λ (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                ((λ (X : C), F_obj X) X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X&#x27;
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X))
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
             (@category_theory.category_struct.comp.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                X&#x27;
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G ((λ (X : C), F_obj X) X))
                f
                (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                   (equiv.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         ((λ (X : C), F_obj X) X)
                         ((λ (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                            ((λ (X : C), F_obj X) X))))
                   (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         ((λ (X : C), F_obj X) X)
                         ((λ (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                            ((λ (X : C), F_obj X) X))))
                   (e X ((λ (X : C), F_obj X) X))
                   (@category_theory.category_struct.id.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                      ((λ (X : C), F_obj X) X))))
             (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                      (λ (X : C), F_obj X)
                      e
                      he)
                   X)
                Y
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                            (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G
                               (λ (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         X
                         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y))
                      (e X Y))
                   g)))))

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ equiv.{v₂+1 ?l_1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.adjunction.left_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G (λ (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    ?m_2

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞,
F_obj : C → D,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)),
he :
  ∀ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (F_obj X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 G Y)
⊢ Sort ?l_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  end construct_left</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  section construct_right</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  -- Construction of a right adjoint, analogous to the above.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  variables {F} {G_obj : D → C}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  variables (e : Π X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G_obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.has_hom.{v₂ u₂} obj], obj → obj → Type v₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type v₂ → Type v₁ → Type (max (max v₂ v₁) v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`α ≃ β` is the type of functions from `α → β` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  variables (he : Π X&#x27; X Y f g, e X&#x27; Y (F.map f ≫ g) = f ≫ e X Y g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  include he</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  private lemma he&#x27; {X&#x27; X Y} (f g) : F.map f ≫ (e X Y).symm g = (e X&#x27; Y).symm (f ≫ g) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  by intros; rw [equiv.eq_symm_apply, he]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α y (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) (@eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (G_obj Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (e X Y))
          g))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (G_obj Y)
          f
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (G_obj Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (G_obj Y))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y)))
       (e X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (G_obj Y))
                (e X Y))
             g)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (G_obj Y)
       f
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (G_obj Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (G_obj Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (G_obj Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y)))
          (e X Y)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (G_obj Y))
                (e X Y))
             g)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (G_obj Y)
       f
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (G_obj Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (e X Y))
          g))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (G_obj Y)
          f
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (G_obj Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y))
             (e X Y))
          g))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (G_obj Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (G_obj Y)
          f
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  def right_adjoint_of_equiv : D ⥤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₂) [_inst_1 : category_theory.category.{v₂ u₂} C] (D : Type u₁) [_inst_2 : category_theory.category.{v₁ u₁} D], Type (max v₂ v₁ u₂ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  { obj := G_obj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='D → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    map := λ Y Y&#x27; g, (e (G_obj Y) Y&#x27;) ((e (G_obj Y) Y).symm (𝟙 _) ≫ g),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D → C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₁}, equiv.{v₂+1 v₁+1} α β → equiv.{v₁+1 v₂+1} β α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {obj : Type u₂} [c : category_theory.category_struct.{v₂ u₂} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Y → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) Y Z → @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265    map_comp&#x27; := λ Y Y&#x27; Y&#x27;&#x27; g g&#x27;, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) Y&#x27; Y&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (G_obj Y)
       (G_obj Y&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (e (G_obj Y) Y&#x27;&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
          Y
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             Y
             Y&#x27;
             Y&#x27;&#x27;
             g
             g&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (G_obj Y)
       (G_obj Y&#x27;)
       (G_obj Y&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y)))
             g))
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (e (G_obj Y&#x27;) Y&#x27;&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
             Y&#x27;
             Y&#x27;&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                      Y&#x27;)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (e (G_obj Y&#x27;) Y&#x27;))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y&#x27;)))
             g&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266      rw [← equiv.eq_symm_apply, ← he&#x27; e he, equiv.symm_apply_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_private.1468233907.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α y (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x)) (@eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G_obj : D → C} (e : Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))), (∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))) → ∀ {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (e X Y)) g)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (e X&#x27; Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) (x : α), @eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (G_obj Y)
       (G_obj Y&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (e (G_obj Y) Y&#x27;&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
          Y
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             Y
             Y&#x27;
             Y&#x27;&#x27;
             g
             g&#x27;)))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (G_obj Y)
       (G_obj Y&#x27;)
       (G_obj Y&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y)))
             g))
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (e (G_obj Y&#x27;) Y&#x27;&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
             Y&#x27;
             Y&#x27;&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                      Y&#x27;)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (e (G_obj Y&#x27;) Y&#x27;))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y&#x27;)))
             g&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;))
          (e (G_obj Y) Y&#x27;&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (G_obj Y)
          (G_obj Y&#x27;)
          (G_obj Y&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g))
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (e (G_obj Y&#x27;) Y&#x27;&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;
                Y&#x27;&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                         Y&#x27;)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (e (G_obj Y&#x27;) Y&#x27;))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y&#x27;)))
                g&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g)))
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                ((λ (Y : D), G_obj Y) Y&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                ((λ (Y : D), G_obj Y) Y&#x27;&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                ((λ (Y : D), G_obj Y) Y&#x27;&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;&#x27;))
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (e (G_obj Y&#x27;) Y&#x27;&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;
                Y&#x27;&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                         Y&#x27;)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (e (G_obj Y&#x27;) Y&#x27;))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y&#x27;)))
                g&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
          Y&#x27;
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (e (G_obj Y&#x27;) Y&#x27;))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y&#x27;)))
          g&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267      conv { to_rhs, rw [← assoc, he&#x27; e he, comp_id, equiv.symm_apply_apply] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.1468233907.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G_obj : D → C} (e : Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))), (∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))) → ∀ {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (e X Y)) g)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (e X&#x27; Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Y f (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) (x : α), @eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) → conv.interactive.itactic → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
          Y&#x27;
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (e (G_obj Y&#x27;) Y&#x27;))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y&#x27;)))
          g&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
          Y&#x27;
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (e (G_obj Y&#x27;) Y&#x27;))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y&#x27;)))
          g&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
    Y&#x27;&#x27;
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y)))
             g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y&#x27;)))
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g)))
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y&#x27;))))
    g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             ((λ (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             ((λ (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             ((λ (Y : D), G_obj Y) Y&#x27;))
          (e (G_obj Y) Y&#x27;))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (G_obj Y)
          (G_obj Y&#x27;)
          ((λ (Y : D), G_obj Y) Y&#x27;)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                   (equiv.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y))
                   (@equiv.symm.{v₂+1 v₁+1}
                      (@category_theory.has_hom.hom.{v₂ u₂} D
                         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                      (G_obj Y)))
                g))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y&#x27;))))
    g&#x27;

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ C

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ C

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             ((λ (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             ((λ (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (G_obj Y)
             ((λ (Y : D), G_obj Y) Y&#x27;))
          (e (G_obj Y) Y&#x27;))
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y)))
             g)))
    g&#x27;

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ C

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ C

C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
    Y&#x27;&#x27;
    (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y) (G_obj Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   (G_obj Y)))
             g)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
       Y&#x27;
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y&#x27;))
                Y&#x27;)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y&#x27;)))
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       g)
    g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;
       Y&#x27;&#x27;
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y)))
          g)
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268      simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;
       Y&#x27;&#x27;
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y)))
          g)
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y&#x27;
    Y&#x27;&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
       Y&#x27;
       Y&#x27;&#x27;
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (G_obj Y)))
          g)
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  def adjunction_of_equiv_right : F ⊣ right_adjoint_of_equiv e he :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.right_adjoint_of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 262, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G_obj : D → C} (e : Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))), (∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))) → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  mk_of_hom_equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_hom_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  { hom_equiv := e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    hom_equiv_naturality_left_symm&#x27; := by intros; rw [equiv.symm_apply_eq, he]; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) {x : β} {y : α}, iff (@eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) x) y) (@eq.{v₁+1} β x (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
⊢ ∀ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (λ (Y : D), G_obj Y)
            e
            he)
         Y)),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
         (equiv.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y))
         (@equiv.symm.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X&#x27;
            X
            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
               (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                  (λ (Y : D), G_obj Y)
                  e
                  he)
               Y)
            f
            g))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
         (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
            (equiv.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y))
            (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y))
            (@equiv.symm.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (λ (Y : D), G_obj Y) e
          he)
       Y)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
       (equiv.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y))
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y))
       (@equiv.symm.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X&#x27;
          X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (λ (Y : D), G_obj Y)
                e
                he)
             Y)
          f
          g))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y))
             (e X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (λ (Y : D), G_obj Y) e
          he)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y)
       f
       g)
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X&#x27;
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y)))
       (e X&#x27; Y)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (e X Y))
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (λ (Y : D), G_obj Y) e
          he)
       Y)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X&#x27;
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y)
       f
       g)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X&#x27;
       X
       (G_obj Y)
       f
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (G_obj Y)))
          (e X Y)
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (e X Y))
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
⊢ ∀ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X
      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F (λ (Y : D), G_obj Y)
            e
            he)
         Y)),
    @eq.{v₂+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
         (equiv.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y))
         (@equiv.symm.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            X&#x27;
            X
            (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
               (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                  (λ (Y : D), G_obj Y)
                  e
                  he)
               Y)
            f
            g))
      (@category_theory.category_struct.comp.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y
         (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
         (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
            (equiv.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y))
            (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y))
            (@equiv.symm.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    hom_equiv_naturality_right&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
⊢ ∀ {X : C} {Y Y&#x27; : D}
  (f :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            Y&#x27;
            f
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (e X Y)
            f)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y
            Y&#x27;
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277      intros X Y Y&#x27; g h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
⊢ ∀ {X : C} {Y Y&#x27; : D}
  (f :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      Y
      Y&#x27;),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y&#x27;))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X
               (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                  (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                     (λ (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            Y&#x27;
            f
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y)
         (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y&#x27;)
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                     (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                        (λ (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (e X Y)
            f)
         (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
            (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
               (λ (Y : D), G_obj Y)
               e
               he)
            Y
            Y&#x27;
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      erw [←he, equiv.apply_eq_iff_eq, ←assoc, he&#x27; e he, comp_id, equiv.symm_apply_apply]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.apply_eq_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.1468233907.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (f : equiv.{v₂+1 v₁+1} α β) (x y : α), iff (@eq.{v₁+1} β (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) f x) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) f y)) (@eq.{v₂+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G_obj : D → C} (e : Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))), (∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))) → ∀ {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y)) (e X Y)) g)) (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y)) (@equiv.symm.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (e X&#x27; Y)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (X : C) (Y : D), equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; X) (g : @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f) g)) (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) Y) (@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Y f (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v₂} {β : Type v₁} (e : equiv.{v₂+1 v₁+1} α β) (x : α), @eq.{v₂+1} α (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))} (equiv.{v₁+1 v₂+1} β α) (@equiv.has_coe_to_fun.{v₁+1 v₂+1} β α) (@equiv.symm.{v₂+1 v₁+1} α β e) (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))} (equiv.{v₂+1 v₁+1} α β) (@equiv.has_coe_to_fun.{v₂+1 v₁+1} α β) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          g
          h))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (G_obj Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (G_obj Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y))
          Y&#x27;
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y)
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                            (λ (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                            (λ (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (e X Y)
                g))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
                (equiv.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      ((λ (Y : D), G_obj Y) Y)
                      ((λ (Y : D), G_obj Y) Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                      Y))
                (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      ((λ (Y : D), G_obj Y) Y)
                      ((λ (Y : D), G_obj Y) Y))
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                      Y))
                (@equiv.symm.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      ((λ (Y : D), G_obj Y) Y)
                      ((λ (Y : D), G_obj Y) Y))
                   (e ((λ (Y : D), G_obj Y) Y) Y))
                (@category_theory.category_struct.id.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                   ((λ (Y : D), G_obj Y) Y)))
             h)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (λ (Y : D), G_obj Y)
                e
                he)
             Y))
       Y&#x27;
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                (λ (Y : D), G_obj Y)
                e
                he)
             Y)
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (e X Y)
             g))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   ((λ (Y : D), G_obj Y) Y)
                   ((λ (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   ((λ (Y : D), G_obj Y) Y)
                   ((λ (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   ((λ (Y : D), G_obj Y) Y)
                   ((λ (Y : D), G_obj Y) Y))
                (e ((λ (Y : D), G_obj Y) Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                ((λ (Y : D), G_obj Y) Y)))
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y))
          Y
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y)
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                            (λ (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                            (λ (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (e X Y)
                g))
          (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
             (equiv.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   ((λ (Y : D), G_obj Y) Y)
                   ((λ (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   ((λ (Y : D), G_obj Y) Y)
                   ((λ (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.symm.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F ((λ (Y : D), G_obj Y) Y))
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   ((λ (Y : D), G_obj Y) Y)
                   ((λ (Y : D), G_obj Y) Y))
                (e ((λ (Y : D), G_obj Y) Y) Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                ((λ (Y : D), G_obj Y) Y))))
       h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                ((λ (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                ((λ (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                ((λ (Y : D), G_obj Y) Y))
             (e X Y))
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y)
             ((λ (Y : D), G_obj Y) Y)
             (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
                (equiv.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                            (λ (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                   (@category_theory.has_hom.hom.{v₂ u₂} D
                      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                      Y)
                   (@category_theory.has_hom.hom.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      X
                      (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                         (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                            (λ (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (e X Y)
                g)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                ((λ (Y : D), G_obj Y) Y))))
       h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (v₁+1) (v₂+1)) (v₂+1) (v₁+1)) (max (v₁+1) (v₂+1))}
          (equiv.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                ((λ (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.has_coe_to_fun.{v₁+1 v₂+1}
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                ((λ (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y))
          (@equiv.symm.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                ((λ (Y : D), G_obj Y) Y))
             (e X Y))
          (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
             (equiv.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
                (@category_theory.has_hom.hom.{v₂ u₂} D
                   (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                      (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                   Y)
                (@category_theory.has_hom.hom.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   X
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                         (λ (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (e X Y)
             g))
       h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
G_obj : D → C,
e :
  Π (X : C) (Y : D),
    equiv.{v₂+1 v₁+1}
      (@category_theory.has_hom.hom.{v₂ u₂} D
         (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
         (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
         Y)
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X
         (G_obj Y)),
he :
  ∀ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{v₂ u₂} D
      (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
         (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
      (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
         (equiv.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
            (@category_theory.has_hom.hom.{v₂ u₂} D
               (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                  (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
               (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{v₂ u₂} D
            (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27;)
            (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
            Y
            (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
            (equiv.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
               (@category_theory.has_hom.hom.{v₂ u₂} D
                  (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                     (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                  (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                  Y)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
    Y,
h :
  @category_theory.has_hom.hom.{v₂ u₂} D
    (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
    Y
    Y&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
       (equiv.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
          (@category_theory.has_hom.hom.{v₂ u₂} D
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                   (λ (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       X
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (v₂+1) (v₁+1)) (v₁+1) (v₂+1)) (max (v₂+1) (v₁+1))}
          (equiv.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{v₂+1 v₁+1}
             (@category_theory.has_hom.hom.{v₂ u₂} D
                (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
                   (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X)
                Y)
             (@category_theory.has_hom.hom.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                X
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
                      (λ (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.adjunction.right_adjoint_of_equiv.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F
             (λ (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  end construct_right</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  end adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  open adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  namespace equivalence</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  def to_adjunction (e : C ≌ D) : e.functor ⊣ e.inverse :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.inverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.equivalence.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.equivalence.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → @category_theory.functor.{v₂ v₁ u₂ u₁} D _inst_2 C _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
 a unit and counit which are natural isomorphisms and the triangle law `Fη ≫ εF = 1`, or in other
 words the composite `F ⟶ FGF ⟶ F` is the identity.

 The triangle equation is written as a family of equalities between morphisms, it is more
 complicated if we write it as an equality of natural transformations, because then we would have
 to insert natural transformations like `F ⟶ F1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  mk_of_unit_counit ⟨e.unit, e.counit,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_unit_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} {G : @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞}, @category_theory.adjunction.core_unit_counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁)} (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞) (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞))) (@category_theory.functor.id.{v₁ u₁} C 𝒞) (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞 (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e) (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.has_hom.hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.category.to_category_struct.{(max u₂ v₂) (max v₂ u₂)} (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟) (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟))) (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟 (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e) (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)) (@category_theory.functor.id.{v₂ u₂} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291    by { ext, dsimp, simp only [id_comp], exact e.functor_unit_comp _, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
⊢ auto_param.{0}
    (@eq.{(max u₁ v₂)+1}
       (@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)))
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
             (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟))
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
                (@category_theory.functor.associator.{u₁ v₁ u₂ v₂ u₁ v₁ u₂ v₂} C 𝒞 D 𝒟 C 𝒞 D
                   𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))))
       (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          x))
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟))
       (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₂ u₂} D 𝒟))
          (@category_theory.whisker_right.{u₁ v₁ u₁ v₁ u₂ v₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
             (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
             (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.id.{v₂ u₂} D 𝒟))
             (@category_theory.iso.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
                (@category_theory.functor.associator.{u₁ v₁ u₂ v₂ u₁ v₁ u₂ v₂} C 𝒞 D 𝒟 C 𝒞 D
                   𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.whisker_left.{u₁ v₁ u₂ v₂ u₂ v₂} C 𝒞 D 𝒟 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))))
       x)
    (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
       (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
       (@category_theory.functor.comp.{v₁ v₂ v₂ u₁ u₂ u₂} C 𝒞 D 𝒟 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.id.{v₂ u₂} D 𝒟))
       (@category_theory.nat_trans.id.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.functor.comp.{v₁ v₁ v₂ u₁ u₁ u₂} C 𝒞 C 𝒞 D 𝒟
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.iso.hom.{(max u₁ v₁) (max v₁ u₁)}
                (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
                (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.equivalence.unit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             x))
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   x)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   x)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             x)
          (@category_theory.category_struct.id.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      x))))
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.iso.hom.{(max u₂ v₂) (max v₂ u₂)}
                (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
                (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.counit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x))))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
x : C
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.iso.hom.{(max u₁ v₁) (max v₁ u₁)}
                (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
                (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
                (@category_theory.functor.id.{v₁ u₁} C 𝒞)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.equivalence.unit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             x))
       (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
          (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.iso.hom.{(max u₂ v₂) (max v₂ u₂)}
             (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
             (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.equivalence.counit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             x)))
    (@category_theory.category_struct.id.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    by { ext, dsimp, simp only [id_comp], exact e.unit_inverse_comp _, }⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The other triangle equality. The proof follows the following proof in Globular:
 http://globular.science/1905.001'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
⊢ auto_param.{0}
    (@eq.{(max u₂ v₁)+1}
       (@category_theory.has_hom.hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category_struct.to_has_hom.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
       (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
             (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.iso.inv.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
                (@category_theory.functor.associator.{u₂ v₂ u₁ v₁ u₂ v₂ u₁ v₁} D 𝒟 C 𝒞 D 𝒟 C
                   𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))))
       (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          x))
    (@category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
       (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
          (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
          (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞))
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
          (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.whisker_left.{u₂ v₂ u₁ v₁ u₁ v₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.unit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.category_struct.comp.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
             (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
             (@category_theory.category.to_category_struct.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞))
             (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.iso.inv.{(max u₂ v₁) (max v₂ v₁ u₂ u₁)}
                (@category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.category.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞)
                (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
                (@category_theory.functor.associator.{u₂ v₂ u₁ v₁ u₂ v₂ u₁ v₁} D 𝒟 C 𝒞 D 𝒟 C
                   𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)))
             (@category_theory.whisker_right.{u₂ v₂ u₂ v₂ u₁ v₁} D 𝒟 D 𝒟 C 𝒞
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.counit.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))))
       x)
    (@category_theory.nat_trans.app.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
       (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.id.{v₁ u₁} C 𝒞))
       (@category_theory.functor.comp.{v₂ v₂ v₁ u₂ u₂ u₁} D 𝒟 D 𝒟 C 𝒞
          (@category_theory.functor.id.{v₂ u₂} D 𝒟)
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
       (@category_theory.nat_trans.id.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.functor.comp.{v₂ v₁ v₁ u₂ u₁ u₁} D 𝒟 C 𝒞 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.iso.hom.{(max u₁ v₁) (max v₁ u₁)}
             (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
             (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.unit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             x))
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   x)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   x)))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             x)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      x))))
          (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   x))
             x
             (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.iso.hom.{(max u₂ v₂) (max v₂ u₂)}
                   (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
                   (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
                   (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                      (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                      (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                   (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                   (@category_theory.equivalence.counit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                x))))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
x : D
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x)))
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞
          (@category_theory.functor.id.{v₁ u₁} C 𝒞)
          (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.iso.hom.{(max u₁ v₁) (max v₁ u₁)}
             (@category_theory.functor.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
             (@category_theory.functor.category.{v₁ v₁ u₁ u₁} C 𝒞 C 𝒞)
             (@category_theory.functor.id.{v₁ u₁} C 𝒞)
             (@category_theory.functor.comp.{v₁ v₂ v₁ u₁ u₂ u₁} C 𝒞 D 𝒟 C 𝒞
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.equivalence.unit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
          (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
             (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             x))
       (@category_theory.functor.map.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
             (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                x))
          x
          (@category_theory.nat_trans.app.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟
             (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             (@category_theory.functor.id.{v₂ u₂} D 𝒟)
             (@category_theory.iso.hom.{(max u₂ v₂) (max v₂ u₂)}
                (@category_theory.functor.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
                (@category_theory.functor.category.{v₂ v₂ u₂ u₂} D 𝒟 D 𝒟)
                (@category_theory.functor.comp.{v₂ v₁ v₂ u₂ u₁ u₂} D 𝒟 C 𝒞 D 𝒟
                   (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
                   (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
                (@category_theory.functor.id.{v₂ u₂} D 𝒟)
                (@category_theory.equivalence.counit_iso.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e))
             x)))
    (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@category_theory.functor.obj.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞
          (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  end equivalence</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  def adjunction (E : C ⥤ D) [is_equivalence E] : E ⊣ E.inv :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞 → Type (max u₁ u₂ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.functor.{v₂ v₁ u₂ u₁} D 𝒟 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor that is part of a (half) adjoint equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`F ⊣ G` represents the data of an adjunction between two functors
`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  (E.as_equivalence).to_adjunction</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.as_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.equivalence.to_adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 289, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.is_equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F], @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (e : @category_theory.equivalence.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟), @category_theory.adjunction.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 (@category_theory.equivalence.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e) (@category_theory.equivalence.inverse.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  end category_theory</code></pre>
</body>