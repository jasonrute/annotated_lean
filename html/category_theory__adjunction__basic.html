<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Reid Barton. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Reid Barton, Johan Commelin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.equivalence</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import data.equiv.basic</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  open category</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  local attribute [elab_simple] whisker_left whisker_right</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='instructs elaborator that the arguments of the function application (f ...) should be elaborated from left to right, and without propagating information from the expected type to its arguments'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  variables {C : Type uâ‚} [ğ’ : category.{vâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category.{vâ‚‚} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{vâ‚ uâ‚} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='category_theory.category.{vâ‚‚ uâ‚‚} D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  include ğ’ ğ’Ÿ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  `F âŠ£ G` represents the data of an adjunction between two functors</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  `F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  structure adjunction (F : C â¥¤ D) (G : D â¥¤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  (hom_equiv : Î  (X Y), (F.obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G.obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type vâ‚‚ â†’ Type vâ‚ â†’ Type (max (max vâ‚‚ vâ‚) vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`Î± â‰ƒ Î²` is the type of functions from `Î± â†’ Î²` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  (unit : ğŸ­ C âŸ¶ F.comp G)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj], obj â†’ obj â†’ Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚} [â„° : category_theory.category.{vâ‚ uâ‚} E], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  (counit : G.comp F âŸ¶ ğŸ­ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚‚} [â„° : category_theory.category.{vâ‚‚ uâ‚‚} E], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚‚ uâ‚‚)} [c : category_theory.has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} obj], obj â†’ obj â†’ Type (max uâ‚‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C], @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  (hom_equiv_unit&#x27; : Î  {X Y f}, (hom_equiv X Y) f = (unit : _ âŸ¶ _).app X â‰« G.map f . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj], obj â†’ obj â†’ Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  (hom_equiv_counit&#x27; : Î  {X Y g}, (hom_equiv X Y).symm g = F.map g â‰« counit.app Y . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  infix ` âŠ£ `:15 := adjunction</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  class is_left_adjoint (left : C â¥¤ D) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  (right : D â¥¤ C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  (adj : left âŠ£ right)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  class is_right_adjoint (right : D â¥¤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  (left : C â¥¤ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  (adj : left âŠ£ right)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  def left_adjoint (R : D â¥¤ C) [is_right_adjoint R] : C â¥¤ D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_right_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  is_right_adjoint.left R</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.is_right_adjoint.left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='R'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 36, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (right : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) [c : @category_theory.is_right_adjoint.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ right], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  def right_adjoint (L : C â¥¤ D) [is_left_adjoint L] : D â¥¤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_left_adjoint'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  is_left_adjoint.right L</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.is_left_adjoint.right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='L'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (left : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) [c : @category_theory.is_left_adjoint.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ left], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  namespace adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  restate_axiom hom_equiv_unit&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  restate_axiom hom_equiv_counit&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  attribute [simp, priority 10] hom_equiv_unit hom_equiv_counit</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y}, @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y) f) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) X) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X : C} {Y : D} {g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)}, @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y)) g) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) g) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  variables {F : C â¥¤ D} {G : D â¥¤ C} (adj : F âŠ£ G) {X&#x27; X : C} {Y Y&#x27; : D}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  @[simp, priority 10] lemma hom_equiv_naturality_left_symm (f : X&#x27; âŸ¶ X) (g : X âŸ¶ G.obj Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                               </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56    (adj.hom_equiv X&#x27; Y).symm (f â‰« g) = F.map f â‰« (adj.hom_equiv X Y).symm g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  by rw [hom_equiv_counit, F.map_comp, assoc, adj.hom_equiv_counit.symm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X : C} {Y : D} {g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)}, @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y)) g) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) g) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) f g)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) Y Z), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) g) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) Y)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             f
             g))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             g))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             g)
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  @[simp] lemma hom_equiv_naturality_left (f : X&#x27; âŸ¶ X) (g : F.obj X âŸ¶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    (adj.hom_equiv X&#x27; Y) (F.map f â‰« g) = f â‰« (adj.hom_equiv X Y) g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  by rw [â† equiv.eq_symm_apply]; simp [-hom_equiv_unit]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± y (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) (@eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       g)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  @[simp, priority 10] lemma hom_equiv_naturality_right (f : F.obj X âŸ¶ Y) (g : Y âŸ¶ Y&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    (adj.hom_equiv X Y&#x27;) (f â‰« g) = (adj.hom_equiv X Y) f â‰« G.map g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  by rw [hom_equiv_unit, G.map_comp, â† assoc, â†hom_equiv_unit]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.adjunction.hom_equiv_unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y}, @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y) f) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) X) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y&#x27; (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y Y&#x27; f g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y f) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X : C} {Y : D} {f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y}, @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y) f) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) X) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          X)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y&#x27;
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             Y&#x27;
             f
             g)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          X)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             f)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          f)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  @[simp] lemma hom_equiv_naturality_right_symm (f : X âŸ¶ G.obj Y) (g : Y âŸ¶ Y&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    (adj.hom_equiv X Y&#x27;).symm (f â‰« G.map g) = (adj.hom_equiv X Y).symm f â‰« g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  by rw [equiv.symm_apply_eq]; simp [-hom_equiv_counit]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x) y) (@eq.{vâ‚+1} Î² x (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       f
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
             f)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  @[simp] lemma left_triangle :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (whisker_right adj.unit F) â‰« (whisker_left F adj.counit) = nat_trans.id _ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type (max uâ‚ vâ‚‚)}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ @eq.{(max uâ‚ vâ‚‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
       (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
       (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)))
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)))
    (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
       (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
       (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          F)
       (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)))
    (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ @eq.{(max uâ‚ vâ‚‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
       (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
       (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)))
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)))
    (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
       (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
       (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          F)
       (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)))
    (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          x))
    (@category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             F)
          (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)))
       x)
    (@category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          F)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             x))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    erw [â† adj.hom_equiv_counit, equiv.symm_apply_eq, adj.hom_equiv_unit],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj x (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) x)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) x)) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x) y) (@eq.{vâ‚+1} Î² x (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj x (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) x (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) x) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x) (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             x))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             x
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             x
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             x
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj x
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          x))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       x
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
       (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
       x)
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             x
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             x
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj x
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
       (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       x
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
       (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
       x)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       x
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          x)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : C
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       x
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)))
    (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
       (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
       x)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       x
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          x)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  @[simp] lemma right_triangle :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80    (whisker_left G adj.unit) â‰« (whisker_right adj.counit G) = nat_trans.id _ :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type (max uâ‚‚ vâ‚)}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                             </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ @eq.{(max uâ‚‚ vâ‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
       (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
       (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          G))
    (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
       (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
       (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          G)
       (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj))
       (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          G))
    (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82    ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ @eq.{(max uâ‚‚ vâ‚)+1}
    (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
       (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
       (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          G))
    (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
       (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
       (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          G)
       (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj))
       (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          G))
    (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          x))
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          G)
       (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj))
          (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             G))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          G)
       (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
          x
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             x)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    erw [â† adj.hom_equiv_unit, â† equiv.eq_symm_apply, adj.hom_equiv_counit],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) x) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) x)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± y (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) (@eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) x)) (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)) x (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x) (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
          x
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             x)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
             x)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
             x)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))
       (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
          x)
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          x))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
       x)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
             x))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
             x))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
             x)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
          (@category_theory.adjunction.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
             x))
       (@category_theory.category_struct.id.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
       x)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       x
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84    simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
x : D
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
       x)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x))
       x
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G x)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  @[simp, reassoc] lemma left_triangle_components :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88    F.map (adj.unit.app X) â‰« adj.counit.app (F.obj X) = ğŸ™ (F.obj X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  congr_arg (Î» (t : nat_trans _ (ğŸ­ C â‹™ F)), t.app X) adj.left_triangle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.left_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type (max uâ‚ vâ‚‚)} {Î² : Type vâ‚‚} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), @eq.{(max uâ‚ vâ‚‚)+1} Î± aâ‚ aâ‚‚ â†’ @eq.{vâ‚‚+1} Î² (f aâ‚) (f aâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚‚} [â„° : category_theory.category.{vâ‚‚ uâ‚‚} E], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G), @eq.{(max uâ‚ vâ‚‚)+1} (@category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))) (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) F) (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj))) (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `Î±.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  @[simp, reassoc] lemma right_triangle_components {Y : D} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                      </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    adj.unit.app (G.obj Y) â‰« G.map (adj.counit.app Y) = ğŸ™ (G.obj Y) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  congr_arg (Î» (t : nat_trans _ (G â‹™ ğŸ­ C)), t.app Y) adj.right_triangle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.right_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 79, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type (max uâ‚‚ vâ‚)} {Î² : Type vâ‚} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), @eq.{(max uâ‚‚ vâ‚)+1} Î± aâ‚ aâ‚‚ â†’ @eq.{vâ‚+1} Î² (f aâ‚) (f aâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚} [â„° : category_theory.category.{vâ‚ uâ‚} E], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.nat_trans.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (adj : @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G), @eq.{(max uâ‚‚ vâ‚)+1} (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) G)) (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) G) (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)) (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) G)) (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `Î±.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  @[simp, reassoc] lemma counit_naturality {X Y : D} (f : X âŸ¶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96    F.map (G.map f) â‰« (adj.counit).app Y = (adj.counit).app X â‰« f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  adj.counit.naturality f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ} (c : @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) â¦ƒX Y : Câ¦„ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C ğ’)) X Y), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G Y)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G Y) (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c Y)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G Y) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X) (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  @[simp, reassoc] lemma unit_naturality {X Y : C} (f : X âŸ¶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='create a companion lemma for associativity-aware rewriting'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100    (adj.unit).app X â‰« G.map (F.map f) = f â‰« (adj.unit).app Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  (adj.unit.naturality f).symm</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 198, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ} (c : @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G) â¦ƒX Y : Câ¦„ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G Y) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X Y f) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G c Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G c X) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ {Î± : Type vâ‚} {a b : Î±}, @eq.{vâ‚+1} Î± a b â†’ @eq.{vâ‚+1} Î± b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  end adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  namespace adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  structure core_hom_equiv (F : C â¥¤ D) (G : D â¥¤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  (hom_equiv : Î  (X Y), (F.obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G.obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type vâ‚‚ â†’ Type vâ‚ â†’ Type (max (max vâ‚‚ vâ‚) vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`Î± â‰ƒ Î²` is the type of functions from `Î± â†’ Î²` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  (hom_equiv_naturality_left_symm&#x27; : Î  {X&#x27; X Y} (f : X&#x27; âŸ¶ X) (g : X âŸ¶ G.obj Y),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    (hom_equiv X&#x27; Y).symm (f â‰« g) = F.map f â‰« (hom_equiv X Y).symm g . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  (hom_equiv_naturality_right&#x27; : Î  {X Y Y&#x27;} (f : F.obj X âŸ¶ Y) (g : Y âŸ¶ Y&#x27;),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    (hom_equiv X Y&#x27;) (f â‰« g) = (hom_equiv X Y) f â‰« G.map g . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  namespace core_hom_equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  restate_axiom hom_equiv_naturality_left_symm&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  restate_axiom hom_equiv_naturality_right&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  attribute [simp, priority 10] hom_equiv_naturality_left_symm hom_equiv_naturality_right</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_left_symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv_naturality_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X&#x27; Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) f g)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G) {X : C} {Y Y&#x27; : D} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y Y&#x27; f g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c X Y) f) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  variables {F : C â¥¤ D} {G : D â¥¤ C} (adj : core_hom_equiv F G) {X&#x27; X : C} {Y Y&#x27; : D}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  @[simp] lemma hom_equiv_naturality_left (f : X&#x27; âŸ¶ X) (g : F.obj X âŸ¶ Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125    (adj.hom_equiv X&#x27; Y) (F.map f â‰« g) = f â‰« (adj.hom_equiv X Y) g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  by rw [â† equiv.eq_symm_apply]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± y (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) (@eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       g)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  @[simp] lemma hom_equiv_naturality_right_symm (f : X âŸ¶ G.obj Y) (g : Y âŸ¶ Y&#x27;) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129    (adj.hom_equiv X Y&#x27;).symm (f â‰« G.map g) = (adj.hom_equiv X Y).symm f â‰« g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  by rw [equiv.symm_apply_eq]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x) y) (@eq.{vâ‚+1} Î² x (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       f
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
             f)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  end core_hom_equiv</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  structure core_unit_counit (F : C â¥¤ D) (G : D â¥¤ C) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  (unit : ğŸ­ C âŸ¶ F.comp G)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj], obj â†’ obj â†’ Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚} [â„° : category_theory.category.{vâ‚ uâ‚} E], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  (counit : G.comp F âŸ¶ ğŸ­ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚‚} [â„° : category_theory.category.{vâ‚‚ uâ‚‚} E], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚‚ uâ‚‚)} [c : category_theory.has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} obj], obj â†’ obj â†’ Type (max uâ‚‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C], @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  (left_triangle&#x27; : whisker_right unit F â‰« (functor.associator F G F).hom â‰« whisker_left F counit = nat_trans.id (ğŸ­ C â‹™ F) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {A : Type uâ‚} [ğ’œ : category_theory.category.{vâ‚ uâ‚} A] {B : Type uâ‚‚} [â„¬ : category_theory.category.{vâ‚‚ uâ‚‚} B] {C : Type uâ‚ƒ} [ğ’ : category_theory.category.{vâ‚ƒ uâ‚ƒ} C] {D : Type uâ‚„} [ğ’Ÿ : category_theory.category.{vâ‚„ uâ‚„} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} A ğ’œ B â„¬) (G : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} B â„¬ C ğ’) (H : @category_theory.functor.{vâ‚ƒ vâ‚„ uâ‚ƒ uâ‚„} C ğ’ D ğ’Ÿ), @category_theory.iso.{(max uâ‚ vâ‚„) (max vâ‚ vâ‚„ uâ‚ uâ‚„)} (@category_theory.functor.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.comp.{vâ‚ vâ‚ƒ vâ‚„ uâ‚ uâ‚ƒ uâ‚„} A ğ’œ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} A ğ’œ B â„¬ C ğ’ F G) H) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚„ uâ‚ uâ‚‚ uâ‚„} A ğ’œ B â„¬ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ƒ vâ‚„ uâ‚‚ uâ‚ƒ uâ‚„} B â„¬ C ğ’ D ğ’Ÿ G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} [_inst_1 : category_theory.category.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} C] {X Y : C}, @category_theory.iso.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} C _inst_1 X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} C (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} C (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚‚} [â„° : category_theory.category.{vâ‚‚ uâ‚‚} E], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  (right_triangle&#x27; : whisker_left G unit â‰« (functor.associator G F G).inv â‰« whisker_right counit G = nat_trans.id (G â‹™ ğŸ­ C) . obviously)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='auto_param'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 119, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/name.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {A : Type uâ‚} [ğ’œ : category_theory.category.{vâ‚ uâ‚} A] {B : Type uâ‚‚} [â„¬ : category_theory.category.{vâ‚‚ uâ‚‚} B] {C : Type uâ‚ƒ} [ğ’ : category_theory.category.{vâ‚ƒ uâ‚ƒ} C] {D : Type uâ‚„} [ğ’Ÿ : category_theory.category.{vâ‚„ uâ‚„} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} A ğ’œ B â„¬) (G : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} B â„¬ C ğ’) (H : @category_theory.functor.{vâ‚ƒ vâ‚„ uâ‚ƒ uâ‚„} C ğ’ D ğ’Ÿ), @category_theory.iso.{(max uâ‚ vâ‚„) (max vâ‚ vâ‚„ uâ‚ uâ‚„)} (@category_theory.functor.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.comp.{vâ‚ vâ‚ƒ vâ‚„ uâ‚ uâ‚ƒ uâ‚„} A ğ’œ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} A ğ’œ B â„¬ C ğ’ F G) H) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚„ uâ‚ uâ‚‚ uâ‚„} A ğ’œ B â„¬ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ƒ vâ‚„ uâ‚‚ uâ‚ƒ uâ‚„} B â„¬ C ğ’ D ğ’Ÿ G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} [_inst_1 : category_theory.category.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} C] {X Y : C}, @category_theory.iso.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} C _inst_1 X Y â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} C (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} C (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop â†’ name â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚} [â„° : category_theory.category.{vâ‚ uâ‚} E], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `punit.{0}`, its most common instantiation.
   This type should be preferred over `punit` where possible to avoid
   unnecessary universe parameters.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='orange'><a title='Gadget for automatic parameter support. This is similar to the opt_param gadget, but it uses
   the tactic declaration names tac_name to synthesize the argument.
   Like opt_param, this gadget only affects elaboration.
   For example, the tactic will *not* be invoked during type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`nat_trans.id F` is the identity natural transformation on a functor `F`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  namespace core_unit_counit</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142  restate_axiom left_triangle&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  restate_axiom right_triangle&#x27;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  attribute [simp] left_triangle right_triangle</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.left_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.right_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G), @eq.{(max uâ‚ vâ‚‚)+1} (@category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))) (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) F) (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.iso.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)) (@category_theory.functor.associator.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ C ğ’ D ğ’Ÿ F G F)) (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c)))) (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) F))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} (c : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G), @eq.{(max uâ‚‚ vâ‚)+1} (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) G)) (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) G) (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c)) (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) G) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) G) (@category_theory.iso.inv.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)} (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’) (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) G) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)) (@category_theory.functor.associator.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ D ğ’Ÿ C ğ’ G F G)) (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G c) G))) (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146  end core_unit_counit</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  variables {F : C â¥¤ D} {G : D â¥¤ C}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  def mk_of_hom_equiv (adj : core_hom_equiv F G) : F âŠ£ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  { unit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152    { app := Î» X, (adj.hom_equiv X (F.obj X)) (ğŸ™ (F.obj X)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153      naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ âˆ€ â¦ƒX Y : Câ¦„
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            Y))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            Y)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            Y)
         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X
            Y
            f)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  Y
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  Y
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj Y
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
            (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            Y)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
            (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155        intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ âˆ€ â¦ƒX Y : Câ¦„
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            Y))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            Y)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            Y)
         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X
            Y
            f)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  Y
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  Y
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj Y
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
            (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            X)
         (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            Y)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
            (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
         (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
            (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          Y)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X
          Y
          f)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                Y
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                Y
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj Y
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156        erw [â† adj.hom_equiv_naturality_left, â† adj.hom_equiv_naturality_right],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y)) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y) f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y) f g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) f) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          Y)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X
          Y
          f)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                Y
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                Y
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj Y
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                Y)
             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X
                Y
                f))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                Y)
             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X
                Y
                f))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157        dsimp, simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                Y)
             (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X
                Y
                f))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                   (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                   X))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159    counit :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    { app := Î» Y, (adj.hom_equiv _ _).inv_fun (ğŸ™ (G.obj Y)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_hom_equiv.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='equiv.inv_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;line&#x27;: 109, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ Î² â†’ Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161      naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ âˆ€ â¦ƒX Y : Dâ¦„
  (f :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      X
      Y),
    @eq.{vâ‚‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            Y))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            Y)
         (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X
            Y
            f)
         (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  Y))
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     Y)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  Y))
            (@category_theory.category_struct.id.{vâ‚ uâ‚} C
               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            Y)
         (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  X))
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  X))
            (@category_theory.category_struct.id.{vâ‚ uâ‚} C
               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
         (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163        intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
âŠ¢ âˆ€ â¦ƒX Y : Dâ¦„
  (f :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      X
      Y),
    @eq.{vâ‚‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            Y))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            Y)
         (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X
            Y
            f)
         (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  Y))
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     Y)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  Y))
            (@category_theory.category_struct.id.{vâ‚ uâ‚} C
               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            X)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            Y)
         (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  X))
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                     (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     X)))
            (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                  (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                  X))
            (@category_theory.category_struct.id.{vâ‚ uâ‚} C
               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
         (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X
          Y
          f)
       (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y)
       (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164        erw [â† adj.hom_equiv_naturality_left_symm, â† adj.hom_equiv_naturality_right_symm],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) f g)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) f) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y))) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) f (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y) g))) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X))) f) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y)
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X
          Y
          f)
       (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y)
       (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y)
       (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   X)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)
             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X
                Y
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165        dsimp, simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   Y)))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                Y)
             (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                X
                Y
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    X
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
             Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167    hom_equiv_unit&#x27; := Î» X Y f, by erw [â† adj.hom_equiv_naturality_right]; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y f g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) f) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
       f)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.nat_trans.mk.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (Î» (X : C),
                @coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                  (equiv.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        X
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        X
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                  (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
             (Î» (X Y : C)
              (f :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           Y)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y)
                        (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X
                           Y
                           f)
                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                           (equiv.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 Y
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 Y
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              Y
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y)
                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                           (equiv.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              X
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                        (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X
                           Y
                           f)))
                  (@eq.{vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y))
                     (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                        (equiv.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    X))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                        (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    X))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                        (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                           adj
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                        (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 Y))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                           (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 Y)
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X
                                 Y
                                 f))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y)
                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                           (equiv.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              X
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                        (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 Y)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y)
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X
                                 Y
                                 f)
                              (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                 (equiv.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       Y
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                 (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       Y
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    Y
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                 (equiv.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X
                                 Y
                                 f)))
                        (@eq.{vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y))
                           (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                              (equiv.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                 (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y)
                                    (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X
                                       Y
                                       f))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                 (equiv.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))
                        (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X
                              Y
                              f)
                           (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                              (equiv.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          Y))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          Y))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    Y)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                        (Î»
                         (_a :
                           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))),
                           @eq.{1} Prop
                             (@eq.{vâ‚+1}
                                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      Y))
                                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      Y)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      Y)
                                   (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X
                                      Y
                                      f)
                                   (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                      (equiv.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            Y
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                      (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            Y
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’
                                         D
                                         ğ’Ÿ
                                         F
                                         G
                                         adj
                                         Y
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                      (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      Y)
                                   (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                      (equiv.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            X
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                      (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            X
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                      (â€¦ â€¦)
                                      â€¦)
                                   â€¦))
                             â€¦)
                        â€¦
                        â€¦
                        â€¦))
                  â€¦))
          X)
       â€¦)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
       f)
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)
       f)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.nat_trans.mk.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (Î» (X : C),
                @coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                  (equiv.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        X
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                  (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        X
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                  (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
             (Î» (X Y : C)
              (f :
                @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           Y)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y)
                        (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X
                           Y
                           f)
                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                           (equiv.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 Y
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 Y
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              Y
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y)
                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                           (equiv.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              X
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                        (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X
                           Y
                           f)))
                  (@eq.{vâ‚+1}
                     (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                        (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y))
                     (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                        (equiv.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    X))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                        (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    X))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                        (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                           adj
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                        (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 Y))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                           (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 Y)
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X
                                 Y
                                 f))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                     (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X)
                        (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           Y)
                        (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                           (equiv.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                              (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                              (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                 (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                 X
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              X
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                           (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                        (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                           (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 Y)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y)
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X
                                 Y
                                 f)
                              (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                 (equiv.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       Y
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                 (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       Y
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    Y
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                 (equiv.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X
                                 Y
                                 f)))
                        (@eq.{vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y))
                           (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                              (equiv.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          X))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    X)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y))
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                 (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y)
                                    (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       X
                                       Y
                                       f))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                           (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X)
                              (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 Y)
                              (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                 (equiv.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                       X
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    X
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                 (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
                              (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                 (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F
                                    G)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 vâ‚+1}
                        (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                           (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)))
                        (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X)
                           (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                           (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                              (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                              X
                              Y
                              f)
                           (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                              (equiv.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          Y))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                          Y))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                       (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                       Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                              (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                                 F
                                 G
                                 adj
                                 (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                    (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                    Y)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                              (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                        (Î»
                         (_a :
                           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
                             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                X)
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))),
                           @eq.{1} Prop
                             (@eq.{vâ‚+1}
                                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      Y))
                                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      Y)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      Y)
                                   (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X
                                      Y
                                      f)
                                   (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                      (equiv.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            Y
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                      (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            Y
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’
                                         D
                                         ğ’Ÿ
                                         F
                                         G
                                         adj
                                         Y
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))
                                      (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y))))
                                (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                                      (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C
                                         ğ’
                                         F
                                         G)
                                      Y)
                                   (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                                      (equiv.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            X
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                      (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                                         (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                               (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                                            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
                                         (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                            (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                               (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                            X
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))))
                                      (â€¦ â€¦)
                                      â€¦)
                                   â€¦))
                             â€¦)
                        â€¦
                        â€¦
                        â€¦))
                  â€¦))
          X)
       â€¦)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168    hom_equiv_counit&#x27; := Î» X Y f, by erw [â† adj.hom_equiv_naturality_left_symm]; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) f g)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) f) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) Y)) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
       f)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f)
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (Î» (Y : D),
                @equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        Y))
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        Y))
                  (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
             (Î» (X Y : D)
              (f :
                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y))
                     (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)
                        (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X
                           Y
                           f)
                        (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                     (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)
                        (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                        (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X
                           Y
                           f)))
                  (@eq.{vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y))
                     (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                        (equiv.{vâ‚+1 vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)))
                        (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)))
                        (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)))
                        (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                     (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)
                        (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                        (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 Y)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)
                              (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X
                                 Y
                                 f)
                              (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                           (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)
                              (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                              (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X
                                 Y
                                 f)))
                        (@eq.{vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                              (equiv.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                           (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)
                              (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                              (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 vâ‚‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                              (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              Y))
                        (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                              (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              Y)
                           (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                              (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f))
                           (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                              (equiv.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                        (Î»
                         (_a :
                           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                Y)),
                           @eq.{1} Prop
                             (@eq.{vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      Y))
                                (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      Y)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      Y)
                                   (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X
                                      Y
                                      f)
                                   (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            Y))
                                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                               (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                               Y)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’
                                         D
                                         ğ’Ÿ
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            Y))
                                      (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                                (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      Y)
                                   (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            X))
                                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                               (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                               X)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’
                                         D
                                         ğ’Ÿ
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            X))
                                      (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                                   â€¦))
                             â€¦)
                        â€¦
                        â€¦
                        â€¦))
                  â€¦))
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
       f)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj X Y))
       f)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f)
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.nat_trans.mk.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (Î» (Y : D),
                @equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                  (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                     (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        Y))
                  (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                     (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                        (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)))
                  (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                        (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        Y))
                  (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                     (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
             (Î» (X Y : D)
              (f :
                @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  X
                  Y),
                @eq.mpr.{0}
                  (@eq.{vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y))
                     (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           Y)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)
                        (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X
                           Y
                           f)
                        (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                     (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)
                        (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                        (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X
                           Y
                           f)))
                  (@eq.{vâ‚‚+1}
                     (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y))
                     (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                        (equiv.{vâ‚+1 vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)))
                        (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)))
                        (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    Y)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)))
                        (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                           (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                     (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                        (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X)
                        (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           Y)
                        (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                              (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                    (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                    X)))
                           (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G
                              adj
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X))
                           (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                              (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                        (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                           (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           X
                           Y
                           f)))
                  (@id.{0}
                     (@eq.{1} Prop
                        (@eq.{vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 Y)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)
                              (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X
                                 Y
                                 f)
                              (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                           (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)
                              (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                              (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X
                                 Y
                                 f)))
                        (@eq.{vâ‚‚+1}
                           (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                 (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y))
                           (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                              (equiv.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f)
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                           (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G
                                    F)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 Y)
                              (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          X)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       X))
                                 (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                    (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                              (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                 (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                 X
                                 Y
                                 f))))
                     (@eq.rec.{0 vâ‚‚+1}
                        (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                              (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                              (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              Y))
                        (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                           (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                           (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                           (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                              (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                              Y)
                           (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                              (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                              (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X Y f))
                           (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                              (equiv.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                                 (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y))
                                 (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                          Y)))
                                 (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D
                                    ğ’Ÿ
                                    F
                                    G
                                    adj
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                    (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                       (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                       Y)))
                              (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                 (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                 (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                        (Î»
                         (_a :
                           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                             (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                Y)),
                           @eq.{1} Prop
                             (@eq.{vâ‚‚+1}
                                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      Y))
                                (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      Y)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      Y)
                                   (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X
                                      Y
                                      f)
                                   (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            Y))
                                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                               (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                               Y)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’
                                         D
                                         ğ’Ÿ
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            Y))
                                      (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))))
                                (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D
                                         ğ’Ÿ
                                         G
                                         F)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      X)
                                   (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                      (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                      Y)
                                   (@equiv.inv_fun.{vâ‚‚+1 vâ‚+1}
                                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            X))
                                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                                            (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                               (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                               X)))
                                      (@category_theory.adjunction.core_hom_equiv.hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’
                                         D
                                         ğ’Ÿ
                                         F
                                         G
                                         adj
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                                            (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                                            X))
                                      (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G X)))
                                   â€¦))
                             â€¦)
                        â€¦
                        â€¦
                        â€¦))
                  â€¦))
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    .. adj }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171  def mk_of_unit_counit (adj : core_unit_counit F G) : F âŠ£ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.adjunction.core_unit_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172  { hom_equiv := Î» X Y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    { to_fun := Î» f, adj.unit.app X â‰« G.map f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174      inv_fun := Î» g, F.map g â‰« adj.counit.app Y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.core_unit_counit.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 134, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175      left_inv := Î» f, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    ((Î»
      (g :
        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
        @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             g)
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y))
       ((Î»
         (f :
           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y),
           @category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X)
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y
                f))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176        change F.map (_ â‰« _) â‰« _ = _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    ((Î»
      (g :
        @category_theory.has_hom.hom.{vâ‚ uâ‚} C
          (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
        @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             g)
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y))
       ((Î»
         (f :
           @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y),
           @category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X)
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y
                f))
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X)
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y
                f)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177        rw [F.map_comp, assoc, â†functor.comp_map, adj.counit.naturality, â†assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.comp_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X)) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) f g)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X) f) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) Y Z), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D] {E : Type uâ‚‚} [â„° : category_theory.category.{vâ‚‚ uâ‚‚} E] (F : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ) (G : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ E â„°) (X Y : C) (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C ğ’)) X Y), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} E (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} E (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} E â„°)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ E â„° (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ E â„° F G) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ E â„° (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ E â„° F G) Y)) (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ E â„° (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ E â„° F G) X Y f) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ E â„° G (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ â¦ƒX Y : Dâ¦„ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) X Y), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y) (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) X Y f) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) Y)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X) (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) Y) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) X) (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) Y Z), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X)
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y
                f)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       Y
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y
                f)))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          Y))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y
                f))
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             f)
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             Y)
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             f)))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       Y
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X))
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178        convert id_comp _ f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) â†’ @interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X X Y (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) â†’ @interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : â„•`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : â„•`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;â†&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;â†&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       Y
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                X)
             (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                X))
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          f))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179        have t := congr_arg (Î» t : nat_trans _ _, t.app _) adj.left_triangle,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type (max uâ‚ vâ‚‚)} {Î² : Type vâ‚‚} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), @eq.{(max uâ‚ vâ‚‚)+1} Î± aâ‚ aâ‚‚ â†’ @eq.{vâ‚‚+1} Î² (f aâ‚) (f aâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F G : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `Î±.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
t :
  @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          ?m_1))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))),
        @category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             F)
          (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                F)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F))
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.iso.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                   F)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F))
                (@category_theory.functor.associator.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ C ğ’ D
                   ğ’Ÿ
                   F
                   G
                   F))
             (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)))))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))),
        @category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          t
          ?m_1)
       (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)))
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180        dsimp at t,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
t :
  @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          ?m_1))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))),
        @category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             F)
          (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                F)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F))
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.iso.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
                   F)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F))
                (@category_theory.functor.associator.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ C ğ’ D
                   ğ’Ÿ
                   F
                   G
                   F))
             (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)))))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))),
        @category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ F
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          t
          ?m_1)
       (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             F)))
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
t :
  @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             ?m_1))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))))
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181        simp only [id_comp] at t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
t :
  @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             ?m_1))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))))
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
t :
  @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             ?m_1))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182        exact t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) X)) (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))) (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
t :
  @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             ?m_1))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ?m_1))
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y
âŠ¢ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183      end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184      right_inv := Î» g, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    ((Î»
      (f :
        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y),
        @category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             f))
       ((Î»
         (g :
           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
           @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                g)
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185        change _ â‰« G.map (_ â‰« _) = _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 249, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`change u` replaces the target `t` of the main goal to `u` provided that `t` is well formed with respect to the local context of the main goal and `t` and `u` are definitionally equal.

`change u at h` will change a local hypothesis to `u`.

`change t with u at h1 h2 ...` will replace `t` with `u` in all the supplied hypotheses (or `*`), or in the goal if no `at` clause is specified, provided that `t` and `u` are definitionally equal.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='change'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with expr)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    ((Î»
      (f :
        @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y),
        @category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y
             f))
       ((Î»
         (g :
           @category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
           @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                g)
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))
          g))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          X)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                g)
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186        rw [G.map_comp, â†assoc, â†functor.comp_map, â†adj.unit.naturality, assoc],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.comp_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 81, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y f g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) f) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚} [â„° : category_theory.category.{vâ‚ uâ‚} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ E â„°) (X Y : C) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} E (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} E (@category_theory.category.to_category_struct.{vâ‚ uâ‚} E â„°)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ E â„° (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ E â„° F G) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ E â„° (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ E â„° F G) Y)) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ E â„° (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ E â„° F G) X Y f) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ E â„° G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F Y) (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ â¦ƒX Y : Câ¦„ (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) Y) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) Y) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X Y f) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X) (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) X) (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          X)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                g)
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          X)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                g))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X)
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
                g)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             X)
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             g))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             g)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          g)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187        convert comp_id _ g,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) â†’ @interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Y f (@category_theory.category_struct.id.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) â†’ @interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : â„•`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : â„•`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;â†&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;â†&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.map.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          g)
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             Y
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                Y))))
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188        have t := congr_arg (Î» t : nat_trans _ _, t.app _) adj.right_triangle,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.nat_trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type (max uâ‚‚ vâ‚)} {Î² : Type vâ‚} {aâ‚ aâ‚‚ : Î±} (f : Î± â†’ Î²), @eq.{(max uâ‚‚ vâ‚)+1} Î± aâ‚ aâ‚‚ â†’ @eq.{vâ‚+1} Î² (f aâ‚) (f aâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`nat_trans F G` represents a natural transformation between functors `F` and `G`.

The field `app` provides the components of the natural transformation.

Naturality is expressed by `Î±.naturality_lemma`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
t :
  @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          ?m_1))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)),
        @category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj))
          (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                G)
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                G)
             (@category_theory.iso.inv.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                   G)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
                (@category_theory.functor.associator.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ D ğ’Ÿ C
                   ğ’
                   G
                   F
                   G))
             (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                G))))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)),
        @category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          t
          ?m_1)
       (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))))
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189        dsimp at t,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
t :
  @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          ?m_1))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)),
        @category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          t
          ?m_1)
       (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
             (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj))
          (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                G)
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                G)
             (@category_theory.iso.inv.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                   G)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G))
                (@category_theory.functor.associator.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ D ğ’Ÿ C
                   ğ’
                   G
                   F
                   G))
             (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                G))))
    ((Î»
      (t :
        @category_theory.nat_trans.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)),
        @category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             G)
          t
          ?m_1)
       (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’ G
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))))
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
t :
  @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
             ?m_1
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                ?m_1))))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190        simp only [id_comp] at t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
t :
  @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
             ?m_1
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
                ?m_1))))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
t :
  @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
          ?m_1
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             ?m_1)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191        exact t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’ (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G) (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) Y (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj) Y))) (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
t :
  @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
          ?m_1
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             ?m_1)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ?m_1))
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)
          (@category_theory.adjunction.core_unit_counit.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          Y
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.adjunction.core_unit_counit.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G adj)
             Y)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
adj : @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G,
X : C,
Y : D,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    end },</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193    .. adj }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='adj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>196  omit ğ’Ÿ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>197  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>198  def id : ğŸ­ C âŠ£ ğŸ­ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚} [ğ’Ÿ : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ vâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [ğ’ : category_theory.category.{vâ‚ uâ‚} C], @category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`ğŸ­ C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>199  { hom_equiv := Î» X Y, equiv.refl _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 56, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (Î± : Sort u_1), equiv.{u_1 u_1} Î± Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>200    unit := ğŸ™ _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj] (X : obj), @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>201    counit := ğŸ™ _ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj] (X : obj), @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>202  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>203  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>204  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>205  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>206  variables {E : Type uâ‚ƒ} [â„° : category.{vâ‚ƒ} E] (H : D â¥¤ E) (I : E â¥¤ D)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u â†’ Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚ƒ) [_inst_2 : category_theory.category.{vâ‚ƒ uâ‚ƒ} D], Type (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Î  (C : Type uâ‚ƒ) [_inst_1 : category_theory.category.{vâ‚ƒ uâ‚ƒ} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>207  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>208  def comp (adjâ‚ : F âŠ£ G) (adjâ‚‚ : H âŠ£ I) : F â‹™ H âŠ£ I â‹™ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚ƒ} [ğ’Ÿ : category_theory.category.{vâ‚ƒ uâ‚ƒ} D], @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚‚ uâ‚ƒ vâ‚‚ vâ‚ƒ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} E â„° D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚ƒ} [ğ’Ÿ : category_theory.category.{vâ‚ƒ uâ‚ƒ} D], @category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚ƒ vâ‚ uâ‚ƒ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚ƒ vâ‚ vâ‚ƒ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} E â„° D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚ƒ} [ğ’ : category_theory.category.{vâ‚ƒ uâ‚ƒ} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚} [â„° : category_theory.category.{vâ‚ uâ‚} E], @category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ E â„° â†’ @category_theory.functor.{vâ‚ƒ vâ‚ uâ‚ƒ uâ‚} C ğ’ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`F â‹™ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>209  { hom_equiv := Î» X Z, equiv.trans (adjâ‚‚.hom_equiv _ _) (adjâ‚.hom_equiv _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='adjâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='adjâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 60, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Sort u} {Î² : Sort v} {Î³ : Sort w}, equiv.{u v} Î± Î² â†’ equiv.{v w} Î² Î³ â†’ equiv.{u w} Î± Î³'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.adjunction.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„° H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚ƒ} [ğ’Ÿ : category_theory.category.{vâ‚ƒ uâ‚ƒ} D] {F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚ƒ+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ƒ uâ‚ƒ} D (@category_theory.category_struct.to_has_hom.{vâ‚ƒ uâ‚ƒ} D (@category_theory.category.to_category_struct.{vâ‚ƒ uâ‚ƒ} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>210    unit := adjâ‚.unit â‰«</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='adjâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>211    (whisker_left F $ whisker_right adjâ‚‚.unit G) â‰« (functor.associator _ _ _).inv,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adjâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.iso.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„° H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚ƒ} [ğ’Ÿ : category_theory.category.{vâ‚ƒ uâ‚ƒ} D] {F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} C ğ’) (@category_theory.functor.comp.{vâ‚‚ vâ‚ƒ vâ‚‚ uâ‚‚ uâ‚ƒ uâ‚‚} C ğ’ D ğ’Ÿ C ğ’ F G)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚ uâ‚)} [c : category_theory.category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {A : Type uâ‚} [ğ’œ : category_theory.category.{vâ‚ uâ‚} A] {B : Type uâ‚‚} [â„¬ : category_theory.category.{vâ‚‚ uâ‚‚} B] {C : Type uâ‚ƒ} [ğ’ : category_theory.category.{vâ‚ƒ uâ‚ƒ} C] {D : Type uâ‚„} [ğ’Ÿ : category_theory.category.{vâ‚„ uâ‚„} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} A ğ’œ B â„¬) (G : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} B â„¬ C ğ’) (H : @category_theory.functor.{vâ‚ƒ vâ‚„ uâ‚ƒ uâ‚„} C ğ’ D ğ’Ÿ), @category_theory.iso.{(max uâ‚ vâ‚„) (max vâ‚ vâ‚„ uâ‚ uâ‚„)} (@category_theory.functor.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.comp.{vâ‚ vâ‚ƒ vâ‚„ uâ‚ uâ‚ƒ uâ‚„} A ğ’œ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} A ğ’œ B â„¬ C ğ’ F G) H) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚„ uâ‚ uâ‚‚ uâ‚„} A ğ’œ B â„¬ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ƒ vâ‚„ uâ‚‚ uâ‚ƒ uâ‚„} B â„¬ C ğ’ D ğ’Ÿ G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Î  {C : Type (max vâ‚ uâ‚)} [_inst_1 : category_theory.category.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} C] {X Y : C}, @category_theory.iso.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} C _inst_1 X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} C (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} C (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} C _inst_1)) Y X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>212    counit := (functor.associator _ _ _).hom â‰«</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='category_theory.functor.associator'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.iso.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 133, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='Î  {A : Type uâ‚} [ğ’œ : category_theory.category.{vâ‚ uâ‚} A] {B : Type uâ‚‚} [â„¬ : category_theory.category.{vâ‚‚ uâ‚‚} B] {C : Type uâ‚ƒ} [ğ’ : category_theory.category.{vâ‚ƒ uâ‚ƒ} C] {D : Type uâ‚„} [ğ’Ÿ : category_theory.category.{vâ‚„ uâ‚„} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} A ğ’œ B â„¬) (G : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} B â„¬ C ğ’) (H : @category_theory.functor.{vâ‚ƒ vâ‚„ uâ‚ƒ uâ‚„} C ğ’ D ğ’Ÿ), @category_theory.iso.{(max uâ‚ vâ‚„) (max vâ‚ vâ‚„ uâ‚ uâ‚„)} (@category_theory.functor.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚„ uâ‚ uâ‚„} A ğ’œ D ğ’Ÿ) (@category_theory.functor.comp.{vâ‚ vâ‚ƒ vâ‚„ uâ‚ uâ‚ƒ uâ‚„} A ğ’œ C ğ’ D ğ’Ÿ (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} A ğ’œ B â„¬ C ğ’ F G) H) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚„ uâ‚ uâ‚‚ uâ‚„} A ğ’œ B â„¬ D ğ’Ÿ F (@category_theory.functor.comp.{vâ‚‚ vâ‚ƒ vâ‚„ uâ‚‚ uâ‚ƒ uâ‚„} B â„¬ C ğ’ D ğ’Ÿ G H))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Î  {C : Type (max vâ‚ƒ uâ‚ƒ)} [_inst_1 : category_theory.category.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} C] {X Y : C}, @category_theory.iso.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} C _inst_1 X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} C (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} C (@category_theory.category.to_category_struct.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} C _inst_1)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚ƒ uâ‚ƒ)} [c : category_theory.category_struct.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>213      (whisker_left I $ whisker_right adjâ‚.counit H) â‰« adjâ‚‚.counit }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.whisker_left'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.whisker_right'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adjâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='adjâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 18, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/whiskering.lean&#x27;, &#x27;line&#x27;: 22, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) {G H : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°}, @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚ƒ) (max vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°) (@category_theory.functor.category.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°))) G H â†’ @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F G) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° F H)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} E â„° D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {E : Type uâ‚ƒ} [â„° : category_theory.category.{vâ‚ƒ uâ‚ƒ} E] {G H : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ}, @category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)} (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))) G H â†’ Î  (F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°), @category_theory.has_hom.hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚ƒ) (max vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ)} (@category_theory.functor.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°) (@category_theory.functor.category.{vâ‚ vâ‚ƒ uâ‚ uâ‚ƒ} C ğ’ E â„°))) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° G F) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ƒ uâ‚ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ E â„° H F)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„°'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {obj : Type (max vâ‚ƒ uâ‚ƒ)} [c : category_theory.category_struct.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj c) X Y â†’ @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj c) Y Z â†’ @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.adjunction.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ E â„° H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [ğ’ : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚ƒ} [ğ’Ÿ : category_theory.category.{vâ‚ƒ uâ‚ƒ} D] {F : @category_theory.functor.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚ƒ vâ‚‚ uâ‚ƒ uâ‚‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.{vâ‚‚ vâ‚ƒ uâ‚‚ uâ‚ƒ} C ğ’ D ğ’Ÿ F G â†’ @category_theory.has_hom.hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} (@category_theory.functor.{vâ‚ƒ vâ‚ƒ uâ‚ƒ uâ‚ƒ} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} (@category_theory.functor.{vâ‚ƒ vâ‚ƒ uâ‚ƒ uâ‚ƒ} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚ƒ vâ‚ƒ) (max vâ‚ƒ uâ‚ƒ)} (@category_theory.functor.{vâ‚ƒ vâ‚ƒ uâ‚ƒ uâ‚ƒ} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚ƒ vâ‚ƒ uâ‚ƒ uâ‚ƒ} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚ƒ vâ‚‚ vâ‚ƒ uâ‚ƒ uâ‚‚ uâ‚ƒ} D ğ’Ÿ C ğ’ D ğ’Ÿ G F) (@category_theory.functor.id.{vâ‚ƒ uâ‚ƒ} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>214  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>215  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>216  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>217  section construct_left</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>218  -- Construction of a left adjoint. In order to construct a left</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>219  -- adjoint to a functor G : D â†’ C, it suffices to give the object part</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>220  -- of a functor F : C â†’ D together with isomorphisms Hom(FX, Y) â‰ƒ</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>221  -- Hom(X, GY) natural in Y. The action of F on morphisms can be</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>222  -- constructed from this data.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>223  variables {F_obj : C â†’ D} {G}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>224  variables (e : Î  X Y, (F_obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G.obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type vâ‚‚ â†’ Type vâ‚ â†’ Type (max (max vâ‚‚ vâ‚) vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`Î± â‰ƒ Î²` is the type of functions from `Î± â†’ Î²` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>225  variables (he : Î  X Y Y&#x27; g h, e X Y&#x27; (h â‰« g) = e X Y h â‰« G.map g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>226  include he</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>227  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>228  private lemma he&#x27; {X Y Y&#x27;} (f g) : (e X Y&#x27;).symm (f â‰« G.map g) = (e X Y).symm f â‰« g :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚‚} [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] {D : Type uâ‚} [_inst_2 : category_theory.category.{vâ‚ uâ‚} D] (c : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} C (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} C (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} D (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} D (@category_theory.category.to_category_struct.{vâ‚ uâ‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>229  by intros; rw [equiv.symm_apply_eq, he]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x) y) (@eq.{vâ‚+1} Î² x (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (F_obj X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (e X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (F_obj X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       f
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (F_obj X)
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (e X Y))
             f)
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       f
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
          (e X Y)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                (e X Y))
             f))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (F_obj X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (e X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (F_obj X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>230  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X : C,
Y Y&#x27; : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y),
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (F_obj X)
       Y&#x27;)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
          (e X Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
          f
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (F_obj X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X Y))
          f)
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>231  def left_adjoint_of_equiv : C â¥¤ D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>232  { obj := F_obj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>233    map := Î» X X&#x27; f, (e X (F_obj X&#x27;)).symm (f â‰« e X&#x27; (F_obj X&#x27;) (ğŸ™ _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>234    map_comp&#x27; := Î» X X&#x27; X&#x27;&#x27; f f&#x27;, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (F_obj X)
       (F_obj X&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
          (e X (F_obj X&#x27;&#x27;)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             X&#x27;
             X&#x27;&#x27;
             f
             f&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;&#x27;)))))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (F_obj X)
       (F_obj X&#x27;)
       (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
             (e X (F_obj X&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
             f
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                (e X&#x27; (F_obj X&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;)))))
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>235      rw [equiv.symm_apply_eq, he, equiv.apply_symm_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.apply_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x) y) (@eq.{vâ‚+1} Î² x (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (x : Î²), @eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (F_obj X)
       (F_obj X&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;)))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
          (e X (F_obj X&#x27;&#x27;)))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             X&#x27;
             X&#x27;&#x27;
             f
             f&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;&#x27;)))))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (F_obj X)
       (F_obj X&#x27;)
       (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
             (e X (F_obj X&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
             f
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;)
                      (F_obj X&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                (e X&#x27; (F_obj X&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;)))))
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
       (e X (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (F_obj X)
          (F_obj X&#x27;)
          (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
                (e X (F_obj X&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
                f
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                   (e X&#x27; (F_obj X&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;)))))
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (e X (F_obj X&#x27;))
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   (F_obj X&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;)))
                (e X (F_obj X&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
                f
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;)
                         (F_obj X&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
                   (e X&#x27; (F_obj X&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;))))))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
          f
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
             (e X&#x27; (F_obj X&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;))))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>236      conv { to_rhs, rw [assoc, â†he, id_comp, equiv.apply_symm_apply] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.apply_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) Y Z), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X X Y (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (x : Î²), @eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
          f
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
             (e X&#x27; (F_obj X&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;))))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
          f
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
             (e X&#x27; (F_obj X&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;))))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (e X&#x27; (F_obj X&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;))))
    (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    X
    X&#x27;
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
    f
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (e X&#x27; (F_obj X&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;)))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    X
    X&#x27;
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
    f
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
       (e X&#x27; (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (F_obj X&#x27;)
          (F_obj X&#x27;)
          (F_obj X&#x27;&#x27;)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;))
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;)))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
                (e X&#x27; (F_obj X&#x27;&#x27;)))
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
                f&#x27;
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (F_obj X&#x27;&#x27;)
                         (F_obj X&#x27;&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X&#x27;&#x27;
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                   (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      (F_obj X&#x27;&#x27;)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    X
    X&#x27;
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
    f
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (F_obj X&#x27;)
             (F_obj X&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
       (e X&#x27; (F_obj X&#x27;&#x27;))
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;))))
          (e X&#x27; (F_obj X&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;))))
    (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;) (F_obj X&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;)))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
             (e X&#x27; (F_obj X&#x27;&#x27;)))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X&#x27;&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
             f&#x27;
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (F_obj X&#x27;&#x27;)
                      (F_obj X&#x27;&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X&#x27;&#x27;
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
                (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (F_obj X&#x27;&#x27;))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
    X
    X&#x27;
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
    f
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       f&#x27;
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       f
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X&#x27;&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
          f&#x27;
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>237      simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       f
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X&#x27;&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
          f&#x27;
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>238    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X X&#x27; X&#x27;&#x27; : C,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    X&#x27;,
f&#x27; :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X
          X&#x27;
          X&#x27;&#x27;
          f
          f&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (F_obj X&#x27;&#x27;)
                (F_obj X&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
          (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (F_obj X&#x27;&#x27;))))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
       f
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X&#x27;&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))
          f&#x27;
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (F_obj X&#x27;&#x27;)
                   (F_obj X&#x27;&#x27;))
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X&#x27;&#x27;
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G (F_obj X&#x27;&#x27;))))
             (e X&#x27;&#x27; (F_obj X&#x27;&#x27;))
             (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (F_obj X&#x27;&#x27;)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>239  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>240  def adjunction_of_equiv_left : left_adjoint_of_equiv e he âŠ£ G :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='category_theory.adjunction.left_adjoint_of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;line&#x27;: 231, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} {F_obj : C â†’ D} (e : Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))), (âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))) â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                          </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>241  mk_of_hom_equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>242  { hom_equiv := e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>243    hom_equiv_naturality_left_symm&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>244    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
âŠ¢ âˆ€ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X
      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
    @eq.{vâ‚‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
         (equiv.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                  (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                     (Î» (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                  (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                     (Î» (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.symm.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                  (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                     (Î» (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
            X&#x27;
            X
            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
            f
            g))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X&#x27;)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X)
         Y
         (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X&#x27;
            X
            f)
         (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
            (equiv.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                     (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                        (Î» (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                     (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                        (Î» (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.symm.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                     (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                        (Î» (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>245      intros,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))
âŠ¢ âˆ€ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X
      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
    @eq.{vâ‚‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
         (equiv.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                  (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                     (Î» (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                  (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                     (Î» (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y))
         (@equiv.symm.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                  (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                     (Î» (X : C), F_obj X)
                     e
                     he)
                  X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
            X&#x27;
            X
            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
            f
            g))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X&#x27;)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X)
         Y
         (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
               (Î» (X : C), F_obj X)
               e
               he)
            X&#x27;
            X
            f)
         (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
            (equiv.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                     (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                        (Î» (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                     (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                        (Î» (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y))
            (@equiv.symm.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                     (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                        (Î» (X : C), F_obj X)
                        e
                        he)
                     X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;
          X
          f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>246      erw [â† he&#x27; e he, â† equiv.apply_eq_iff_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_private.2238520471.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='equiv.apply_eq_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 228, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’} {F_obj : C â†’ D} (e : Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))), (âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))) â†’ âˆ€ {X : C} {Y Y&#x27; : D} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (e X Y&#x27;)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) f (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)) (e X Y)) f) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± Î² : Type vâ‚‚} (f : equiv.{vâ‚‚+1 vâ‚‚+1} Î± Î²) (x y : Î±), iff (@eq.{vâ‚‚+1} Î² (@coe_fn.{(max 1 (vâ‚‚+1)) vâ‚‚+1} (equiv.{vâ‚‚+1 vâ‚‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚‚+1} Î± Î²) f x) (@coe_fn.{(max 1 (vâ‚‚+1)) vâ‚‚+1} (equiv.{vâ‚‚+1 vâ‚‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚‚+1} Î± Î²) f y)) (@eq.{vâ‚‚+1} Î± x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;
          X
          f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          f
          g))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             ((Î» (X : C), F_obj X) X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             ((Î» (X : C), F_obj X) X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             ((Î» (X : C), F_obj X) X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ((Î» (X : C), F_obj X) X))
             f
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      ((Î» (X : C), F_obj X) X)
                      ((Î» (X : C), F_obj X) X))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ((Î» (X : C), F_obj X) X))))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      ((Î» (X : C), F_obj X) X)
                      ((Î» (X : C), F_obj X) X))
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ((Î» (X : C), F_obj X) X))))
                (e X ((Î» (X : C), F_obj X) X))
                (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   ((Î» (X : C), F_obj X) X))))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X)
             Y
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                         (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                            (Î» (X : C), F_obj X)
                            e
                            he)
                         X)
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                         (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                            (Î» (X : C), F_obj X)
                            e
                            he)
                         X)
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                         (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                            (Î» (X : C), F_obj X)
                            e
                            he)
                         X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                   (e X Y))
                g))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{?l_1} ?m_2
    (@coe_fn.{(max 1 (imax (vâ‚‚+1) ?l_1) ?l_1 (vâ‚‚+1)) (imax (vâ‚‚+1) ?l_1)}
       (equiv.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             f
             g)))
    (@coe_fn.{(max 1 (imax (vâ‚‚+1) ?l_1) ?l_1 (vâ‚‚+1)) (imax (vâ‚‚+1) ?l_1)}
       (equiv.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ((Î» (X : C), F_obj X) X))
                f
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         ((Î» (X : C), F_obj X) X)
                         ((Î» (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                            ((Î» (X : C), F_obj X) X))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         ((Î» (X : C), F_obj X) X)
                         ((Î» (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                            ((Î» (X : C), F_obj X) X))))
                   (e X ((Î» (X : C), F_obj X) X))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      ((Î» (X : C), F_obj X) X))))
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (e X Y))
                   g)))))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ equiv.{vâ‚‚+1 ?l_1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    ?m_2

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ Sort ?l_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>247      simp [(he _ _ _ _ _).symm]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ (X : C) (Y Y&#x27; : D) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y&#x27;) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))) (e X Y&#x27;) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (F_obj X) Y Y&#x27; h g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y) (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (F_obj X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))) (e X Y) h) (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{?l_1} ?m_2
    (@coe_fn.{(max 1 (imax (vâ‚‚+1) ?l_1) ?l_1 (vâ‚‚+1)) (imax (vâ‚‚+1) ?l_1)}
       (equiv.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             f
             g)))
    (@coe_fn.{(max 1 (imax (vâ‚‚+1) ?l_1) ?l_1 (vâ‚‚+1)) (imax (vâ‚‚+1) ?l_1)}
       (equiv.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ((Î» (X : C), F_obj X) X))
                f
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         ((Î» (X : C), F_obj X) X)
                         ((Î» (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                            ((Î» (X : C), F_obj X) X))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         ((Î» (X : C), F_obj X) X)
                         ((Î» (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                            ((Î» (X : C), F_obj X) X))))
                   (e X ((Î» (X : C), F_obj X) X))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      ((Î» (X : C), F_obj X) X))))
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (e X Y))
                   g)))))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ equiv.{vâ‚‚+1 ?l_1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    ?m_2

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ Sort ?l_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>248    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ @eq.{?l_1} ?m_2
    (@coe_fn.{(max 1 (imax (vâ‚‚+1) ?l_1) ?l_1 (vâ‚‚+1)) (imax (vâ‚‚+1) ?l_1)}
       (equiv.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             f
             g)))
    (@coe_fn.{(max 1 (imax (vâ‚‚+1) ?l_1) ?l_1 (vâ‚‚+1)) (imax (vâ‚‚+1) ?l_1)}
       (equiv.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       (@equiv.has_coe_to_fun.{vâ‚‚+1 ?l_1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                   (Î» (X : C), F_obj X)
                   e
                   he)
                X&#x27;)
             Y)
          ?m_2)
       ?m_3
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                ((Î» (X : C), F_obj X) X&#x27;)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X&#x27;
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
             (e X&#x27; Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X))
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
             (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                X&#x27;
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G ((Î» (X : C), F_obj X) X))
                f
                (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                   (equiv.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         ((Î» (X : C), F_obj X) X)
                         ((Î» (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                            ((Î» (X : C), F_obj X) X))))
                   (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         ((Î» (X : C), F_obj X) X)
                         ((Î» (X : C), F_obj X) X))
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                            ((Î» (X : C), F_obj X) X))))
                   (e X ((Î» (X : C), F_obj X) X))
                   (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                      ((Î» (X : C), F_obj X) X))))
             (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                      (Î» (X : C), F_obj X)
                      e
                      he)
                   X)
                Y
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                            (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G
                               (Î» (X : C), F_obj X)
                               e
                               he)
                            X)
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         X
                         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y))
                      (e X Y))
                   g)))))

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ equiv.{vâ‚‚+1 ?l_1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.adjunction.left_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ G (Î» (X : C), F_obj X)
             e
             he)
          X&#x27;)
       Y)
    ?m_2

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’,
F_obj : C â†’ D,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (F_obj X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)),
he :
  âˆ€ (X : C) (Y Y&#x27; : D)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;)
  (h :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (F_obj X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (F_obj X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (F_obj X)
            Y
            Y&#x27;
            h
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (F_obj X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)))
            (e X Y)
            h)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y Y&#x27; g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ G Y)
âŠ¢ Sort ?l_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>249  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>250  end construct_left</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>251  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>252  section construct_right</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>253  -- Construction of a right adjoint, analogous to the above.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>254  variables {F} {G_obj : D â†’ C}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>255  variables (e : Î  X Y, (F.obj X âŸ¶ Y) â‰ƒ (X âŸ¶ G_obj Y))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 19, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ C â†’ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.has_hom.{vâ‚‚ uâ‚‚} obj], obj â†’ obj â†’ Type vâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type vâ‚‚ â†’ Type vâ‚ â†’ Type (max (max vâ‚‚ vâ‚) vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.has_hom.{vâ‚ uâ‚} obj], obj â†’ obj â†’ Type vâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`Î± â‰ƒ Î²` is the type of functions from `Î± â†’ Î²` with a two-sided inverse.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>256  variables (he : Î  X&#x27; X Y f g, e X&#x27; Y (F.map f â‰« g) = f â‰« e X Y g)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  {Î± : Type vâ‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>257  include he</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>258  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>259  private lemma he&#x27; {X&#x27; X Y} (f g) : F.map f â‰« (e X Y).symm g = (e X&#x27; Y).symm (f â‰« g) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D] (c : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C _inst_1)) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D _inst_2)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚}, Î± â†’ Î± â†’ Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>260  by intros; rw [equiv.eq_symm_apply, he]; simp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± y (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) (@eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (G_obj Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (e X Y))
          g))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (G_obj Y)
          f
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (G_obj Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (G_obj Y))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y)))
       (e X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (G_obj Y))
                (e X Y))
             g)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (G_obj Y)
       f
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (G_obj Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (G_obj Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (G_obj Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y)))
          (e X Y)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (G_obj Y))
                (e X Y))
             g)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (G_obj Y)
       f
       g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (G_obj Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (e X Y))
          g))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (G_obj Y)
          f
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>261  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (G_obj Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y))
             (e X Y))
          g))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (G_obj Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (G_obj Y)
          f
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>262  def right_adjoint_of_equiv : D â¥¤ C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚‚) [_inst_1 : category_theory.category.{vâ‚‚ uâ‚‚} C] (D : Type uâ‚) [_inst_2 : category_theory.category.{vâ‚ uâ‚} D], Type (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>263  { obj := G_obj,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='D â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>264    map := Î» Y Y&#x27; g, (e (G_obj Y) Y&#x27;) ((e (G_obj Y) Y).symm (ğŸ™ _) â‰« g),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='G_obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='equiv.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 22}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D â†’ C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {Î± : Type vâ‚‚} {Î² : Type vâ‚}, equiv.{vâ‚‚+1 vâ‚+1} Î± Î² â†’ equiv.{vâ‚+1 vâ‚‚+1} Î² Î±'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {obj : Type uâ‚} [c : category_theory.category_struct.{vâ‚ uâ‚} obj] (X : obj), @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Î  {obj : Type uâ‚‚} [c : category_theory.category_struct.{vâ‚‚ uâ‚‚} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Y â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) Y Z â†’ @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>265    map_comp&#x27; := Î» Y Y&#x27; Y&#x27;&#x27; g g&#x27;, begin</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y Y&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) Y&#x27; Y&#x27;&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (G_obj Y)
       (G_obj Y&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (e (G_obj Y) Y&#x27;&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
          Y
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y)))
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             Y
             Y&#x27;
             Y&#x27;&#x27;
             g
             g&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (G_obj Y)
       (G_obj Y&#x27;)
       (G_obj Y&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y)))
             g))
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (e (G_obj Y&#x27;) Y&#x27;&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
             Y&#x27;
             Y&#x27;&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                      Y&#x27;)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (e (G_obj Y&#x27;) Y&#x27;))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y&#x27;)))
             g&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>266      rw [â† equiv.eq_symm_apply, â† he&#x27; e he, equiv.symm_apply_apply],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='equiv.eq_symm_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='_private.1468233907.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± y (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x)) (@eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y) x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G_obj : D â†’ C} (e : Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))), (âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))) â†’ âˆ€ {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (e X Y)) g)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (e X&#x27; Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (x : Î±), @eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (G_obj Y)
       (G_obj Y&#x27;&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;)))
       (e (G_obj Y) Y&#x27;&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
          Y
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y)))
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             Y
             Y&#x27;
             Y&#x27;&#x27;
             g
             g&#x27;)))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (G_obj Y)
       (G_obj Y&#x27;)
       (G_obj Y&#x27;&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y)))
             g))
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;&#x27;)))
          (e (G_obj Y&#x27;) Y&#x27;&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
             Y&#x27;
             Y&#x27;&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                      Y&#x27;))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                      Y&#x27;)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y&#x27;)
                      (G_obj Y&#x27;))
                   (e (G_obj Y&#x27;) Y&#x27;))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y&#x27;)))
             g&#x27;)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             (G_obj Y&#x27;&#x27;))
          (e (G_obj Y) Y&#x27;&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (G_obj Y)
          (G_obj Y&#x27;)
          (G_obj Y&#x27;&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g))
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (e (G_obj Y&#x27;) Y&#x27;&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;
                Y&#x27;&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                         Y&#x27;)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (e (G_obj Y&#x27;) Y&#x27;))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y&#x27;)))
                g&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g)))
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                ((Î» (Y : D), G_obj Y) Y&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                ((Î» (Y : D), G_obj Y) Y&#x27;&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                ((Î» (Y : D), G_obj Y) Y&#x27;&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;&#x27;))
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;&#x27;)))
             (e (G_obj Y&#x27;) Y&#x27;&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;
                Y&#x27;&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                         Y&#x27;))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                         Y&#x27;)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y&#x27;)
                         (G_obj Y&#x27;))
                      (e (G_obj Y&#x27;) Y&#x27;))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y&#x27;)))
                g&#x27;))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
          Y&#x27;
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (e (G_obj Y&#x27;) Y&#x27;))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y&#x27;)))
          g&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>267      conv { to_rhs, rw [â† assoc, he&#x27; e he, comp_id, equiv.symm_apply_apply] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.1468233907.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 68, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/converter/interactive.lean&#x27;, &#x27;line&#x27;: 174, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) Y Z), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G_obj : D â†’ C} (e : Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))), (âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))) â†’ âˆ€ {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (e X Y)) g)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (e X&#x27; Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Y f (@category_theory.category_struct.id.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (x : Î±), @eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ conv.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (Î» (a : option.{0} name), @option.has_reflect name (Î» (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit name (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.ident)) â†’ @interactive.parse (option.{0} pexpr) (Î» (a : option.{0} pexpr), @option.has_reflect pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) (lean.parser.pexpr std.prec.max))) â†’ conv.interactive.itactic â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='to_rhs'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='conv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;(at id)?&#x27;, &#x27;(in expr)?&#x27;, &#x27;{ tactic }&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
          Y&#x27;
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (e (G_obj Y&#x27;) Y&#x27;))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y&#x27;)))
          g&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;&#x27;
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
          Y&#x27;
          Y&#x27;&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y&#x27;)
                   (G_obj Y&#x27;))
                (e (G_obj Y&#x27;) Y&#x27;))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y&#x27;)))
          g&#x27;))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
    Y&#x27;&#x27;
    (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y)))
             g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y&#x27;)))
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g)))
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y&#x27;))))
    g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             ((Î» (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             ((Î» (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             ((Î» (Y : D), G_obj Y) Y&#x27;))
          (e (G_obj Y) Y&#x27;))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (G_obj Y)
          (G_obj Y&#x27;)
          ((Î» (Y : D), G_obj Y) Y&#x27;)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y&#x27;)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y&#x27;)))
             (e (G_obj Y) Y&#x27;)
             (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y
                Y&#x27;
                (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                   (equiv.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y))
                   (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                         Y)
                      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                         (G_obj Y)
                         (G_obj Y))
                      (e (G_obj Y) Y))
                   (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                      (G_obj Y)))
                g))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y&#x27;))))
    g&#x27;

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ C

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ C

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='4 goals
C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             ((Î» (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             ((Î» (Y : D), G_obj Y) Y&#x27;))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             (G_obj Y)
             ((Î» (Y : D), G_obj Y) Y&#x27;))
          (e (G_obj Y) Y&#x27;))
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y)))
             g)))
    g&#x27;

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ C

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ C

C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
    Y&#x27;&#x27;
    (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y) (G_obj Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y&#x27;)))
          (e (G_obj Y) Y&#x27;)
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      (G_obj Y)
                      (G_obj Y))
                   (e (G_obj Y) Y))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   (G_obj Y)))
             g)))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
       Y&#x27;
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y&#x27;))
                Y&#x27;)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y&#x27;)
                (G_obj Y&#x27;))
             (e (G_obj Y&#x27;) Y&#x27;))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y&#x27;)))
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
| @category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
    Y&#x27;
    Y&#x27;&#x27;
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       g)
    g&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;
       Y&#x27;&#x27;
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y)))
          g)
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>268      simp</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;
       Y&#x27;&#x27;
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y)))
          g)
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>269    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
Y Y&#x27; Y&#x27;&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;,
g&#x27; :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y&#x27;
    Y&#x27;&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y
       Y&#x27;&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                (G_obj Y)
                (G_obj Y))
             (e (G_obj Y) Y))
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (G_obj Y)))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          Y
          Y&#x27;
          Y&#x27;&#x27;
          g
          g&#x27;))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
       Y&#x27;
       Y&#x27;&#x27;
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (G_obj Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   (G_obj Y)
                   (G_obj Y))
                (e (G_obj Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                (G_obj Y)))
          g)
       g&#x27;)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>270  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>271  def adjunction_of_equiv_right : F âŠ£ right_adjoint_of_equiv e he :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction.right_adjoint_of_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 262, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G_obj : D â†’ C} (e : Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))), (âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))) â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>272  mk_of_hom_equiv</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_hom_equiv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 150, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_hom_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>273  { hom_equiv := e,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>274    hom_equiv_naturality_left_symm&#x27; := by intros; rw [equiv.symm_apply_eq, he]; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='equiv.symm_apply_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 109, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) {x : Î²} {y : Î±}, iff (@eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) x) y) (@eq.{vâ‚+1} Î² x (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
âŠ¢ âˆ€ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X
      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (Î» (Y : D), G_obj Y)
            e
            he)
         Y)),
    @eq.{vâ‚‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
         (equiv.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y))
         (@equiv.symm.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
            X&#x27;
            X
            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
               (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                  (Î» (Y : D), G_obj Y)
                  e
                  he)
               Y)
            f
            g))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y
         (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
         (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
            (equiv.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y))
            (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y))
            (@equiv.symm.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (Î» (Y : D), G_obj Y) e
          he)
       Y)
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       Y)
    (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
       (equiv.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y))
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y))
       (@equiv.symm.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y))
          (e X&#x27; Y))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          X&#x27;
          X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (Î» (Y : D), G_obj Y)
                e
                he)
             Y)
          f
          g))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y))
             (e X Y))
          g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (Î» (Y : D), G_obj Y) e
          he)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y)
       f
       g)
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
             Y)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X&#x27;
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y)))
       (e X&#x27; Y)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (e X Y))
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X&#x27; X : C,
Y : D,
f :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X&#x27;
    X,
g :
  @category_theory.has_hom.hom.{vâ‚ uâ‚} C
    (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
    X
    (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (Î» (Y : D), G_obj Y) e
          he)
       Y)
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X&#x27;
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y)
       f
       g)
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X&#x27;
       X
       (G_obj Y)
       f
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (G_obj Y)))
          (e X Y)
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y))
                (e X Y))
             g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
âŠ¢ âˆ€ {X&#x27; X : C} {Y : D}
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X
      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F (Î» (Y : D), G_obj Y)
            e
            he)
         Y)),
    @eq.{vâ‚‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
         Y)
      (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
         (equiv.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y))
         (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y))
         (@equiv.symm.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y))
            (e X&#x27; Y))
         (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
            X&#x27;
            X
            (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
               (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                  (Î» (Y : D), G_obj Y)
                  e
                  he)
               Y)
            f
            g))
      (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y
         (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
         (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
            (equiv.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y))
            (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y))
            (@equiv.symm.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y))
               (e X Y))
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>275    hom_equiv_naturality_right&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>276    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
âŠ¢ âˆ€ {X : C} {Y Y&#x27; : D}
  (f :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            Y&#x27;
            f
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (e X Y)
            f)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y
            Y&#x27;
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>277      intros X Y Y&#x27; g h,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros hâ‚ ... hâ‚™` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g))
âŠ¢ âˆ€ {X : C} {Y Y&#x27; : D}
  (f :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      Y
      Y&#x27;),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y&#x27;))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
               Y&#x27;)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X
               (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                  (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                     (Î» (Y : D), G_obj Y)
                     e
                     he)
                  Y&#x27;)))
         (e X Y&#x27;)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            Y&#x27;
            f
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y)
         (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y&#x27;)
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                     (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                        (Î» (Y : D), G_obj Y)
                        e
                        he)
                     Y)))
            (e X Y)
            f)
         (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
            (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
               (Î» (Y : D), G_obj Y)
               e
               he)
            Y
            Y&#x27;
            g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>278      erw [â†he, equiv.apply_eq_iff_eq, â†assoc, he&#x27; e he, comp_id, equiv.symm_apply_apply]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.apply_eq_iff_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='_private.1468233907.he&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='he'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category.comp_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='equiv.symm_apply_apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 104, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 259, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/equiv/basic.lean&#x27;, &#x27;line&#x27;: 98, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (f : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (x y : Î±), iff (@eq.{vâ‚+1} Î² (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) f x) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) f y)) (@eq.{vâ‚‚+1} Î± x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚‚) [c : category_theory.category.{vâ‚‚ uâ‚‚} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) X Y) (h : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) Y Z), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c)) W Z) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W Y Z (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) W X Z f (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} obj (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G_obj : D â†’ C} (e : Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))), (âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))) â†’ âˆ€ {X&#x27; X : C} {Y : D} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)), @eq.{vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y)) (e X Y)) g)) (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y)) (@equiv.symm.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (e X&#x27; Y)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  (X : C) (Y : D), equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (X&#x27; X : C) (Y : D) (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; X) (g : @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y)) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X&#x27; (G_obj Y))) (e X&#x27; Y) (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f) g)) (@category_theory.category_struct.comp.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’) X&#x27; X (G_obj Y) f (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)) (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X) Y) (@category_theory.has_hom.hom.{vâ‚ uâ‚} C (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)) X (G_obj Y))) (e X Y) g))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type uâ‚) [c : category_theory.category.{vâ‚ uâ‚} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y), @eq.{vâ‚+1} (@category_theory.has_hom.hom.{vâ‚ uâ‚} obj (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c)) X Y) (@category_theory.category_struct.comp.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) X Y Y f (@category_theory.category_struct.id.{vâ‚ uâ‚} obj (@category_theory.category.to_category_struct.{vâ‚ uâ‚} obj c) Y)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ {Î± : Type vâ‚‚} {Î² : Type vâ‚} (e : equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (x : Î±), @eq.{vâ‚‚+1} Î± (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))} (equiv.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1} Î² Î±) (@equiv.symm.{vâ‚‚+1 vâ‚+1} Î± Î² e) (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))} (equiv.{vâ‚‚+1 vâ‚+1} Î± Î²) (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1} Î± Î²) e x)) x'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          g
          h))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (G_obj Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (G_obj Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y))
          Y&#x27;
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y)
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                            (Î» (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                            (Î» (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (e X Y)
                g))
          (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
             Y
             Y&#x27;
             (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
                (equiv.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      ((Î» (Y : D), G_obj Y) Y)
                      ((Î» (Y : D), G_obj Y) Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                      Y))
                (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      ((Î» (Y : D), G_obj Y) Y)
                      ((Î» (Y : D), G_obj Y) Y))
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                      Y))
                (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      ((Î» (Y : D), G_obj Y) Y)
                      ((Î» (Y : D), G_obj Y) Y))
                   (e ((Î» (Y : D), G_obj Y) Y) Y))
                (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                   ((Î» (Y : D), G_obj Y) Y)))
             h)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (Î» (Y : D), G_obj Y)
                e
                he)
             Y))
       Y&#x27;
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                (Î» (Y : D), G_obj Y)
                e
                he)
             Y)
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (e X Y)
             g))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
          Y
          Y&#x27;
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   ((Î» (Y : D), G_obj Y) Y)
                   ((Î» (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   ((Î» (Y : D), G_obj Y) Y)
                   ((Î» (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   ((Î» (Y : D), G_obj Y) Y)
                   ((Î» (Y : D), G_obj Y) Y))
                (e ((Î» (Y : D), G_obj Y) Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                ((Î» (Y : D), G_obj Y) Y)))
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y))
          Y
          (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y)
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                            (Î» (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                            (Î» (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (e X Y)
                g))
          (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
             (equiv.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   ((Î» (Y : D), G_obj Y) Y)
                   ((Î» (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   ((Î» (Y : D), G_obj Y) Y)
                   ((Î» (Y : D), G_obj Y) Y))
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                   Y))
             (@equiv.symm.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F ((Î» (Y : D), G_obj Y) Y))
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   ((Î» (Y : D), G_obj Y) Y)
                   ((Î» (Y : D), G_obj Y) Y))
                (e ((Î» (Y : D), G_obj Y) Y) Y))
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                ((Î» (Y : D), G_obj Y) Y))))
       h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                ((Î» (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                ((Î» (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                ((Î» (Y : D), G_obj Y) Y))
             (e X Y))
          (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y)
             ((Î» (Y : D), G_obj Y) Y)
             (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
                (equiv.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                            (Î» (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                   (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                      Y)
                   (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                      X
                      (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                         (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                            (Î» (Y : D), G_obj Y)
                            e
                            he)
                         Y)))
                (e X Y)
                g)
             (@category_theory.category_struct.id.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
                ((Î» (Y : D), G_obj Y) Y))))
       h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y&#x27;)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       g
       h)
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
       Y
       Y&#x27;
       (@coe_fn.{(max 1 (max (vâ‚+1) (vâ‚‚+1)) (vâ‚‚+1) (vâ‚+1)) (max (vâ‚+1) (vâ‚‚+1))}
          (equiv.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                ((Î» (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.has_coe_to_fun.{vâ‚+1 vâ‚‚+1}
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                ((Î» (Y : D), G_obj Y) Y))
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y))
          (@equiv.symm.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                ((Î» (Y : D), G_obj Y) Y))
             (e X Y))
          (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
             (equiv.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
                (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                      (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                   Y)
                (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                   (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                      (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                   X
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                         (Î» (Y : D), G_obj Y)
                         e
                         he)
                      Y)))
             (e X Y)
             g))
       h)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>279    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (Î» (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (â†? expr), ... ] | â†? expr)&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
G_obj : D â†’ C,
e :
  Î  (X : C) (Y : D),
    equiv.{vâ‚‚+1 vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
         (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
         Y)
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X
         (G_obj Y)),
he :
  âˆ€ (X&#x27; X : C) (Y : D)
  (f :
    @category_theory.has_hom.hom.{vâ‚ uâ‚} C
      (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
      X&#x27;
      X)
  (g :
    @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
      (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
         (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
      (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
      Y),
    @eq.{vâ‚+1}
      (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
         (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
            (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
         X&#x27;
         (G_obj Y))
      (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
         (equiv.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
            (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
               (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
               (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
               Y)
            (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
               (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                  (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
               X&#x27;
               (G_obj Y)))
         (e X&#x27; Y)
         (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
            (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27;)
            (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
            Y
            (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X&#x27; X f)
            g))
      (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
         (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
         X&#x27;
         X
         (G_obj Y)
         f
         (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
            (equiv.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
               (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                  (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                     (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                  (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                  Y)
               (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                  (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                     (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                  X
                  (G_obj Y)))
            (e X Y)
            g)),
X : C,
Y Y&#x27; : D,
g :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
    Y,
h :
  @category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
    (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
    Y
    Y&#x27;
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;))
    (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
       (equiv.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
          (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
             (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
             Y&#x27;)
          (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
             (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
             X
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                   (Î» (Y : D), G_obj Y)
                   e
                   he)
                Y&#x27;)))
       (e X Y&#x27;)
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
          Y
          Y&#x27;
          g
          h))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       X
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y&#x27;)
       (@coe_fn.{(max 1 (max (vâ‚‚+1) (vâ‚+1)) (vâ‚+1) (vâ‚‚+1)) (max (vâ‚‚+1) (vâ‚+1))}
          (equiv.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (@equiv.has_coe_to_fun.{vâ‚‚+1 vâ‚+1}
             (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
                (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
                   (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F X)
                Y)
             (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
                (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
                   (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
                X
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
                      (Î» (Y : D), G_obj Y)
                      e
                      he)
                   Y)))
          (e X Y)
          g)
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.adjunction.right_adjoint_of_equiv.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F
             (Î» (Y : D), G_obj Y)
             e
             he)
          Y
          Y&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>280  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>281  end construct_right</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>282  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>283  end adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>284  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>285  open adjunction</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>286  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>287  namespace equivalence</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>288  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>289  def to_adjunction (e : C â‰Œ D) : e.functor âŠ£ e.inverse :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.inverse'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C _inst_1 D _inst_2 â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D _inst_2 C _inst_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='We define an equivalence as a (half)-adjoint equivalence, a pair of functors with
 a unit and counit which are natural isomorphisms and the triangle law `FÎ· â‰« ÎµF = 1`, or in other
 words the composite `F âŸ¶ FGF âŸ¶ F` is the identity.

 The triangle equation is written as a family of equalities between morphisms, it is more
 complicated if we write it as an equality of natural transformations, because then we would have
 to insert natural transformations like `F âŸ¶ F1`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>290  mk_of_unit_counit âŸ¨e.unit, e.counit,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.adjunction.mk_of_unit_counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.equivalence.counit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 171, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 43, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] {F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ} {G : @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’}, @category_theory.adjunction.core_unit_counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G â†’ @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.has_hom.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)} (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’) (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’))) (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’) (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’ (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e) (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.has_hom.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)} (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ) (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ))) (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e) (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)) (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>291    by { ext, dsimp, simp only [id_comp], exact e.functor_unit_comp _, },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 52, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
âŠ¢ auto_param.{0}
    (@eq.{(max uâ‚ vâ‚‚)+1}
       (@category_theory.has_hom.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category_struct.to_has_hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)))
       (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.iso.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
                (@category_theory.functor.associator.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ C ğ’ D
                   ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))))
       (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          x))
    (@category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
          (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
          (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
          (@category_theory.whisker_right.{uâ‚ vâ‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.category_struct.comp.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
             (@category_theory.category.to_category_struct.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ))
             (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
             (@category_theory.iso.hom.{(max uâ‚ vâ‚‚) (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ)
                (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
                (@category_theory.functor.associator.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ C ğ’ D
                   ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.whisker_left.{uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))))
       x)
    (@category_theory.nat_trans.app.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
       (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
       (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚‚ uâ‚ uâ‚‚ uâ‚‚} C ğ’ D ğ’Ÿ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.nat_trans.id.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚ vâ‚ vâ‚‚ uâ‚ uâ‚ uâ‚‚} C ğ’ C ğ’ D ğ’Ÿ
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.iso.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)}
                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.equivalence.unit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             x))
       (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   x)))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   x)))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             x)
          (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D
             (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      x))))
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.iso.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.counit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x))))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
x : C
âŠ¢ @eq.{vâ‚‚+1}
    (@category_theory.has_hom.hom.{vâ‚‚ uâ‚‚} D
       (@category_theory.category_struct.to_has_hom.{vâ‚‚ uâ‚‚} D
          (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))
    (@category_theory.category_struct.comp.{vâ‚‚ uâ‚‚} D
       (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x)))
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.map.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x))
          (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.iso.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)}
                (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
                (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
                (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.equivalence.unit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             x))
       (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.iso.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
             (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.equivalence.counit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             x)))
    (@category_theory.category_struct.id.{vâ‚‚ uâ‚‚} D (@category_theory.category.to_category_struct.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
       (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
          (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>292    by { ext, dsimp, simp only [id_comp], exact e.unit_inverse_comp _, }âŸ©</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='e'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse tactic.ext_patt (Î» (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (Î» (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse â†’ @interactive.parse (option.{0} nat) (Î» (a : option.{0} nat), @option.has_reflect nat (Î» (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='âˆ€ (obj : Type ?l_1) [c : category_theory.category.{?l_2 ?l_1} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y), @eq.{?l_2+1} (@category_theory.has_hom.hom.{?l_2 ?l_1} obj (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c)) X Y) (@category_theory.category_struct.comp.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X X Y (@category_theory.category_struct.id.{?l_2 ?l_1} obj (@category_theory.category.to_category_struct.{?l_2 ?l_1} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (Î» (a : option.{0} unit), @option.has_reflect unit (Î» (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) â†’ @interactive.parse bool (Î» (a : bool), bool.has_reflect a) interactive.types.only_flag â†’ @interactive.parse (list.{0} tactic.simp_arg_type) (Î» (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (Î» (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list â†’ @interactive.parse (list.{0} name) (Î» (a : list.{0} name), @list.reflect name (Î» (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list â†’ @interactive.parse interactive.loc (Î» (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location â†’ opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (Î» (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr â†’ tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²
âŠ¢ f = g
```

applying `ext x y` yields:

```lean
Î± Î² : Type,
f g : Î± â†’ set Î²,
x : Î±,
y : Î²
âŠ¢ y âˆˆ f x â†” y âˆˆ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [hâ‚ hâ‚‚ ... hâ‚™]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `háµ¢`&#x27;s, where the `háµ¢`&#x27;s are expressions. If an `háµ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [hâ‚ hâ‚‚ ... hâ‚™]` is like `simp [hâ‚ hâ‚‚ ... hâ‚™]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idáµ¢`.

`simp at hâ‚ hâ‚‚ ... hâ‚™` simplifies the non-dependent hypotheses `hâ‚ : Tâ‚` ... `hâ‚™ : Tâ‚™`. The tactic fails if the target or another hypothesis depends on one of them. The token `âŠ¢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attrâ‚ ... attrâ‚™` simplifies the main goal target using the lemmas tagged with any of the attributes `[attrâ‚]`, ..., `[attrâ‚™]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The other triangle equality. The proof follows the following proof in Globular:
 http://globular.science/1905.001'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (âŠ¢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”˜</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
âŠ¢ auto_param.{0}
    (@eq.{(max uâ‚‚ vâ‚)+1}
       (@category_theory.has_hom.hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category_struct.to_has_hom.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
       (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.iso.inv.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
                (@category_theory.functor.associator.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ D ğ’Ÿ C
                   ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))))
       (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))))
    (name.mk_string
       (string.str
          (string.str
             (string.str
                (string.str
                   (string.str
                      (string.str
                         (string.str
                            (string.str
                               (string.str string.empty
                                  (char.of_nat
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@bit0.{0} nat nat.has_add
                                                    (@bit1.{0} nat nat.has_one nat.has_add
                                                       (@has_one.one.{0} nat nat.has_one)))))))))
                               (char.of_nat
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit0.{0} nat nat.has_add
                                              (@bit0.{0} nat nat.has_add
                                                 (@bit1.{0} nat nat.has_one nat.has_add
                                                    (@has_one.one.{0} nat nat.has_one)))))))))
                            (char.of_nat
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@bit1.{0} nat nat.has_one nat.has_add
                                                 (@has_one.one.{0} nat nat.has_one)))))))))
                         (char.of_nat
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit0.{0} nat nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add
                                        (@bit0.{0} nat nat.has_add
                                           (@bit1.{0} nat nat.has_one nat.has_add
                                              (@has_one.one.{0} nat nat.has_one)))))))))
                      (char.of_nat
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit0.{0} nat nat.has_add
                                        (@bit1.{0} nat nat.has_one nat.has_add
                                           (@has_one.one.{0} nat nat.has_one)))))))))
                   (char.of_nat
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add
                               (@bit0.{0} nat nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add
                                     (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
                (char.of_nat
                   (@bit1.{0} nat nat.has_one nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit0.{0} nat nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add
                                  (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
             (char.of_nat
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit0.{0} nat nat.has_add
                               (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
          (char.of_nat
             (@bit1.{0} nat nat.has_one nat.has_add
                (@bit0.{0} nat nat.has_add
                   (@bit0.{0} nat nat.has_add
                      (@bit1.{0} nat nat.has_one nat.has_add
                         (@bit1.{0} nat nat.has_one nat.has_add
                            (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))
       name.anonymous)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          x))
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
       (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
          (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
          (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
          (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.whisker_left.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.unit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.category_struct.comp.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
             (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
             (@category_theory.category.to_category_struct.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.iso.inv.{(max uâ‚‚ vâ‚) (max vâ‚‚ vâ‚ uâ‚‚ uâ‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.category.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
                (@category_theory.functor.associator.{uâ‚‚ vâ‚‚ uâ‚ vâ‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ C ğ’ D ğ’Ÿ C
                   ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)))
             (@category_theory.whisker_right.{uâ‚‚ vâ‚‚ uâ‚‚ vâ‚‚ uâ‚ vâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.counit.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))))
       x)
    (@category_theory.nat_trans.app.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
       (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.comp.{vâ‚‚ vâ‚‚ vâ‚ uâ‚‚ uâ‚‚ uâ‚} D ğ’Ÿ D ğ’Ÿ C ğ’
          (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
       (@category_theory.nat_trans.id.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚ uâ‚‚ uâ‚ uâ‚} D ğ’Ÿ C ğ’ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)))
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.iso.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.unit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             x))
       (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   x)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   x)))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             x)
          (@category_theory.category_struct.id.{vâ‚ uâ‚} C
             (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      x))))
          (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   x))
             x
             (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.iso.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)}
                   (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
                   (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
                   (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                      (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                      (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                   (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                   (@category_theory.equivalence.counit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                x))))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type uâ‚,
ğ’ : category_theory.category.{vâ‚ uâ‚} C,
D : Type uâ‚‚,
ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D,
e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ,
x : D
âŠ¢ @eq.{vâ‚+1}
    (@category_theory.has_hom.hom.{vâ‚ uâ‚} C
       (@category_theory.category_struct.to_has_hom.{vâ‚ uâ‚} C
          (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))
    (@category_theory.category_struct.comp.{vâ‚ uâ‚} C
       (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x)))
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x)
       (@category_theory.nat_trans.app.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’
          (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
          (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.iso.hom.{(max uâ‚ vâ‚) (max vâ‚ uâ‚)}
             (@category_theory.functor.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
             (@category_theory.functor.category.{vâ‚ vâ‚ uâ‚ uâ‚} C ğ’ C ğ’)
             (@category_theory.functor.id.{vâ‚ uâ‚} C ğ’)
             (@category_theory.functor.comp.{vâ‚ vâ‚‚ vâ‚ uâ‚ uâ‚‚ uâ‚} C ğ’ D ğ’Ÿ C ğ’
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.equivalence.unit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
          (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
             (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             x))
       (@category_theory.functor.map.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          (@category_theory.functor.obj.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ
             (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
             (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                x))
          x
          (@category_theory.nat_trans.app.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ
             (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
             (@category_theory.iso.hom.{(max uâ‚‚ vâ‚‚) (max vâ‚‚ uâ‚‚)}
                (@category_theory.functor.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
                (@category_theory.functor.category.{vâ‚‚ vâ‚‚ uâ‚‚ uâ‚‚} D ğ’Ÿ D ğ’Ÿ)
                (@category_theory.functor.comp.{vâ‚‚ vâ‚ vâ‚‚ uâ‚‚ uâ‚ uâ‚‚} D ğ’Ÿ C ğ’ D ğ’Ÿ
                   (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
                   (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
                (@category_theory.functor.id.{vâ‚‚ uâ‚‚} D ğ’Ÿ)
                (@category_theory.equivalence.counit_iso.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e))
             x)))
    (@category_theory.category_struct.id.{vâ‚ uâ‚} C (@category_theory.category.to_category_struct.{vâ‚ uâ‚} C ğ’)
       (@category_theory.functor.obj.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’
          (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>293  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>294  end equivalence</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>295  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>296  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>297  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>298  def adjunction (E : C â¥¤ D) [is_equivalence E] : E âŠ£ E.inv :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.inv'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 195, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;line&#x27;: 23, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 232, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='Type uâ‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  (C : Type uâ‚) [_inst_1 : category_theory.category.{vâ‚ uâ‚} C] (D : Type uâ‚‚) [_inst_2 : category_theory.category.{vâ‚‚ uâ‚‚} D], Type (max vâ‚ vâ‚‚ uâ‚ uâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type uâ‚‚'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D], @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ â†’ @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’ â†’ Type (max uâ‚ uâ‚‚ vâ‚ vâ‚‚)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) [_inst_1 : @category_theory.is_equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F], @category_theory.functor.{vâ‚‚ vâ‚ uâ‚‚ uâ‚} D ğ’Ÿ C ğ’'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”˜</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='A functor that is part of a (half) adjoint equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`F âŠ£ G` represents the data of an adjunction between two functors
`F : C â¥¤ D` and `G : D â¥¤ C`. `F` is the left adjoint and `G` is the right adjoint.'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>299  (E.as_equivalence).to_adjunction</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='E'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.as_equivalence'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.equivalence.to_adjunction'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 289, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â”´</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (F : @category_theory.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ) [_inst_1 : @category_theory.is_equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ F], @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Î  {C : Type uâ‚} [ğ’ : category_theory.category.{vâ‚ uâ‚} C] {D : Type uâ‚‚} [ğ’Ÿ : category_theory.category.{vâ‚‚ uâ‚‚} D] (e : @category_theory.equivalence.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ), @category_theory.adjunction.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ (@category_theory.equivalence.functor.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e) (@category_theory.equivalence.inverse.{vâ‚ vâ‚‚ uâ‚ uâ‚‚} C ğ’ D ğ’Ÿ e)'><code style='font-family: menlo, "Source Code Pro", monospace;'>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>300  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>301  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>302  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>303  end category_theory</code></pre>
</body>