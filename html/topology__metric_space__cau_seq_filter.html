<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2018 Robert Y. Lewis. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Robert Y. Lewis, Sébastien Gouëzel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import topology.uniform_space.basic analysis.normed_space.basic data.real.cau_seq</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import tactic.linarith</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/linarith.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  /-! # Completeness in terms of `cauchy` filters vs `is_cau_seq` sequences</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  In this file we apply `metric.complete_of_cauchy_seq_tendsto` to prove that a `normed_ring`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  is complete in terms of `cauchy` filter if and only if it is complete in terms</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  of `cau_seq` Cauchy sequences.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  universes u v</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  open set filter</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  open_locale topological_space classical</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  variable {β : Type v}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  lemma cau_seq.tendsto_limit [normed_ring β] [hn : is_absolute_value (norm : β → ℝ)]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    (f : cau_seq β norm) [cau_seq.is_complete β norm] :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25    tendsto f at_top (𝓝 f.lim) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  _root_.tendsto_nhds.mpr</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    intros s os lfs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    suffices : ∃ (a : ℕ), ∀ (b : ℕ), b ≥ a → f b ∈ s, by simpa using this,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 961, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`suffices h : t` is the same as `have h : t, tactic.swap`. In other words, it adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='suffices'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30    rcases metric.is_open_iff.1 os _ lfs with ⟨ε, ⟨hε, hεs⟩⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31    cases setoid.symm (cau_seq.equiv_lim f) _ hε with N hN,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='setoid.symm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cau_seq.equiv_lim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/setoid.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq_completion.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : setoid.{(max 1 (v+1))} α] {a b : α}, @has_equiv.equiv.{(max 1 (v+1))} α (@setoid_has_equiv.{(max 1 (v+1))} α _inst_1) a b → @has_equiv.equiv.{(max 1 (v+1))} α (@setoid_has_equiv.{(max 1 (v+1))} α _inst_1) b a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] {β : Type v} [_inst_2 : ring.{v} β] {abv : β → α} [_inst_3 : @is_absolute_value.{0 v} α _inst_1 β _inst_2 abv] [_inst_4 : @cau_seq.is_complete.{0 v} α _inst_1 β _inst_2 abv _inst_3] (s : @cau_seq.{0 v} α _inst_1 β _inst_2 abv), @has_equiv.equiv.{(max 1 (v+1))} (@cau_seq.{0 v} α _inst_1 β _inst_2 abv) (@setoid_has_equiv.{(max 1 (v+1))} (@cau_seq.{0 v} α _inst_1 β _inst_2 abv) (@cau_seq.equiv.{0 v} α _inst_1 β _inst_2 abv _inst_3)) s (@cau_seq.const.{0 v} α _inst_1 β _inst_2 abv _inst_3 (@cau_seq.lim.{0 v} α _inst_1 β _inst_2 abv _inst_3 _inst_4 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1) (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @ge.{0} nat nat.has_le b a →
         @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
           (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
              (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                 (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
              (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β _inst_1)
                 (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
              f
              b)
           s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @ge.{0} nat nat.has_le b a →
         @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
           (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
              (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                 (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
              (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β _inst_1)
                 (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
              f
              b)
           s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    existsi N,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @ge.{0} nat nat.has_le b a →
         @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
           (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
              (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                 (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
              (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β _inst_1)
                 (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
              f
              b)
           s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε
⊢ ∀ (b : nat),
    @ge.{0} nat nat.has_le b N →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
            (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
            (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
         f
         b)
      s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    intros b hb,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε
⊢ ∀ (b : nat),
    @ge.{0} nat nat.has_le b N →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
            (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
            (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
         f
         b)
      s'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       f
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34    apply hεs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       f
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       f
       b)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    dsimp [metric.ball], rw [dist_comm, dist_eq_norm],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='metric.ball'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='dist_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dist_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 245, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α], α → real → set.{?l_1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : metric_space.{v} α] (x y : α), @eq.{1} real (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α _inst_1) x y) (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α _inst_1) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : normed_group.{v} α] (g h : α), @eq.{1} real (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α (@normed_group.to_metric_space.{v} α _inst_1)) g h) (@has_norm.norm.{v} α (@normed_group.to_has_norm.{v} α _inst_1) (@has_sub.sub.{v} α (@add_group_has_sub.{v} α (@add_comm_group.to_add_group.{v} α (@normed_group.to_add_comm_group.{v} α _inst_1))) g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`ball x ε` is the set of all points `y` with `dist y x &lt; ε`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
       f
       b)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_ring.to_metric_space.{v} β _inst_1))
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
             (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β _inst_1)
             (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
          f
          b)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_ring.to_metric_space.{v} β _inst_1))
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
             (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β _inst_1)
             (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
          f
          b))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β (@normed_ring.to_normed_group.{v} β _inst_1))
       (@has_sub.sub.{v} β
          (@add_group_has_sub.{v} β
             (@add_comm_group.to_add_group.{v} β
                (@normed_group.to_add_comm_group.{v} β (@normed_ring.to_normed_group.{v} β _inst_1))))
          (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
             (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
             hn
             _inst_2
             f)
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β _inst_1)
                (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
             f
             b)))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    solve_by_elim</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/solve_by_elim.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.by_elim_opt {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches
and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,
performing at most `max_rep` recursive steps.

`solve_by_elim` discharges the current goal or fails.

`solve_by_elim` performs back-tracking if `apply_assumption` chooses an unproductive assumption.

By default, the assumptions passed to apply_assumption are the local context, `rfl`, `trivial`, `congr_fun` and
`congr_arg`.

`solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the named lemmas.

`solve_by_elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.

`solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context, `rfl`, `trivial`, `congr_fun`, or `congr_arg`
unless they are explicitly included.

`solve_by_elim [-id]` removes a specified assumption.

`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.

optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. `cc` may be helpful)
- max_rep: number of attempts at discharging generated sub-goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='solve_by_elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.by_elim_opt?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_ring.{v} β,
hn :
  @is_absolute_value.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)),
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
    (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
    hn,
s : set.{v} β,
os :
  @is_open.{v} β
    (@uniform_space.to_topological_space.{v} β
       (@metric_space.to_uniform_space&#x27;.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)))
    s,
lfs :
  @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β)
    (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
       (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
       hn
       _inst_2
       f)
    s,
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  @has_subset.subset.{v} (set.{v} β) (@set.has_subset.{v} β)
    (@metric.ball.{v} β (@normed_ring.to_metric_space.{v} β _inst_1)
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
          (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
          hn
          _inst_2
          f)
       ε)
    s,
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β _inst_1)
               (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                        (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β _inst_1)
                           (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                           hn))))
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                  (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                  hn
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                     (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
                     hn
                     _inst_2
                     f))
               f)
            j))
      ε,
b : nat,
hb : @ge.{0} nat nat.has_le b N
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_norm.norm.{v} β (@normed_group.to_has_norm.{v} β (@normed_ring.to_normed_group.{v} β _inst_1))
       (@has_sub.sub.{v} β
          (@add_group_has_sub.{v} β
             (@add_comm_group.to_add_group.{v} β
                (@normed_group.to_add_comm_group.{v} β (@normed_ring.to_normed_group.{v} β _inst_1))))
          (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
             (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1))
             hn
             _inst_2
             f)
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β _inst_1)
                (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β _inst_1)
                (@has_norm.norm.{v} β (@normed_ring.to_has_norm.{v} β _inst_1)))
             f
             b)))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  variables [normed_field β]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type v → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='A normed field is a field with a norm satisfying ∥x y∥ = ∥x∥ ∥y∥.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42   This section shows that if we have a uniform space generated by an absolute value, topological</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43   completeness and Cauchy sequence completeness coincide. The problem is that there isn&#x27;t</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44   a good notion of &quot;uniform space generated by an absolute value&quot;, so right now this is</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45   specific to norm. Furthermore, norm only instantiates is_absolute_value on normed_field.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46   This needs to be fixed, since it prevents showing that ℤ_[hp] is complete</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  instance normed_field.is_absolute_value : is_absolute_value (norm : β → ℝ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='is_absolute_value'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : discrete_linear_ordered_field.{u_1} α] {β : Type u_2} [_inst_2 : ring.{u_2} β], (β → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_5} [c : has_norm.{u_5} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title=' A function f is an absolute value if it is nonnegative, zero only at 0, additive, and
multiplicative.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  { abv_nonneg := norm_nonneg,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='norm_nonneg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 135, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : normed_group.{u_1} α] (g : α), @has_le.le.{0} real real.has_le (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) (@has_norm.norm.{u_1} α (@normed_group.to_has_norm.{u_1} α _inst_1) g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    abv_eq_zero := norm_eq_zero,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='norm_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 138, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : normed_group.{u_1} α] (g : α), iff (@eq.{1} real (@has_norm.norm.{u_1} α (@normed_group.to_has_norm.{u_1} α _inst_1) g) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (@eq.{u_1+1} α g (@has_zero.zero.{u_1} α (@add_monoid.to_has_zero.{u_1} α (@add_group.to_add_monoid.{u_1} α (@add_comm_group.to_add_group.{u_1} α (@normed_group.to_add_comm_group.{u_1} α _inst_1))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52    abv_add := norm_add_le,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='norm_add_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : normed_group.{u_1} α] (g h : α), @has_le.le.{0} real real.has_le (@has_norm.norm.{u_1} α (@normed_group.to_has_norm.{u_1} α _inst_1) (@has_add.add.{u_1} α (@add_semigroup.to_has_add.{u_1} α (@add_monoid.to_add_semigroup.{u_1} α (@add_group.to_add_monoid.{u_1} α (@add_comm_group.to_add_group.{u_1} α (@normed_group.to_add_comm_group.{u_1} α _inst_1))))) g h)) (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_norm.norm.{u_1} α (@normed_group.to_has_norm.{u_1} α _inst_1) g) (@has_norm.norm.{u_1} α (@normed_group.to_has_norm.{u_1} α _inst_1) h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='Triangle inequality for the norm.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53    abv_mul := normed_field.norm_mul }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='normed_field.norm_mul'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 439, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='∀ {α : Type u_1} [_inst_1 : normed_field.{u_1} α] (a b : α), @eq.{1} real (@has_norm.norm.{u_1} α (@normed_field.to_has_norm.{u_1} α _inst_1) (@has_mul.mul.{u_1} α (@no_zero_divisors.to_has_mul.{u_1} α (@domain.to_no_zero_divisors.{u_1} α (@division_ring.to_domain.{u_1} α (@field.to_division_ring.{u_1} α (@discrete_field.to_field.{u_1} α (@normed_field.to_discrete_field.{u_1} α _inst_1)))))) a b)) (@has_mul.mul.{0} real (@no_zero_divisors.to_has_mul.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)) (@has_norm.norm.{u_1} α (@normed_field.to_has_norm.{u_1} α _inst_1) a) (@has_norm.norm.{u_1} α (@normed_field.to_has_norm.{u_1} α _inst_1) b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  open metric</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  lemma cauchy_seq.is_cau_seq {f : ℕ → β} (hf : cauchy_seq f) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cauchy_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : lattice.semilattice_sup.{v} β], (β → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                              </code><font color='orange'><a title=' Cauchy sequences. Usually defined on ℕ, but often it is also useful to say that a function
defined on ℝ is Cauchy at +∞ to deduce convergence. Therefore, we define it in a type class that
is general enough to cover both ℕ and ℝ, which are the main motivating examples.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    is_cau_seq norm f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_cau_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : discrete_linear_ordered_field.{u_1} α] {β : Type u_2} [_inst_2 : ring.{u_2} β], (β → α) → (nat → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_5} [c : has_norm.{u_5} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A sequence is Cauchy if the distance between its entries tends to zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f
⊢ @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60    cases cauchy_iff.1 hf with hf1 hf2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cauchy_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hf'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : uniform_space.{v} α] {f : filter.{v} α}, iff (@cauchy.{v} α _inst_1 f) (and (@ne.{v+1} (filter.{v} α) f (@lattice.has_bot.bot.{v} (filter.{v} α) (@lattice.order_bot.to_has_bot.{v} (filter.{v} α) (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} α) (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} α) (@filter.lattice.complete_lattice.{v} α)))))) (∀ (s : set.{v} (prod.{v v} α α)), @has_mem.mem.{v v} (set.{v} (prod.{v v} α α)) (filter.{v} (prod.{v v} α α)) (@filter.has_mem.{v} (prod.{v v} α α)) s (@uniformity.{v} α _inst_1) → @Exists.{v+1} (set.{v} α) (λ (t : set.{v} α), @Exists.{0} (@has_mem.mem.{v v} (set.{v} α) (set.{v} (set.{v} α)) (@set.has_mem.{v} (set.{v} α)) t (@filter.sets.{v} α f)) (λ (H : @has_mem.mem.{v v} (set.{v} α) (set.{v} (set.{v} α)) (@set.has_mem.{v} (set.{v} α)) t (@filter.sets.{v} α f)), @has_subset.subset.{v} (set.{v} (prod.{v v} α α)) (@set.has_subset.{v} (prod.{v v} α α)) (@set.prod.{v v} α α t t) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f
⊢ @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s))
⊢ @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    intros ε hε,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s))
⊢ @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field)))))))
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62    rcases hf2 {x | dist x.1 x.2 &lt; ε} (dist_mem_uniformity hε) with ⟨t, ⟨ht, htsub⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='hf2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='metric.dist_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (s : set.{v} (prod.{v v} β β)), @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β)) (@filter.has_mem.{v} (prod.{v v} β β)) s (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) → @Exists.{v+1} (set.{v} β) (λ (t : set.{v} β), @Exists.{0} (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t (@filter.sets.{v} β (@filter.map.{0 v} nat β f (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@lattice.semilattice_sup.to_partial_order.{0} nat (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))))) (λ (H : @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t (@filter.sets.{v} β (@filter.map.{0 v} nat β f (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@lattice.semilattice_sup.to_partial_order.{0} nat (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))))), @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β)) (@set.prod.{v v} β β t t) s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v}, (α → Prop) → set.{v} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_dist.{v} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v} [_inst_1 : metric_space.{v} α] {ε : real}, @has_lt.lt.{0} real real.has_lt (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) ε → @has_mem.mem.{v v} (set.{v} (prod.{v v} α α)) (filter.{v} (prod.{v v} α α)) (@filter.has_mem.{v} (prod.{v v} α α)) (@set_of.{v} (prod.{v v} α α) (λ (p : prod.{v v} α α), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α _inst_1) (@prod.fst.{v v} α α p) (@prod.snd.{v v} α α p)) ε)) (@uniformity.{v} α (@metric_space.to_uniform_space&#x27;.{v} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real (@preorder.to_has_lt.{0} real (@partial_order.to_preorder.{0} real (@ordered_comm_monoid.to_partial_order.{0} real (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real (@ordered_ring.to_ordered_semiring.{0} real (@linear_ordered_ring.to_ordered_ring.{0} real (@linear_ordered_field.to_linear_ordered_ring.{0} real (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real real.discrete_linear_ordered_field))))))))) ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real (@division_ring.to_domain.{0} real (@field.to_division_ring.{0} real (@linear_ordered_field.to_field.{0} real (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real real.discrete_linear_ordered_field)))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field)))))))
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
ht :
  @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
    (@filter.sets.{v} β
       (@filter.map.{0 v} nat β f
          (@filter.at_top.{0} nat
             (@partial_order.to_preorder.{0} nat
                (@lattice.semilattice_sup.to_partial_order.{0} nat
                   (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))),
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε))
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    simp at ht, cases ht with N hN,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{1} nat (λ (a : nat), ∀ (b : nat), @has_le.le.{0} nat (@preorder.to_has_le.{0} nat (@partial_order.to_preorder.{0} nat (@lattice.semilattice_sup.to_partial_order.{0} nat (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))) a b → @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
ht :
  @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
    (@filter.sets.{v} β
       (@filter.map.{0 v} nat β f
          (@filter.at_top.{0} nat
             (@partial_order.to_preorder.{0} nat
                (@lattice.semilattice_sup.to_partial_order.{0} nat
                   (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))),
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε))
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
ht :
  @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @has_le.le.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           a
           b →
         @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t)
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    existsi N,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t
⊢ @Exists.{1} nat
    (λ (i : nat),
       ∀ (j : nat),
         @ge.{0} nat nat.has_le j i →
         @has_lt.lt.{0} real
           (@preorder.to_has_lt.{0} real
              (@partial_order.to_preorder.{0} real
                 (@ordered_comm_monoid.to_partial_order.{0} real
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                          (@ordered_ring.to_ordered_semiring.{0} real
                             (@linear_ordered_ring.to_ordered_ring.{0} real
                                (@linear_ordered_field.to_linear_ordered_ring.{0} real
                                   (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                      real.discrete_linear_ordered_field)))))))))
           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
              (@has_sub.sub.{v} β
                 (@add_group_has_sub.{v} β
                    (@add_comm_group.to_add_group.{v} β
                       (@ring.to_add_comm_group.{v} β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
                 (f j)
                 (f i)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t
⊢ ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (f j)
            (f N)))
      ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65    intros j hj,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t
⊢ ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (f j)
            (f N)))
      ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t,
j : nat,
hj : @ge.{0} nat nat.has_le j N
⊢ @has_lt.lt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
       (@has_sub.sub.{v} β
          (@add_group_has_sub.{v} β
             (@add_comm_group.to_add_group.{v} β
                (@ring.to_add_comm_group.{v} β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
          (f j)
          (f N)))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66    rw ←dist_eq_norm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='dist_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : normed_group.{v} α] (g h : α), @eq.{1} real (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α (@normed_group.to_metric_space.{v} α _inst_1)) g h) (@has_norm.norm.{v} α (@normed_group.to_has_norm.{v} α _inst_1) (@has_sub.sub.{v} α (@add_group_has_sub.{v} α (@add_comm_group.to_add_group.{v} α (@normed_group.to_add_comm_group.{v} α _inst_1))) g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t,
j : nat,
hj : @ge.{0} nat nat.has_le j N
⊢ @has_lt.lt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
       (@has_sub.sub.{v} β
          (@add_group_has_sub.{v} β
             (@add_comm_group.to_add_group.{v} β
                (@ring.to_add_comm_group.{v} β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
          (f j)
          (f N)))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t,
j : nat,
hj : @ge.{0} nat nat.has_le j N
⊢ @has_lt.lt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    (@has_dist.dist.{v} β
       (@metric_space.to_has_dist.{v} β
          (@normed_group.to_metric_space.{v} β
             (@normed_ring.to_normed_group.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))))
       (f j)
       (f N))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67    apply @htsub (f j, f N),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='htsub'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='j'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β)) (@set.prod.{v v} β β t t) (@set_of.{v} (prod.{v v} β β) (λ (x : prod.{v v} β β), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) (@prod.fst.{v v} β β x) (@prod.snd.{v v} β β x)) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type v}, α → β → prod.{v v} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t,
j : nat,
hj : @ge.{0} nat nat.has_le j N
⊢ @has_lt.lt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    (@has_dist.dist.{v} β
       (@metric_space.to_has_dist.{v} β
          (@normed_group.to_metric_space.{v} β
             (@normed_ring.to_normed_group.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))))
       (f j)
       (f N))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t,
j : nat,
hj : @ge.{0} nat nat.has_le j N
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β (f j) (f N))
    (@set.prod.{v v} β β t t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    apply set.mk_mem_prod; solve_by_elim [le_refl]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='set.mk_mem_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='le_refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/solve_by_elim.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/solve_by_elim.lean&#x27;, &#x27;line&#x27;: 130, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v} {s : set.{v} α} {t : set.{v} β} {a : α} {b : β}, @has_mem.mem.{v v} α (set.{v} α) (@set.has_mem.{v} α) a s → @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) b t → @has_mem.mem.{v v} (prod.{v v} α β) (set.{v} (prod.{v v} α β)) (@set.has_mem.{v} (prod.{v v} α β)) (@prod.mk.{v v} α β a b) (@set.prod.{v v} α β s t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.by_elim_opt {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : preorder.{?l_1} α] (a : α), @has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α _inst_1) a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → opt_param.{1} tactic.by_elim_opt {backtrack_all_goals := bool.ff, discharger := tactic.done, assumptions := tactic.mk_assumption_set (@decidable.to_bool false decidable.false) (@list.nil.{0} tactic.simp_arg_type) (@list.nil.{0} name), max_rep := @bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches
and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,
performing at most `max_rep` recursive steps.

`solve_by_elim` discharges the current goal or fails.

`solve_by_elim` performs back-tracking if `apply_assumption` chooses an unproductive assumption.

By default, the assumptions passed to apply_assumption are the local context, `rfl`, `trivial`, `congr_fun` and
`congr_arg`.

`solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the named lemmas.

`solve_by_elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.

`solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context, `rfl`, `trivial`, `congr_fun`, or `congr_arg`
unless they are explicitly included.

`solve_by_elim [-id]` removes a specified assumption.

`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.

optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. `cc` may be helpful)
- max_rep: number of attempts at discharging generated sub-goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches
and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,
performing at most `max_rep` recursive steps.

`solve_by_elim` discharges the current goal or fails.

`solve_by_elim` performs back-tracking if `apply_assumption` chooses an unproductive assumption.

By default, the assumptions passed to apply_assumption are the local context, `rfl`, `trivial`, `congr_fun` and
`congr_arg`.

`solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the named lemmas.

`solve_by_elim with attr₁ ... attrᵣ also applied all lemmas tagged with the specified attributes.

`solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context, `rfl`, `trivial`, `congr_fun`, or `congr_arg`
unless they are explicitly included.

`solve_by_elim [-id]` removes a specified assumption.

`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal
makes other goals impossible.

optional arguments:
- discharger: a subsidiary tactic to try at each step (e.g. `cc` may be helpful)
- max_rep: number of attempts at discharging generated sub-goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='solve_by_elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='solve_by_elim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.by_elim_opt?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;*?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;tactic.by_elim_opt?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f : nat → β,
hf :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    f,
hf1 :
  @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β f
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β))))),
hf2 :
  ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β f
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β f
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s)),
ε : real,
hε :
  @gt.{0} real
    (@preorder.to_has_lt.{0} real
       (@partial_order.to_preorder.{0} real
          (@ordered_comm_monoid.to_partial_order.{0} real
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                   (@ordered_ring.to_ordered_semiring.{0} real
                      (@linear_ordered_ring.to_ordered_ring.{0} real
                         (@linear_ordered_field.to_linear_ordered_ring.{0} real
                            (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                               real.discrete_linear_ordered_field)))))))))
    ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real
          (@domain.to_no_zero_divisors.{0} real
             (@division_ring.to_domain.{0} real
                (@field.to_division_ring.{0} real
                   (@linear_ordered_field.to_field.{0} real
                      (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                         real.discrete_linear_ordered_field))))))),
t : set.{v} β,
htsub :
  @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β t t)
    (@set_of.{v} (prod.{v v} β β)
       (λ (x : prod.{v v} β β),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
               (@prod.fst.{v v} β β x)
               (@prod.snd.{v v} β β x))
            ε)),
N : nat,
hN :
  ∀ (b : nat),
    @has_le.le.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      N
      b →
    @has_mem.mem.{v v} β (set.{v} β) (@set.has_mem.{v} β) (f b) t,
j : nat,
hj : @ge.{0} nat nat.has_le j N
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β (f j) (f N))
    (@set.prod.{v v} β β t t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  lemma cau_seq.cauchy_seq (f : cau_seq β norm) : cauchy_seq f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='blue'><a title='cau_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='cauchy_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 177, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : discrete_linear_ordered_field.{u_1} α] (β : Type u_2) [_inst_2 : ring.{u_2} β], (β → α) → Type u_2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_5} [c : has_norm.{u_5} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : lattice.semilattice_sup.{v} β], (β → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                </code><font color='orange'><a title=' Cauchy sequences. Usually defined on ℕ, but often it is also useful to say that a function
defined on ℝ is Cauchy at +∞ to deduce convergence. Therefore, we define it in a type class that
is general enough to cover both ℕ and ℝ, which are the main motivating examples.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    apply cauchy_iff.2,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='cauchy_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : uniform_space.{v} α] {f : filter.{v} α}, iff (@cauchy.{v} α _inst_1 f) (and (@ne.{v+1} (filter.{v} α) f (@lattice.has_bot.bot.{v} (filter.{v} α) (@lattice.order_bot.to_has_bot.{v} (filter.{v} α) (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} α) (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} α) (@filter.lattice.complete_lattice.{v} α)))))) (∀ (s : set.{v} (prod.{v v} α α)), @has_mem.mem.{v v} (set.{v} (prod.{v v} α α)) (filter.{v} (prod.{v v} α α)) (@filter.has_mem.{v} (prod.{v v} α α)) s (@uniformity.{v} α _inst_1) → @Exists.{v+1} (set.{v} α) (λ (t : set.{v} α), @Exists.{0} (@has_mem.mem.{v v} (set.{v} α) (set.{v} (set.{v} α)) (@set.has_mem.{v} (set.{v} α)) t (@filter.sets.{v} α f)) (λ (H : @has_mem.mem.{v v} (set.{v} α) (set.{v} (set.{v} α)) (@set.has_mem.{v} (set.{v} α)) t (@filter.sets.{v} α f)), @has_subset.subset.{v} (set.{v} (prod.{v v} α α)) (@set.has_subset.{v} (prod.{v v} α α)) (@set.prod.{v v} α α t t) s))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ and
    (@ne.{v+1} (filter.{v} β)
       (@filter.map.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@filter.at_top.{0} nat
             (@partial_order.to_preorder.{0} nat
                (@lattice.semilattice_sup.to_partial_order.{0} nat
                   (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
       (@lattice.has_bot.bot.{v} (filter.{v} β)
          (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
             (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
                (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                   (@filter.lattice.complete_lattice.{v} β))))))
    (∀ (s : set.{v} (prod.{v v} β β)),
       @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
         (@filter.has_mem.{v} (prod.{v v} β β))
         s
         (@uniformity.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
       @Exists.{v+1} (set.{v} β)
         (λ (t : set.{v} β),
            @Exists.{0}
              (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                 (@filter.sets.{v} β
                    (@filter.map.{0 v} nat β
                       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                          f)
                       (@filter.at_top.{0} nat
                          (@partial_order.to_preorder.{0} nat
                             (@lattice.semilattice_sup.to_partial_order.{0} nat
                                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                   lattice.nat.semilattice_sup_bot)))))))
              (λ
               (H :
                 @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                   (@filter.sets.{v} β
                      (@filter.map.{0 v} nat β
                         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                            f)
                         (@filter.at_top.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@lattice.semilattice_sup.to_partial_order.{0} nat
                                  (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                     lattice.nat.semilattice_sup_bot))))))),
                 @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                   (@set.prod.{v v} β β t t)
                   s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ and
    (@ne.{v+1} (filter.{v} β)
       (@filter.map.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@filter.at_top.{0} nat
             (@partial_order.to_preorder.{0} nat
                (@lattice.semilattice_sup.to_partial_order.{0} nat
                   (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
       (@lattice.has_bot.bot.{v} (filter.{v} β)
          (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
             (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
                (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                   (@filter.lattice.complete_lattice.{v} β))))))
    (∀ (s : set.{v} (prod.{v v} β β)),
       @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
         (@filter.has_mem.{v} (prod.{v v} β β))
         s
         (@uniformity.{v} β
            (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
       @Exists.{v+1} (set.{v} β)
         (λ (t : set.{v} β),
            @Exists.{0}
              (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                 (@filter.sets.{v} β
                    (@filter.map.{0 v} nat β
                       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                          f)
                       (@filter.at_top.{0} nat
                          (@partial_order.to_preorder.{0} nat
                             (@lattice.semilattice_sup.to_partial_order.{0} nat
                                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                   lattice.nat.semilattice_sup_bot)))))))
              (λ
               (H :
                 @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                   (@filter.sets.{v} β
                      (@filter.map.{0 v} nat β
                         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                            f)
                         (@filter.at_top.{0} nat
                            (@partial_order.to_preorder.{0} nat
                               (@lattice.semilattice_sup.to_partial_order.{0} nat
                                  (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                     lattice.nat.semilattice_sup_bot))))))),
                 @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                   (@set.prod.{v v} β β t t)
                   s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β)))))

β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β
                      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         f)
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    { exact map_ne_bot at_top_ne_bot },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='filter.map_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.at_top_ne_bot'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1070, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1656, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type v} {f : filter.{0} α} {m : α → β}, @ne.{1} (filter.{0} α) f (@lattice.has_bot.bot.{0} (filter.{0} α) (@lattice.order_bot.to_has_bot.{0} (filter.{0} α) (@lattice.bounded_lattice.to_order_bot.{0} (filter.{0} α) (@lattice.complete_lattice.to_bounded_lattice.{0} (filter.{0} α) (@filter.lattice.complete_lattice.{0} α))))) → @ne.{v+1} (filter.{v} β) (@filter.map.{0 v} α β m f) (@lattice.has_bot.bot.{v} (filter.{v} β) (@lattice.order_bot.to_has_bot.{v} (filter.{v} β) (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β) (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β) (@filter.lattice.complete_lattice.{v} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : nonempty.{1} α] [_inst_2 : lattice.semilattice_sup.{0} α], @ne.{1} (filter.{0} α) (@filter.at_top.{0} α (@partial_order.to_preorder.{0} α (@lattice.semilattice_sup.to_partial_order.{0} α _inst_2))) (@lattice.has_bot.bot.{0} (filter.{0} α) (@lattice.order_bot.to_has_bot.{0} (filter.{0} α) (@lattice.bounded_lattice.to_order_bot.{0} (filter.{0} α) (@lattice.complete_lattice.to_bounded_lattice.{0} (filter.{0} α) (@filter.lattice.complete_lattice.{0} α)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β)))))

β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β
                      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         f)
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ @ne.{v+1} (filter.{v} β)
    (@filter.map.{0 v} nat β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f)
       (@filter.at_top.{0} nat
          (@partial_order.to_preorder.{0} nat
             (@lattice.semilattice_sup.to_partial_order.{0} nat
                (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))
    (@lattice.has_bot.bot.{v} (filter.{v} β)
       (@lattice.order_bot.to_has_bot.{v} (filter.{v} β)
          (@lattice.bounded_lattice.to_order_bot.{v} (filter.{v} β)
             (@lattice.complete_lattice.to_bounded_lattice.{v} (filter.{v} β)
                (@filter.lattice.complete_lattice.{v} β)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β
                      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         f)
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    { intros s hs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
⊢ ∀ (s : set.{v} (prod.{v v} β β)),
    @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
      (@filter.has_mem.{v} (prod.{v v} β β))
      s
      (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))) →
    @Exists.{v+1} (set.{v} β)
      (λ (t : set.{v} β),
         @Exists.{0}
           (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot)))))))
           (λ
            (H :
              @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
                (@filter.sets.{v} β
                   (@filter.map.{0 v} nat β
                      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         f)
                      (@filter.at_top.{0} nat
                         (@partial_order.to_preorder.{0} nat
                            (@lattice.semilattice_sup.to_partial_order.{0} nat
                               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                  lattice.nat.semilattice_sup_bot))))))),
              @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
                (@set.prod.{v v} β β t t)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
⊢ @Exists.{v+1} (set.{v} β)
    (λ (t : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
            (@filter.sets.{v} β
               (@filter.map.{0 v} nat β
                  (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     f)
                  (@filter.at_top.{0} nat
                     (@partial_order.to_preorder.{0} nat
                        (@lattice.semilattice_sup.to_partial_order.{0} nat
                           (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                              lattice.nat.semilattice_sup_bot)))))))
         (λ
          (H :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot))))))),
            @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
              (@set.prod.{v v} β β t t)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      rcases mem_uniformity_dist.1 hs with ⟨ε, ⟨hε, hεs⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='metric.mem_uniformity_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 307, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : metric_space.{v} α] {s : set.{v} (prod.{v v} α α)}, iff (@has_mem.mem.{v v} (set.{v} (prod.{v v} α α)) (filter.{v} (prod.{v v} α α)) (@filter.has_mem.{v} (prod.{v v} α α)) s (@uniformity.{v} α (@metric_space.to_uniform_space&#x27;.{v} α _inst_1))) (@Exists.{1} real (λ (ε : real), @Exists.{0} (@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (λ (H : @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))), ∀ {a b : α}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α _inst_1) a b) ε → @has_mem.mem.{v v} (prod.{v v} α α) (set.{v} (prod.{v v} α α)) (@set.has_mem.{v} (prod.{v v} α α)) (@prod.mk.{v v} α α a b) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β)) (@filter.has_mem.{v} (prod.{v v} β β)) s (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
⊢ @Exists.{v+1} (set.{v} β)
    (λ (t : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
            (@filter.sets.{v} β
               (@filter.map.{0 v} nat β
                  (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     f)
                  (@filter.at_top.{0} nat
                     (@partial_order.to_preorder.{0} nat
                        (@lattice.semilattice_sup.to_partial_order.{0} nat
                           (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                              lattice.nat.semilattice_sup_bot)))))))
         (λ
          (H :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot))))))),
            @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
              (@set.prod.{v v} β β t t)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s
⊢ @Exists.{v+1} (set.{v} β)
    (λ (t : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
            (@filter.sets.{v} β
               (@filter.map.{0 v} nat β
                  (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     f)
                  (@filter.at_top.{0} nat
                     (@partial_order.to_preorder.{0} nat
                        (@lattice.semilattice_sup.to_partial_order.{0} nat
                           (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                              lattice.nat.semilattice_sup_bot)))))))
         (λ
          (H :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot))))))),
            @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
              (@set.prod.{v v} β β t t)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78      cases cau_seq.cauchy₂ f hε with N hN,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='cau_seq.cauchy₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 205, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] {β : Type v} [_inst_2 : ring.{v} β] {abv : β → α} [_inst_3 : @is_absolute_value.{0 v} α _inst_1 β _inst_2 abv] (f : @cau_seq.{0 v} α _inst_1 β _inst_2 abv) {ε : α}, @gt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))))) ε (@has_zero.zero.{0} α (@no_zero_divisors.to_has_zero.{0} α (@domain.to_no_zero_divisors.{0} α (@division_ring.to_domain.{0} α (@field.to_division_ring.{0} α (@linear_ordered_field.to_field.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))) → @Exists.{1} nat (λ (i : nat), ∀ (j k : nat), @ge.{0} nat nat.has_le j i → @ge.{0} nat nat.has_le k i → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_monoid.to_partial_order.{0} α (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@ordered_ring.to_ordered_semiring.{0} α (@linear_ordered_ring.to_ordered_ring.{0} α (@linear_ordered_field.to_linear_ordered_ring.{0} α (@discrete_linear_ordered_field.to_linear_ordered_field.{0} α _inst_1))))))))) (abv (@has_sub.sub.{v} β (@add_group_has_sub.{v} β (@add_comm_group.to_add_group.{v} β (@ring.to_add_comm_group.{v} β _inst_2))) (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))} (@cau_seq.{0 v} α _inst_1 β _inst_2 abv) (@cau_seq.has_coe_to_fun.{0 v} α _inst_1 β _inst_2 abv) f j) (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))} (@cau_seq.{0 v} α _inst_1 β _inst_2 abv) (@cau_seq.has_coe_to_fun.{0 v} α _inst_1 β _inst_2 abv) f k))) ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s
⊢ @Exists.{v+1} (set.{v} β)
    (λ (t : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
            (@filter.sets.{v} β
               (@filter.map.{0 v} nat β
                  (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     f)
                  (@filter.at_top.{0} nat
                     (@partial_order.to_preorder.{0} nat
                        (@lattice.semilattice_sup.to_partial_order.{0} nat
                           (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                              lattice.nat.semilattice_sup_bot)))))))
         (λ
          (H :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot))))))),
            @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
              (@set.prod.{v v} β β t t)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{v+1} (set.{v} β)
    (λ (t : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
            (@filter.sets.{v} β
               (@filter.map.{0 v} nat β
                  (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     f)
                  (@filter.at_top.{0} nat
                     (@partial_order.to_preorder.{0} nat
                        (@lattice.semilattice_sup.to_partial_order.{0} nat
                           (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                              lattice.nat.semilattice_sup_bot)))))))
         (λ
          (H :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot))))))),
            @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
              (@set.prod.{v v} β β t t)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79      existsi {n | n ≥ N}.image f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type}, (α → Prop) → set.{0} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{v+1} (set.{v} β)
    (λ (t : set.{v} β),
       @Exists.{0}
         (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
            (@filter.sets.{v} β
               (@filter.map.{0 v} nat β
                  (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     f)
                  (@filter.at_top.{0} nat
                     (@partial_order.to_preorder.{0} nat
                        (@lattice.semilattice_sup.to_partial_order.{0} nat
                           (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                              lattice.nat.semilattice_sup_bot)))))))
         (λ
          (H :
            @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β)) t
              (@filter.sets.{v} β
                 (@filter.map.{0 v} nat β
                    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                       f)
                    (@filter.at_top.{0} nat
                       (@partial_order.to_preorder.{0} nat
                          (@lattice.semilattice_sup.to_partial_order.{0} nat
                             (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat
                                lattice.nat.semilattice_sup_bot))))))),
            @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
              (@set.prod.{v v} β β t t)
              s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{0}
    (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β))
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N)))
       (@filter.sets.{v} β
          (@filter.map.{0 v} nat β
             (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                f)
             (@filter.at_top.{0} nat
                (@partial_order.to_preorder.{0} nat
                   (@lattice.semilattice_sup.to_partial_order.{0} nat
                      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))))
    (λ
     (H :
       @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β))
         (@set.image.{0 v} nat β
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f)
            (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N)))
         (@filter.sets.{v} β
            (@filter.map.{0 v} nat β
               (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  f)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@lattice.semilattice_sup.to_partial_order.{0} nat
                        (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))))),
       @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
         (@set.prod.{v v} β β
            (@set.image.{0 v} nat β
               (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  f)
               (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N)))
            (@set.image.{0 v} nat β
               (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  f)
               (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N))))
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80      simp, split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{0}
    (@has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β))
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N)))
       (@filter.sets.{v} β
          (@filter.map.{0 v} nat β
             (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                f)
             (@filter.at_top.{0} nat
                (@partial_order.to_preorder.{0} nat
                   (@lattice.semilattice_sup.to_partial_order.{0} nat
                      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)))))))
    (λ
     (H :
       @has_mem.mem.{v v} (set.{v} β) (set.{v} (set.{v} β)) (@set.has_mem.{v} (set.{v} β))
         (@set.image.{0 v} nat β
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f)
            (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N)))
         (@filter.sets.{v} β
            (@filter.map.{0 v} nat β
               (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  f)
               (@filter.at_top.{0} nat
                  (@partial_order.to_preorder.{0} nat
                     (@lattice.semilattice_sup.to_partial_order.{0} nat
                        (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))))),
       @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
         (@set.prod.{v v} β β
            (@set.image.{0 v} nat β
               (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  f)
               (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N)))
            (@set.image.{0 v} nat β
               (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  f)
               (@set_of.{0} nat (λ (n : nat), @ge.{0} nat nat.has_le n N))))
         s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ and
    (@Exists.{1} nat
       (λ (a : nat),
          ∀ (b : nat),
            @has_le.le.{0} nat nat.has_le a b →
            @Exists.{1} nat
              (λ (x : nat),
                 and (@has_le.le.{0} nat nat.has_le N x)
                   (@eq.{v+1} β
                      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         f
                         x)
                      (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                         (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                         f
                         b)))))
    (@has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
       (@set.prod.{v v} β β
          (@set.image.{0 v} nat β
             (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                f)
             (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)))
          (@set.image.{0 v} nat β
             (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                f)
             (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N))))
       s)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @has_le.le.{0} nat nat.has_le a b →
         @Exists.{1} nat
           (λ (x : nat),
              and (@has_le.le.{0} nat nat.has_le N x)
                (@eq.{v+1} β
                   (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                      (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      f
                      x)
                   (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                      (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      f
                      b))))

β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)))
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81      { existsi N, intros b hb, existsi b, simp [hb] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hb'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} nat nat.has_le N b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @has_le.le.{0} nat nat.has_le a b →
         @Exists.{1} nat
           (λ (x : nat),
              and (@has_le.le.{0} nat nat.has_le N x)
                (@eq.{v+1} β
                   (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                      (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      f
                      x)
                   (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                      (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      f
                      b))))

β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)))
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @Exists.{1} nat
    (λ (a : nat),
       ∀ (b : nat),
         @has_le.le.{0} nat nat.has_le a b →
         @Exists.{1} nat
           (λ (x : nat),
              and (@has_le.le.{0} nat nat.has_le N x)
                (@eq.{v+1} β
                   (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                      (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      f
                      x)
                   (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                      (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                      f
                      b))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ ∀ (b : nat),
    @has_le.le.{0} nat nat.has_le N b →
    @Exists.{1} nat
      (λ (x : nat),
         and (@has_le.le.{0} nat nat.has_le N x)
           (@eq.{v+1} β
              (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                 (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                 (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                 f
                 x)
              (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
                 (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                 (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                 f
                 b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
b : nat,
hb : @has_le.le.{0} nat nat.has_le N b
⊢ @Exists.{1} nat
    (λ (x : nat),
       and (@has_le.le.{0} nat nat.has_le N x)
         (@eq.{v+1} β
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               x)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
b : nat,
hb : @has_le.le.{0} nat nat.has_le N b
⊢ and (@has_le.le.{0} nat nat.has_le N b)
    (@eq.{v+1} β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          b)
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          b))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)))
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82      { rintros ⟨a, b⟩ ⟨⟨a&#x27;, ⟨ha&#x27;1, ha&#x27;2⟩⟩, ⟨b&#x27;, ⟨hb&#x27;1, hb&#x27;2⟩⟩⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε
⊢ @has_subset.subset.{v} (set.{v} (prod.{v v} β β)) (@set.has_subset.{v} (prod.{v v} β β))
    (@set.prod.{v v} β β
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)))
       (@set.image.{0 v} nat β
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f)
          (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N))))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; : nat,
ha&#x27;1 :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a&#x27; (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)),
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    (@prod.fst.{v v} β β (@prod.mk.{v v} β β a b)),
b&#x27; : nat,
hb&#x27;1 :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) b&#x27; (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)),
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    (@prod.snd.{v v} β β (@prod.mk.{v v} β β a b))
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β a b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83        dsimp at ha&#x27;1 ha&#x27;2 hb&#x27;1 hb&#x27;2,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; : nat,
ha&#x27;1 :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) a&#x27; (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)),
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    (@prod.fst.{v v} β β (@prod.mk.{v v} β β a b)),
b&#x27; : nat,
hb&#x27;1 :
  @has_mem.mem.{0 0} nat (set.{0} nat) (@set.has_mem.{0} nat) b&#x27; (@set_of.{0} nat (@has_le.le.{0} nat nat.has_le N)),
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    (@prod.snd.{v v} β β (@prod.mk.{v v} β β a b))
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β a b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β a b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84        rw [←ha&#x27;2, ←hb&#x27;2],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ha&#x27;2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hb&#x27;2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) f a&#x27;) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v+1} β (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) f b&#x27;) b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β a b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          a&#x27;)
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          a&#x27;)
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          b&#x27;))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85        apply hεs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
    (@prod.mk.{v v} β β
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          a&#x27;)
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          b&#x27;))
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          a&#x27;)
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          b&#x27;))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86        rw dist_eq_norm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='dist_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : normed_group.{v} α] (g h : α), @eq.{1} real (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α (@normed_group.to_metric_space.{v} α _inst_1)) g h) (@has_norm.norm.{v} α (@normed_group.to_has_norm.{v} α _inst_1) (@has_sub.sub.{v} α (@add_group_has_sub.{v} α (@add_comm_group.to_add_group.{v} α (@normed_group.to_add_comm_group.{v} α _inst_1))) g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          a&#x27;)
       (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
          (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
          f
          b&#x27;))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_norm.norm.{v} β
       (@normed_group.to_has_norm.{v} β
          (@normed_ring.to_normed_group.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))
       (@has_sub.sub.{v} β
          (@add_group_has_sub.{v} β
             (@add_comm_group.to_add_group.{v} β
                (@normed_group.to_add_comm_group.{v} β
                   (@normed_ring.to_normed_group.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f
             a&#x27;)
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f
             b&#x27;)))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87        apply hN; assumption }},</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 227, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic looks in the local context for a hypothesis whose type is equal to the goal target. If it finds one, it uses it to prove the goal, and otherwise it fails.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assumption'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
f :
  @cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)),
s : set.{v} (prod.{v v} β β),
hs :
  @has_mem.mem.{v v} (set.{v} (prod.{v v} β β)) (filter.{v} (prod.{v v} β β))
    (@filter.has_mem.{v} (prod.{v v} β β))
    s
    (@uniformity.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))),
ε : real,
hε :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hεs :
  ∀ {a b : β},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) a b)
      ε →
    @has_mem.mem.{v v} (prod.{v v} β β) (set.{v} (prod.{v v} β β)) (@set.has_mem.{v} (prod.{v v} β β))
      (@prod.mk.{v v} β β a b)
      s,
N : nat,
hN :
  ∀ (j k : nat),
    @ge.{0} nat nat.has_le j N →
    @ge.{0} nat nat.has_le k N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@has_sub.sub.{v} β
            (@add_group_has_sub.{v} β
               (@add_comm_group.to_add_group.{v} β
                  (@ring.to_add_comm_group.{v} β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               j)
            (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               f
               k)))
      ε,
a b : β,
a&#x27; b&#x27; : nat,
hb&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       b&#x27;)
    b,
hb&#x27;1 : @has_le.le.{0} nat nat.has_le N b&#x27;,
ha&#x27;2 :
  @eq.{v+1} β
    (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
       (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
       f
       a&#x27;)
    a,
ha&#x27;1 : @has_le.le.{0} nat nat.has_le N a&#x27;
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_norm.norm.{v} β
       (@normed_group.to_has_norm.{v} β
          (@normed_ring.to_normed_group.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))
       (@has_sub.sub.{v} β
          (@add_group_has_sub.{v} β
             (@add_comm_group.to_add_group.{v} β
                (@normed_group.to_add_comm_group.{v} β
                   (@normed_ring.to_normed_group.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)))))
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f
             a&#x27;)
          (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
             (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
                (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
             f
             b&#x27;)))
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  /-- In a normed field, `cau_seq` coincides with the usual notion of Cauchy sequences. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  lemma cau_seq_iff_cauchy_seq {α : Type u} [normed_field α] {u : ℕ → α} :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='blue'><a title='normed_field'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 293, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A normed field is a field with a norm satisfying ∥x y∥ = ∥x∥ ∥y∥.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92    is_cau_seq norm u ↔ cauchy_seq u :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='is_cau_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='cauchy_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : discrete_linear_ordered_field.{u_1} α] {β : Type u_2} [_inst_2 : ring.{u_2} β], (β → α) → (nat → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_5} [c : has_norm.{u_5} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : uniform_space.{u} α] [_inst_2 : lattice.semilattice_sup.{v} β], (β → α) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='A sequence is Cauchy if the distance between its entries tends to zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title=' Cauchy sequences. Usually defined on ℕ, but often it is also useful to say that a function
defined on ℝ is Cauchy at +∞ to deduce convergence. Therefore, we define it in a type class that
is general enough to cover both ℕ and ℝ, which are the main motivating examples.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  ⟨λh, cau_seq.cauchy_seq ⟨u, h⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='cau_seq.cauchy_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 71, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_cau_seq.{0 u} real real.discrete_linear_ordered_field α (@normed_ring.to_ring.{u} α (@normed_field.to_normed_ring.{u} α _inst_2)) (@has_norm.norm.{u} α (@normed_field.to_has_norm.{u} α _inst_2)) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {β : Type u} [_inst_1 : normed_field.{u} β] (f : @cau_seq.{0 u} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{u} β (@normed_field.to_normed_ring.{u} β _inst_1)) (@has_norm.norm.{u} β (@normed_field.to_has_norm.{u} β _inst_1))), @cauchy_seq.{u 0} β nat (@metric_space.to_uniform_space&#x27;.{u} β (@normed_field.to_metric_space.{u} β _inst_1)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) (@coe_fn.{(max 1 (u+1)) (max 1 (u+1))} (@cau_seq.{0 u} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{u} β (@normed_field.to_normed_ring.{u} β _inst_1)) (@has_norm.norm.{u} β (@normed_field.to_has_norm.{u} β _inst_1))) (@cau_seq.has_coe_to_fun.{0 u} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{u} β (@normed_field.to_normed_ring.{u} β _inst_1)) (@has_norm.norm.{u} β (@normed_field.to_has_norm.{u} β _inst_1))) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='nat → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@is_cau_seq.{0 u} real real.discrete_linear_ordered_field α (@normed_ring.to_ring.{u} α (@normed_field.to_normed_ring.{u} α _inst_2)) (@has_norm.norm.{u} α (@normed_field.to_has_norm.{u} α _inst_2)) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94   λh, h.is_cau_seq⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='cauchy_seq.is_cau_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;line&#x27;: 57, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@cauchy_seq.{u 0} α nat (@metric_space.to_uniform_space&#x27;.{u} α (@normed_field.to_metric_space.{u} α _inst_2)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@cauchy_seq.{u 0} α nat (@metric_space.to_uniform_space&#x27;.{u} α (@normed_field.to_metric_space.{u} α _inst_2)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {β : Type u} [_inst_1 : normed_field.{u} β] {f : nat → β}, @cauchy_seq.{u 0} β nat (@metric_space.to_uniform_space&#x27;.{u} β (@normed_field.to_metric_space.{u} β _inst_1)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) f → @is_cau_seq.{0 u} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{u} β (@normed_field.to_normed_ring.{u} β _inst_1)) (@has_norm.norm.{u} β (@normed_field.to_has_norm.{u} β _inst_1)) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  /-- A complete normed field is complete as a metric space, as Cauchy sequences converge by</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  assumption and this suffices to characterize completeness. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  @[priority 100] -- see Note [lower instance priority]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  instance complete_space_of_cau_seq_complete [cau_seq.is_complete β norm] : complete_space β :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='blue'><a title='cau_seq.is_complete'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='complete_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq_completion.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/cauchy.lean&#x27;, &#x27;line&#x27;: 139, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='Π {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] (β : Type v) [_inst_2 : ring.{v} β] (abv : β → α) [_inst_3 : @is_absolute_value.{0 v} α _inst_1 β _inst_2 abv], Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_5} [c : has_norm.{u_5} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                                           </code><font color='orange'><a title='A complete space is defined here using uniformities. A uniform space
 is complete if every Cauchy filter converges.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1)
⊢ @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    apply complete_of_cauchy_seq_tendsto,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='metric.complete_of_cauchy_seq_tendsto'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 639, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_1 : metric_space.{v} α], (∀ (u : nat → α), @cauchy_seq.{v 0} α nat (@metric_space.to_uniform_space&#x27;.{v} α _inst_1) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) u → @Exists.{v+1} α (λ (a : α), @filter.tendsto.{0 v} nat α u (@filter.at_top.{0} nat (@partial_order.to_preorder.{0} nat (@ordered_comm_monoid.to_partial_order.{0} nat (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring))))) (@nhds.{v} α (@uniform_space.to_topological_space.{v} α (@metric_space.to_uniform_space&#x27;.{v} α _inst_1)) a))) → @complete_space.{v} α (@metric_space.to_uniform_space&#x27;.{v} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1)
⊢ @complete_space.{v} β (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1)
⊢ ∀ (u : nat → β),
    @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
      u →
    @Exists.{v+1} β
      (λ (a : β),
         @filter.tendsto.{0 v} nat β u
           (@filter.at_top.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@ordered_comm_monoid.to_partial_order.{0} nat
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
           (@nhds.{v} β
              (@uniform_space.to_topological_space.{v} β
                 (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    assume u hu,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1)
⊢ ∀ (u : nat → β),
    @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
      u →
    @Exists.{v+1} β
      (λ (a : β),
         @filter.tendsto.{0 v} nat β u
           (@filter.at_top.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@ordered_comm_monoid.to_partial_order.{0} nat
                    (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                       (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
           (@nhds.{v} β
              (@uniform_space.to_topological_space.{v} β
                 (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
              a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u
⊢ @Exists.{v+1} β
    (λ (a : β),
       @filter.tendsto.{0 v} nat β u
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103    have C : is_cau_seq norm u := cau_seq_iff_cauchy_seq.2 hu,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_cau_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_norm.norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='cau_seq_iff_cauchy_seq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='hu'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 23, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 91, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] {β : Type v} [_inst_2 : ring.{v} β], (β → α) → (nat → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v} [c : has_norm.{v} α], α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} [_inst_2 : normed_field.{v} α] {u : nat → α}, iff (@is_cau_seq.{0 v} real real.discrete_linear_ordered_field α (@normed_ring.to_ring.{v} α (@normed_field.to_normed_ring.{v} α _inst_2)) (@has_norm.norm.{v} α (@normed_field.to_has_norm.{v} α _inst_2)) u) (@cauchy_seq.{v 0} α nat (@metric_space.to_uniform_space&#x27;.{v} α (@normed_field.to_metric_space.{v} α _inst_2)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) u)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A sequence is Cauchy if the distance between its entries tends to zero.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='In a normed field, `cau_seq` coincides with the usual notion of Cauchy sequences.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u
⊢ @Exists.{v+1} β
    (λ (a : β),
       @filter.tendsto.{0 v} nat β u
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u
⊢ @Exists.{v+1} β
    (λ (a : β),
       @filter.tendsto.{0 v} nat β u
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104    existsi cau_seq.lim ⟨u, C⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='cau_seq.lim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq_completion.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 18}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] {β : Type v} [_inst_2 : ring.{v} β] {abv : β → α} [_inst_3 : @is_absolute_value.{0 v} α _inst_1 β _inst_2 abv] [_inst_4 : @cau_seq.is_complete.{0 v} α _inst_1 β _inst_2 abv _inst_3], @cau_seq.{0 v} α _inst_1 β _inst_2 abv → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u
⊢ @Exists.{v+1} β
    (λ (a : β),
       @filter.tendsto.{0 v} nat β u
         (@filter.at_top.{0} nat
            (@partial_order.to_preorder.{0} nat
               (@ordered_comm_monoid.to_partial_order.{0} nat
                  (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                     (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
         (@nhds.{v} β
            (@uniform_space.to_topological_space.{v} β
               (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u
⊢ @filter.tendsto.{0 v} nat β u
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
          (@normed_field.is_absolute_value.{v} β _inst_1)
          _inst_2
          (@subtype.mk.{(max 1 (v+1))} (nat → β)
             (λ (f : nat → β),
                @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                  f)
             u
             C)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105    rw metric.tendsto_at_top,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='metric.tendsto_at_top'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 496, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type v} {β : Type} [_inst_1 : metric_space.{v} α] [_inst_2 : nonempty.{1} β] [_inst_3 : lattice.semilattice_sup.{0} β] {u : β → α} {a : α}, iff (@filter.tendsto.{0 v} β α u (@filter.at_top.{0} β (@partial_order.to_preorder.{0} β (@lattice.semilattice_sup.to_partial_order.{0} β _inst_3))) (@nhds.{v} α (@uniform_space.to_topological_space.{v} α (@metric_space.to_uniform_space&#x27;.{v} α _inst_1)) a)) (∀ (ε : real), @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) → @Exists.{1} β (λ (N : β), ∀ (n : β), @ge.{0} β (@preorder.to_has_le.{0} β (@partial_order.to_preorder.{0} β (@lattice.semilattice_sup.to_partial_order.{0} β _inst_3))) n N → @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{v} α (@metric_space.to_has_dist.{v} α _inst_1) (u n) a) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u
⊢ @filter.tendsto.{0 v} nat β u
    (@filter.at_top.{0} nat
       (@partial_order.to_preorder.{0} nat
          (@ordered_comm_monoid.to_partial_order.{0} nat
             (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} nat
                (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} nat nat.ordered_semiring)))))
    (@nhds.{v} β
       (@uniform_space.to_topological_space.{v} β
          (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1)))
       (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
          (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
          (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
          (@normed_field.is_absolute_value.{v} β _inst_1)
          _inst_2
          (@subtype.mk.{(max 1 (v+1))} (nat → β)
             (λ (f : nat → β),
                @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                  f)
             u
             C)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u
⊢ ∀ (ε : real),
    @gt.{0} real real.has_lt ε
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) →
    @Exists.{1} nat
      (λ (N : nat),
         ∀ (n : nat),
           @ge.{0} nat
             (@preorder.to_has_le.{0} nat
                (@partial_order.to_preorder.{0} nat
                   (@lattice.semilattice_sup.to_partial_order.{0} nat
                      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
             n
             N →
           @has_lt.lt.{0} real real.has_lt
             (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
                (u n)
                (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                   (@normed_field.is_absolute_value.{v} β _inst_1)
                   _inst_2
                   (@subtype.mk.{(max 1 (v+1))} (nat → β)
                      (λ (f : nat → β),
                         @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                           f)
                      u
                      C)))
             ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106    assume ε εpos,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u
⊢ ∀ (ε : real),
    @gt.{0} real real.has_lt ε
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) →
    @Exists.{1} nat
      (λ (N : nat),
         ∀ (n : nat),
           @ge.{0} nat
             (@preorder.to_has_le.{0} nat
                (@partial_order.to_preorder.{0} nat
                   (@lattice.semilattice_sup.to_partial_order.{0} nat
                      (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
             n
             N →
           @has_lt.lt.{0} real real.has_lt
             (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
                (u n)
                (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                   (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                   (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                   (@normed_field.is_absolute_value.{v} β _inst_1)
                   _inst_2
                   (@subtype.mk.{(max 1 (v+1))} (nat → β)
                      (λ (f : nat → β),
                         @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                           f)
                      u
                      C)))
             ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u,
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @Exists.{1} nat
    (λ (N : nat),
       ∀ (n : nat),
         @ge.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           n
           N →
         @has_lt.lt.{0} real real.has_lt
           (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
              (u n)
              (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                 (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                 (@normed_field.is_absolute_value.{v} β _inst_1)
                 _inst_2
                 (@subtype.mk.{(max 1 (v+1))} (nat → β)
                    (λ (f : nat → β),
                       @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                         f)
                    u
                    C)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    cases (cau_seq.equiv_lim ⟨u, C⟩) _ εpos with N hN,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='cau_seq.equiv_lim'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='εpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/cau_seq_completion.lean&#x27;, &#x27;line&#x27;: 169, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : discrete_linear_ordered_field.{0} α] {β : Type v} [_inst_2 : ring.{v} β] {abv : β → α} [_inst_3 : @is_absolute_value.{0 v} α _inst_1 β _inst_2 abv] [_inst_4 : @cau_seq.is_complete.{0 v} α _inst_1 β _inst_2 abv _inst_3] (s : @cau_seq.{0 v} α _inst_1 β _inst_2 abv), @has_equiv.equiv.{(max 1 (v+1))} (@cau_seq.{0 v} α _inst_1 β _inst_2 abv) (@setoid_has_equiv.{(max 1 (v+1))} (@cau_seq.{0 v} α _inst_1 β _inst_2 abv) (@cau_seq.equiv.{0 v} α _inst_1 β _inst_2 abv _inst_3)) s (@cau_seq.const.{0 v} α _inst_1 β _inst_2 abv _inst_3 (@cau_seq.lim.{0 v} α _inst_1 β _inst_2 abv _inst_3 _inst_4 s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='nat → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u,
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @Exists.{1} nat
    (λ (N : nat),
       ∀ (n : nat),
         @ge.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           n
           N →
         @has_lt.lt.{0} real real.has_lt
           (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
              (u n)
              (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                 (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                 (@normed_field.is_absolute_value.{v} β _inst_1)
                 _inst_2
                 (@subtype.mk.{(max 1 (v+1))} (nat → β)
                    (λ (f : nat → β),
                       @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                         f)
                    u
                    C)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u,
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                           (@normed_field.is_absolute_value.{v} β _inst_1)))))
               (@subtype.mk.{(max 1 (v+1))} (nat → β)
                  (λ (f : nat → β),
                     @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                       (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                       (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                       f)
                  u
                  C)
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                  (@normed_field.is_absolute_value.{v} β _inst_1)
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                     (@normed_field.is_absolute_value.{v} β _inst_1)
                     _inst_2
                     (@subtype.mk.{(max 1 (v+1))} (nat → β)
                        (λ (f : nat → β),
                           @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                             f)
                        u
                        C))))
            j))
      ε
⊢ @Exists.{1} nat
    (λ (N : nat),
       ∀ (n : nat),
         @ge.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           n
           N →
         @has_lt.lt.{0} real real.has_lt
           (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
              (u n)
              (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                 (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                 (@normed_field.is_absolute_value.{v} β _inst_1)
                 _inst_2
                 (@subtype.mk.{(max 1 (v+1))} (nat → β)
                    (λ (f : nat → β),
                       @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                         f)
                    u
                    C)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    existsi N,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='N'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 981, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='nat'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`existsi e` will instantiate an existential quantifier in the target with `e` and leave the instantiated body as the new target. More generally, it applies to any inductive type with one constructor and at least two arguments, applying the constructor with `e` as the first argument and leaving the remaining arguments as goals.

`existsi [e₁, ..., eₙ]` iteratively does the same for each expression in the list.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='existsi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u,
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                           (@normed_field.is_absolute_value.{v} β _inst_1)))))
               (@subtype.mk.{(max 1 (v+1))} (nat → β)
                  (λ (f : nat → β),
                     @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                       (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                       (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                       f)
                  u
                  C)
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                  (@normed_field.is_absolute_value.{v} β _inst_1)
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                     (@normed_field.is_absolute_value.{v} β _inst_1)
                     _inst_2
                     (@subtype.mk.{(max 1 (v+1))} (nat → β)
                        (λ (f : nat → β),
                           @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                             f)
                        u
                        C))))
            j))
      ε
⊢ @Exists.{1} nat
    (λ (N : nat),
       ∀ (n : nat),
         @ge.{0} nat
           (@preorder.to_has_le.{0} nat
              (@partial_order.to_preorder.{0} nat
                 (@lattice.semilattice_sup.to_partial_order.{0} nat
                    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
           n
           N →
         @has_lt.lt.{0} real real.has_lt
           (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
              (u n)
              (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                 (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                 (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                 (@normed_field.is_absolute_value.{v} β _inst_1)
                 _inst_2
                 (@subtype.mk.{(max 1 (v+1))} (nat → β)
                    (λ (f : nat → β),
                       @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                         (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                         (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                         f)
                    u
                    C)))
           ε)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u,
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                           (@normed_field.is_absolute_value.{v} β _inst_1)))))
               (@subtype.mk.{(max 1 (v+1))} (nat → β)
                  (λ (f : nat → β),
                     @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                       (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                       (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                       f)
                  u
                  C)
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                  (@normed_field.is_absolute_value.{v} β _inst_1)
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                     (@normed_field.is_absolute_value.{v} β _inst_1)
                     _inst_2
                     (@subtype.mk.{(max 1 (v+1))} (nat → β)
                        (λ (f : nat → β),
                           @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                             f)
                        u
                        C))))
            j))
      ε
⊢ ∀ (n : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      n
      N →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) (u n)
         (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
            (@normed_field.is_absolute_value.{v} β _inst_1)
            _inst_2
            (@subtype.mk.{(max 1 (v+1))} (nat → β)
               (λ (f : nat → β),
                  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                    f)
               u
               C)))
      ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    simpa [dist_eq_norm] using hN</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='dist_eq_norm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hN'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/analysis/normed_space/basic.lean&#x27;, &#x27;line&#x27;: 82, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : normed_group.{?l_1} α] (g h : α), @eq.{1} real (@has_dist.dist.{?l_1} α (@metric_space.to_has_dist.{?l_1} α (@normed_group.to_metric_space.{?l_1} α _inst_1)) g h) (@has_norm.norm.{?l_1} α (@normed_group.to_has_norm.{?l_1} α _inst_1) (@has_sub.sub.{?l_1} α (@add_group_has_sub.{?l_1} α (@add_comm_group.to_add_group.{?l_1} α (@normed_group.to_add_comm_group.{?l_1} α _inst_1))) g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (j : nat), @ge.{0} nat nat.has_le j N → @has_lt.lt.{0} real (@preorder.to_has_lt.{0} real (@partial_order.to_preorder.{0} real (@ordered_comm_monoid.to_partial_order.{0} real (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real (@ordered_ring.to_ordered_semiring.{0} real (@linear_ordered_ring.to_ordered_ring.{0} real (@linear_ordered_field.to_linear_ordered_ring.{0} real (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real real.discrete_linear_ordered_field))))))))) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1) (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@has_sub.sub.{v} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@add_group_has_sub.{v} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@add_comm_group.to_add_group.{v} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@ring.to_add_comm_group.{v} (@cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))) (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) (@normed_field.is_absolute_value.{v} β _inst_1))))) (@subtype.mk.{(max 1 (v+1))} (nat → β) (λ (f : nat → β), @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) f) u C) (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) (@normed_field.is_absolute_value.{v} β _inst_1) (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) (@normed_field.is_absolute_value.{v} β _inst_1) _inst_2 (@subtype.mk.{(max 1 (v+1))} (nat → β) (λ (f : nat → β), @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1)) (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)) f) u C)))) j)) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='β : Type v,
_inst_1 : normed_field.{v} β,
_inst_2 :
  @cau_seq.is_complete.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    (@normed_field.is_absolute_value.{v} β _inst_1),
u : nat → β,
hu :
  @cauchy_seq.{v 0} β nat (@metric_space.to_uniform_space&#x27;.{v} β (@normed_field.to_metric_space.{v} β _inst_1))
    (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot)
    u,
C :
  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
    u,
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
N : nat,
hN :
  ∀ (j : nat),
    @ge.{0} nat nat.has_le j N →
    @has_lt.lt.{0} real
      (@preorder.to_has_lt.{0} real
         (@partial_order.to_preorder.{0} real
            (@ordered_comm_monoid.to_partial_order.{0} real
               (@ordered_cancel_comm_monoid.to_ordered_comm_monoid.{0} real
                  (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} real
                     (@ordered_ring.to_ordered_semiring.{0} real
                        (@linear_ordered_ring.to_ordered_ring.{0} real
                           (@linear_ordered_field.to_linear_ordered_ring.{0} real
                              (@discrete_linear_ordered_field.to_linear_ordered_field.{0} real
                                 real.discrete_linear_ordered_field)))))))))
      (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)
         (@coe_fn.{(max 1 (v+1)) (max 1 (v+1))}
            (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@cau_seq.has_coe_to_fun.{0 v} real real.discrete_linear_ordered_field β
               (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
               (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
            (@has_sub.sub.{v}
               (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
               (@add_group_has_sub.{v}
                  (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                  (@add_comm_group.to_add_group.{v}
                     (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                        (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                        (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                     (@ring.to_add_comm_group.{v}
                        (@cau_seq.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1)))
                        (@cau_seq.ring.{0 v} real real.discrete_linear_ordered_field β
                           (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                           (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                           (@normed_field.is_absolute_value.{v} β _inst_1)))))
               (@subtype.mk.{(max 1 (v+1))} (nat → β)
                  (λ (f : nat → β),
                     @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                       (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                       (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                       f)
                  u
                  C)
               (@cau_seq.const.{0 v} real real.discrete_linear_ordered_field β
                  (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                  (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                  (@normed_field.is_absolute_value.{v} β _inst_1)
                  (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
                     (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                     (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                     (@normed_field.is_absolute_value.{v} β _inst_1)
                     _inst_2
                     (@subtype.mk.{(max 1 (v+1))} (nat → β)
                        (λ (f : nat → β),
                           @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                             (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                             (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                             f)
                        u
                        C))))
            j))
      ε
⊢ ∀ (n : nat),
    @ge.{0} nat
      (@preorder.to_has_le.{0} nat
         (@partial_order.to_preorder.{0} nat
            (@lattice.semilattice_sup.to_partial_order.{0} nat
               (@lattice.semilattice_sup_bot.to_semilattice_sup.{0} nat lattice.nat.semilattice_sup_bot))))
      n
      N →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{v} β (@metric_space.to_has_dist.{v} β (@normed_field.to_metric_space.{v} β _inst_1)) (u n)
         (@cau_seq.lim.{0 v} real real.discrete_linear_ordered_field β
            (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
            (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
            (@normed_field.is_absolute_value.{v} β _inst_1)
            _inst_2
            (@subtype.mk.{(max 1 (v+1))} (nat → β)
               (λ (f : nat → β),
                  @is_cau_seq.{0 v} real real.discrete_linear_ordered_field β
                    (@normed_ring.to_ring.{v} β (@normed_field.to_normed_ring.{v} β _inst_1))
                    (@has_norm.norm.{v} β (@normed_field.to_has_norm.{v} β _inst_1))
                    f)
               u
               C)))
      ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font></pre>
</body>